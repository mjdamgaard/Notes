\documentclass{report}
\usepackage[utf8]{inputenc}


%\usepackage{amsmath}

%\usepackage[toc, page]{appendix}
%\usepackage[nottoc, numbib]{tocbibind}
\usepackage[nottoc]{tocbibind}
\usepackage[bookmarks=true]{hyperref}
\usepackage[numbered]{bookmark}

%%%\usepackage{hyperref}     
%%%\usepackage{amsthm}     
%%\usepackage{cleveref}
%\usepackage{silence}
%\WarningFilter{pdftex}{destination with the same}

\hypersetup{
	colorlinks	= true,
	urlcolor	= blue,
	linkcolor	= black,
	citecolor	= black
}

\usepackage{comment}

\usepackage{lipsum}


\title{
	Note collection (2023--20xx)
	\author{Mads J.\ Damgaard%
		%\footnote{
		%	See https://www.github.com/mjdamgaard/notes for potential updates, additional points, and other work.
		%}
		%\footnote{
		%	B.Sc.\ at the Niels Bohr Institute, University of Copenhagen.
		%	B.Sc.\ at the Department of Computer Science, University of Copenhagen.
		%	E-mail: fxn318@alumni.ku.dk.
		%	GitHub folder: https://www.github.com/mjdamgaard/notes.
		%}
	}
}

\usepackage[margin=1.5in]{geometry}

\begin{document}
\maketitle

\section*{Foreword}
{\centering\noindent
	\vspace{-\baselineskip}
	\hspace{-0.7em}
	{\hspace{-4.em}$|$\hspace{\linewidth}\hspace{8em}$|$}
}
Note collection from 10.01.23--???. 

%Kopieret nedenfra:
	%"(10.01.23) Okay, jeg har lige påbegyndt dette notesæt. Jeg er pt. i gang med at skrive version 2 (en meget mere simpel udgave) af min SRC-artikel, og så har jeg ikke kunne lade være med at bruge en del af tiden (som jeg "burde" have brugt på at skrive om SRC) på at tænke mere over, hvordan jeg ville starte mine hjemmesider, jeg har i tankerne, hvis jeg selv skulle gå i gang (hvad jeg faktisk stærkt overvejer). Særligt har jeg tænkt nogle tanker om en alternativ opsætning end den med fanerne, når det kommer til hele den applikation der. De tanker vil jeg skrive ned, når jeg vender tilbage her, sikkert senere i dag/aften. (For inden da vil jeg lige fortsætte lidt mere med SRC-arbejdet.) (17:17)"
%

\ 

\lipsum[1]


\chapter{Web ideas}

%(10.01.23) Okay, jeg har lige påbegyndt dette notesæt. Jeg er pt. i gang med at skrive version 2 (en meget mere simpel udgave) af min SRC-artikel, og så har jeg ikke kunne lade være med at bruge en del af tiden (som jeg "burde" have brugt på at skrive om SRC) på at tænke mere over, hvordan jeg ville starte mine hjemmesider, jeg har i tankerne, hvis jeg selv skulle gå i gang (hvad jeg faktisk stærkt overvejer). Særligt har jeg tænkt nogle tanker om en alternativ opsætning end den med fanerne, når det kommer til hele den applikation der. De tanker vil jeg skrive ned, når jeg vender tilbage her, sikkert senere i dag/aften. (For inden da vil jeg lige fortsætte lidt mere med SRC-arbejdet.) (17:17)

\section{Nye tanker om, hvordan Web 2.0--3.0-siden kunne være til at starte med (10.01.23)}

(17:58, 10.01.23) Jeg har nogle nye tanker om, hvad jeg gør mht.\ mine hjemmeside-idéer. Sidst jeg skrev om det var for ret kort tid siden i mine 22--23-huskenoter, og inden da har jeg skrevet nogle tanker ned i det, der endte med at blive udkommenterede noter under SRC-artiklen (version 1). Men jeg har nu skiftet mening siden de noter. Jeg tænker således ikke længere på at starte med det der fane-værk. Nu har jeg en anden indledende opsætning i tankerne.

Men inden jeg går i gang med at beskrive den opsætning, så lad mig også lige sige, at jeg nu faktisk tænker at fokusere mest på web-applikationen, der har med semantiske strukturer, tag-ratings, opdelte kommentarer, ``automatiske point'' (og ``brugergrupper'') osv.\ at gøre, og derudover så også min debatside-applikation. Og jeg tænker så altså lidt at starte med førstnævnte emne, og så også tænke på at tilføje en debatside-applikation til den hjemmeside også inden for en nær fremtid efter, at jeg har fået den første applikation i gang. Desuden tænker jeg nu at gøre det open source. Jeg tænker altså ikke længere på at fokusere på at starte en SRC omkring det. I forhold til det monetære, så synes jeg nemlig, det er bedre at gøre dette i et separat lag oven over det applikationsmæssige lag. Så jeg tænker dermed altså, at den monetære del bare skal implementeres via donationer, og muligvis særligt via en donationsforening, ligesom.\,.

Ok. Nej, vent. Og fordi jeg vil gøre det helt open source, så tænker jeg altså også bare at tage med arme og ben fra andre open source-hjemmesider. Særligt kunne det være smart at tage fra en YouTube-agtig open source applikation og en Reddit/Twitter-agtig (måske Mastodon) applikation.\,. Og så altså derfra påsætte min.\,. hm, lad mig bare kalde det min `semantik-applikation' for nu; det er nemmere end, hvad jeg ellers har haft gang i (så som min ``Web 2.0--3.0-hjemmeside''). Jeg vil altså prøve at påsætte den applikation oven på de andre --- og efterfølgende påsætte en debatside-applikation oveni, så det bliver altså lidt af en Schweizerkniv-hjemmeside, men hvorfor ikke?\,. (sagde han helt naivt.\,. ej, jeg håber, det kommer til at give god mening sådan, 7, 9, 13).\,. 

Nå, og nu til at forklare, hvordan jeg tænker min semantiske applikation nu --- og det er ved at blive småsent, så jeg ser bare, hvor langt jeg når (og hvor sammenhængende det bliver), og så må jeg samle tråden op igen en af de kommende dage.

Som jeg forestiller mig min semantiske applikation nu (altså hvordan den kunne starte med at se ud rettere, for i fremtiden kan den så få alle mulige former, det er jo en del af det (altså at brugerne selv skal have frihed til at ændre udseendet)), så forestiller jeg mig altså bare en enkelt HTML-side, hvor at når man ser på lister over ressourcer, hvilket bliver en rigtig central del af applikationens brug, så er dette altså bare en liste midt på HTML-siden. Dog skal der så være en menu i siden, som gerne skal kunne være fold-ud. Denne menu bliver så til, hvad vi kan betragte som brugerens ``workspace.'' (Lad mig kalde det `arbejdsbord' på dansk.) .\,.\,Hm, lad mig lige holde en pause, og så ser jeg lige på, om jeg vender tilbage, eller om jeg bare holder for i dag.\,. (18:22)

(12.01.23, 16:58) I forgårs aften fik jeg tænkt lidt flere gode idéer omkring opbygningen, særligt af fold-ud-menuen. Men lad mig lige starte med at gie en helt grundlæggende beskrivelse, og så kan jeg føje flere detaljer til bagefter.

Lad os forestille os at en bruger kigger på kategorien `film,' og har valgt, ikke at se på en liste over film, men valgt at se en liste over underkategorier til kategorien `film.' Bemærk altså at `film' er implementeret, ikke som et er\_film-prædikat, men som et term simpelthen. Lad os så sige, at brugeren vælger `komediefilm.' Brugeren føjer hermed dette term til sit arbejdsbord, ved siden af `film.' Dette term ligger altså nu i fold-ud-menuen. Brugeren kan så nu i princippet gå til fold-ud-menuen og vælge en knap, der skifter visningen fra underkategorier\_af(term) til termer\_af\_kategorien(term). Og ved så at vælge `komediefilm' fra menuen (der også indeholder brugeren arbejdsbord nemlig), så får brugeren altså nu en liste over alle de termer, som passer på termer\_af\_kategorien(komediefilm). Dette er altså en mulig vej for brugeren i princippet, men allerede i prototypen af hjemmesiden skal det altså gerne være indbygget som en standard ting, at når brugeren har en liste over kategorier, så er der også en knap der gør disse ting på én gang, nemlig tilføjer kategorien til arbejdsbordet og går direkte hen til visningen af termer\_af\_kategorien(term), hvor inputtet så er den valgte kategori. 

Nu ser brugeren så en liste af ressourcer (komediefilm i dette tilfælde). Nu vil brugeren så måske gerne lægge et specifikt filter over denne liste, så kun visse ting bliver vist og i en vis rækkefølge. Nu kan brugeren så i fold-ud-menuen vælge en knap til at se, hvad vi kunne kalde filter-prædikater. Lad os sige, at brugeren allerede har browset film mange gange før og derfor har alle de almindelige filter-prædikater klar såsom `populær,' `godt bedømt' osv., men af en eller anden grund mangler prædikatet `sjov' i listen. Nu vil brugeren så gerne finde et sådant prædikat frem. Dette kan så gøres af to primære vejen, foruden at brugeren selvfølgelig kan lave en normal, ikke-semantisk søgning på prædikatet, hvilket man i praksis ofte vil gøre med tiden, men jeg har dog ikke i sinde at fokusere særligt på den mulighed med min prototype. I stedet kan brugeren enten gå til en grundlæggende visning over prædikat-kategorier, og så navigere frem til det ønskede prædikat, nemlig på samme måde som da brugeren navigerede til `komediefilm,' bare hvor brugeren altså nu søger i prædikat-kategorier (og til sidst -termer) og ikke i ressource-kategorier (og til sidst -termer). Når brugeren så har fundet prædikatet `sjov,' kan denne så tilføje det til arbejdsbordet, hvorved det så bliver vist i filter-prædikat-delmenuen. Ellers kan brugeren også forsøge at vælge en liste over prædikater\_relaterede\_til(term), hvor brugeren så kan vælge et term fra arbejdsbordet at putte ind her som input. Og her vil det jo så være oplagt, at brugeren inputter `komediefilm.' Den resulterende liste over prædikater kan så forestilles at indeholde det søgte prædikat (rimeligt tidligt i listen), og brugen kan så vælge det fra denne liste direkte. 

Når brugeren nu har tilføjet `sjov' til sine filter-prædikater, så kan brugeren nu gå tilbage og se termer\_af\_kategorien(komediefilm). Her kunne brugeren med fordel have valgt at navigere væk fra denne visning i første omgang med et midterklik, eller med ctrl + klik, således at den midlertidige søgning på prædikatet foregik i en ny fane. Pointen er nemlig, at arbejdsbordet skal ændres på tværs af faner (hvis brugeren altså bliver i det samme workspace, men det kommer vi til). I så fald kan brugeren bare klikke tilbage til browserfanen, hvor han/hun kom fra, og får herved nu vist `sjov' i filter-prædikat-menuen. 

Nu kan brugeren så tilpasse filteret mht.\ dette prædikat, hvilket indebærer at basalt set indstille en kurve over en akse for, hvor `sjov' filmen er. Jeg forstiller mig således en todelt gaussisk kurve, som altså næsten er en gaussfunktion, bortset fra at den kan have to forskellige spredninger til hver side (så altså en asymmetrisk version af en gausskurve). I dette tilfælde vil brugeren så sandsynligvis ønske at sætte toppunktet for kurven i enden, hvor `sjov' er mest gældende. Herefter kan brugeren så bestemme spredningen til den eneste af de to sider, der her er relevante. Og sidst men ikke mindst skal brugeren også kunne indstille en min- og en maks-værdi til filteret, således at for eksempel ingen film bliver vist, der har under en vis `sjov'-score. 

Jeg forestiller mig mere specifikt dermed at brugeren får vist tre barer, når brugeren folder indstillingerne ud for et filter-prædikat: Den første har én knap, der kan bevæges over hele baren, og som bestemmer kurvens toppunkt. Den næste bar kunne så være til at indstille de to spredninger og kunne så være en todelt bar, hvor knappen i hver siden kan sættes tæt på midten eller tæt på den respektive ende af baren, alt efter om spredningen til den side skal være lille eller stor (helt flad kurve, hvis man sætter dem i endepunkterne). Den sidste bar kan så være to knapper, der også kan sættes hvor som helst, og som så angiver min- og maks-værdierne for filteret. Imens brugeres finindstiller filter-prædikatet således, forestiller jeg mig, at brugeren også for vist den pågældende kurve i en lille graf over barerne. 

Nu kunne man så tro, at brugeren bare vil tage en virkelig lille spredning for kun at vise de film, der er har fået de allerhøjeste `sjov'-scorer, men i så fald ville de andre filter-prædikater, såsom f.eks.\ `godt bedømt' *(`god,' rettere) blive ubetydende, og derfor kan det altså ofte give god mening ikke at gøre kurverne alt for smalle. 

Cool, lad mig lige tænke over, om der er mere jeg skal sige til denne første lille del-rundgang, og ellers vil jeg gå over til at opsummere detaljerne, som jeg har tænkt mig nu her omkring denne nye opsætning (efter en lille pause.\,.). (17:55)

(18:09) Jo, jeg skal selvfølgelig også lige omkring det her med at rate ressourcer. Lad os sige, at brugeren undrer sig over, at en vis komediefilm kommer enten tidligt eller sent i listen, og så kigger på `sjov'-ratingen og ser, at den ikke ser ud, som brugeren ville forvente/synes. Så bør brugeren så kunne klikke sig ind på en rating-visning, nu hvor.\,. hm, jeg skulle til at skrive, at det er hvor alle andre spredninger er sat til uendeligt og at alle andre kurver end det relevante prædikat dermed bliver til firkantede trinkurver mellem deres valgte min- og maks-værdier i stedet, men er det nu også virkelig ideelt.\,.\,? 

\ldots Ah, man skal selvfølgelig bare have nogle separate filter-indstillinger for at vise rating-lister, og i starten vil de fleste så sikkert kunne nøjes med at bruge et enkelt prædikat udover det pågældende man rater i forhold til, og det er så popularitetsprædikatet. Senere kan man så prøve at implementere nogle indstillinger, hvor brugerne også får prioriteret at vise termer, der er bekendte for brugeren i listen, men det vil så være mere kompliceret at få dette op at køre. Så ja, når brugeren trykker, at denne vil ind og rate termerne, f.eks.\ ift.\ sjovhed i dette tilfælde, så får brugeren altså bare en ny rating-visning, hvor der også er særlige filter-indstillinger til, og hvor brugeren så kan rate ressourcerne/termerne. Og som jeg har forklaret i tidligere noter, så forestiller jeg mig altså her, at brugeren så særligt skal kunne rate termer/ressourcer (ift.\ pågældende prædikat) ved at trække termen op eller ned i listen --- og hvor brugeren kan zoome ind og ud i, hvor mange termer, der vises i listen, hvilket så altså meget vel ofte kunne indebære at indstille på, hvor mange termer vises i listen efter popularitet (altså mere præcist stille på, hvad min-værdien er for popularitet i listen). (Og jeg forestiller mig altså, at brugeren endda kan ``zoome ind og ud'' imens denne trækker en ressource/et term også.) 

Når brugeren så har rykket lidt rundt på termer i denne liste og derved givet dem rating i henhold til pågældende prædikat, kan brugeren jo så gå tilbage til, hvad brugeren egentligt var interesseret i, nemlig at se på en liste over sjove komediefilm. Slut på denne lille overordnede rundgang. Og så kan jeg skrive nogle flere detaljer om disse seneste idéer en anden dag (måske i morgen). (18:58) 

.\,.\,Hm, lad mig lige nævne, at når brugeren skifter type af visning, altså hvis denne f.eks. skifter fra ressource- til prædikat-visninger.\,. hm.\,. .\,.\,Hm, jeg skulle til at skrive noget med, at det ofte gerne må være standarden, at når brugeren går til en anden visning, at der åbnes en ny fane i browseren, men på den anden side er dette svært at sige præcis, hvad der er smartest her. Og måske er det fint, hvis brugeren bare husker at trykke ctrl (eller midterklik) på de rette tidspunkter og, nå ja, så kan brugeren jo altid gå tilbage i browseren --- især idet listerne som regel er simpel HTML, hvilket sikkert vil sige, at browseren endda tit vil kunne huske, hvor i listen brugeren var og dermed kan vende tilbage til samme sted.\,.\,:) 


(13.01.23, 16:40) Nu vil jeg så prøve at tilføje lidt flere detaljer om den opsætning, jeg nu tænker, at prototypen på den semantiske hjemmeside kunne have. Ja, og jeg kan jo starte med at sige, at jeg jo tænker at hjemmesiden kunne have flere applikationer i sig, bl.a.\ en YouTube-agtig applikation og en Reddit-/Twitter-/9gag-agtig applikation, hvor brugere så kan uploade ressourcer i forbindelse med de applikationer, som så derefter også kan findes i den semantiske applikation.

Og hvis vi så ser på den semantiske applikation, så forestiller jeg mig altså en ret central fold-ud-menu, hvor brugerne kan skifte visningen som beskrevet lige her ovenfor. Og når brugeren skifter visningen skal det så bare i prototypen føre til en ændret URL, hvilket så gør at brugerne kan gå frem og tilbage i deres seneste visninger, og åbne flere faner for visninger, ved simpelthen bare at bruge deres browsers velkendte funktionalitet hertil.

Fold-ud-menuen kan så have en liste af faneblade i toppen, der afgør, hvilket workspace brugeren arbejder i. Som sagt, så skal det være sådan, at hvis brugeren føjer en ting til et givent workspace i én fane, så skal ændringen ske i alle faner (som opdateres, når brugeren klikker ind på den igen (eller når brugeren går frem og tilbage i sin sessions browserhistorik)). Men ændringen skal dog kun ske i pågældende workspace.

Nedenunder denne liste kan så være endnu en liste over overordnede undermenuer i fold-ud-menuen. Den mest centrale undermenu er så den, hvor alle de tilføjede termer i workspace'et findes. Jeg forestiller mig, at en mulig løsning her for prototypen kunne være en træ-struktureret menu a la den jeg har her ude i venstre side af min TeXstudio-editor over sektioner og undersektioner (og hvor man så kan folde oversektionerne ind og ud). Sådanne oversigter har sikkert et teknisk navn, men det kender jeg ikke lige på stående fod. Og en endnu simplere løsning, måske til en tidlig version af prototypen, kunne bare være at have en enkelt liste ordnet kronologisk ift.\ hvornår termerne sidst blev brugt/tilføjet. I øvrigt kunne man også tænke sig en blanding af disse muligheder, sådan at man tilføjer endnu en fane af muligheder, hvor den ene så er omtalte træ-struktur-oversigt, og hvor den/de andre bare er lister over seneste brugte og/eller seneste valgte og/eller seneste tilføjet.\,. Ok.

Men udover at se lister over termer (som altså også inkluderer prædikater og relationer --- og også relationer og input-termer sat sammen til prædikater), som så kan bruges til at vælge nye visninger med, så skal der også være en (overordnet) undermenu med filter-prædikater, som nævnt i overordnede tekst. Og der skal være en menu specifikt beregnet til rating-visningerne (altså når brugeren iagttager en liste med udgangspunkt i et specifikt prædikat, som termerne i listen så kan rates i forhold til (gerne ved at brugeren kan flytte op og ned på termer)). 

En anden undermenu, der faktisk bliver ret væsentlig selv på nogenlunde kort sigt, er en hvor brugerne kan vælge indstillinger for, hvordan de gerne vil have diverse ressourcer og lister vist. Her bør man så faktisk ret hurtigt gøre det til en del af applikationen, at brugere kan aktivere CSS styles for diverse ressource-typer. (Og ja, det er en god idé, at man fra start af indfører diverse typer for de forskellige, ja, typer af ressourcer. Så applikation skal altså have et helt typesystem, hvor brugere kan tilføje nye typer, og hvor man så også har indbyggede list-constructor're til at danne list-typer. Her kan der så endda være forskellige typer alt efter om vi f.eks.\ snakker en standard oversigtsliste, eller om vi snakker om en liste beregnet til en rating-visning. Når en bruger opretter en ny ressource-type, så sker dette ved at definere et HTML-template for typen.\,. Tja nej, faktisk to HTML-templates: Et der udgør selve ressourcen, og et der udgør den data, der skal vises, når ressourcen indgår i en listeoversigt over flere ressourcer (f.eks.\ thumbnail og kort beskrivelse og sådan). Indholds-HTML-skabelonen bør så også have datafelter i sig med f.eks.\ titel, tilhørende tekst, og hvad man ellers kan finde på, og hvis ressourcen indeholder et billede eller en video af en art (måske i et eller andet fast format), så skal skabelonen selvfølgelig også indeholde de datafelter. Når så en type er oprettet, og brugere skal uploade andre instanser af typen, så skal de så bare uploade data af passende formater, der passer til felterne i HTML-skabelonen. Og når brugere så får vist ressourcen, så sættes alle disse datafelter altså ind i HTML-skabelonen. Og når brugerne for vist en liste over ressourcer af den pågældende type, så vil elementerne i listen vises i form af den anden HTML-skabelon, hvor det passende data (så som f.eks. thumbnail og kort beskrivelse) er loadet ind. Og for så at vende tilbage til den undermenu, som vi startede med at snakke om, så skal brugere altså gerne kunne indstille, hvordan diverse typer helt præcist skal vises, bl.a. ved at vælge CSS-indstillinger. Og på sigt (gerne kort sigt) skal brugerne endda og også få mulighed for at ændre i og lave tilføjelser til selve HTML'en (ligesom browserudvidelser fungerer), sådan at de kan få vist det lige som de vil have det. 

I øvrigt, og det gælder både, når brugere opretter HTML-skabelonerne, og når brugere opretter udvidelser til eksisterende HTML-skabeloner, så vil det være godt på sigt at få det sådan, at brugere kan lave (div-)felter i skabelonerne, som faktisk får mulighed for at query'e selve hjemmesidens database, og altså vise ting fra denne database. Dette kommer til at gøre, at man kan få levende ressourcer, hvis udseende og struktur kan afhænge af databasens tilstand. For eksempel kunne man lave HTML-skabeloner, der automatisk henter lister over mest relevante ressourcer til pågældende ressource, eller henter kommentarer, ratings, annotationer osv.\ osv.


Det skal så dog nævnes, at den semantiske applikation allerede indeholder en måde, hvorpå brugere kan kommentere ressourcer, nemlig ved at tage termen, der udgør ressourcens reference, og så vælge en relation i den forbindelse, således at man danner et prædikat: er\_kommentarer\_tilhørende\_ressourcen(term), hvor `term' så her er en placeholder for på-gældende ressource. Herved kan man altså gøre kommentarer til ressourcer til en del af den samlede (semantisk strukturerede).\,. database, eller rettere: selve den underlæggende database bør jo (nok) bare være en relationel database, men udefra set får man altså en semantisk struktureret database, og det er altså det jeg mener, når jeg siger en semantisk struktureret database; det er sådan, den ser ud fr brugerne. 


Nå, tilbage til fold-ud-menuen: Derudover kunne det nok også være smart (på sigt) med menuer, mest for de avancerede brugere, til at vælge opsætningsindstillingerne for selve fold-ud-menuen, sådan at selv denne bliver en del af alt det, som brugerne i sidste ende selv kan bestemme opsætningen for.

Ok, så det var altså den overordnede struktur.\,. Nå ja, på nær at jeg også lige kan nævne, at man på sigt også kan åbne op for, at selve applikationen får sin egen måde at have gang i flere visninger på én gang, sådan at dette ikke bare kun opnås via browserens funktionalitet (og ved hele tiden at skifte URL for hver visning). Så på længere sigt skal man måske også gøre, så at brugere kan implementere sådan navigation, og også gerne mulighed for f.eks.\ split-screen-visning, i applikation selv. 

Okay. Det var den gennemgang. Så havde jeg vist lige en eller flere ekstra punkter, som jeg også gerne ville nævne (men som jeg dog har talt om i tidligere noter), hvis jeg ellers kan huske, hvad de var.\,. (Og hvis det altså ikke bare var dem, jeg allerede har nævnt nu her.\,.) .\,.\,Nå, hvis der ar noget mere, så er det lige glippet, så jeg vil bare gå og summe lidt over det, og så ellers bare vende tilbage, når jeg finder nogen tilføjelser, jeg også bør nævne. (17:44)

(14.01.23, 11:48) Okay, der er nogle tilføjelser, jeg mangler, og jeg har også tænkt på lidt nye ting. Jeg mangler at nævne, at al data gerne skal gemmes via, hvad der svarer lidt til tripletter, men hvor de dog ikke behøver at være begrænset til 2-nære relationer; de kan også være 1-ære (altså prædikater) og 3-nære. Der må så vidt jeg kan se også være relationer med endnu flere input en tre, hvis brugerne får behov for dette. Og foruden relation-ID og ID på alle input objekterne (hvilke også kan være placeholders, for man skal f.eks.\ gerne kunne danne prædikater ud fra (f.eks.) en 2-ær relation og en inputterm, so vi har set ovenfor), så skal der også i alle disse udvidede tripletter være bruger-ID for hvem, der siger/har uploadet udsagnet, samt også et tal, der bestemmer hvor meget brugeren mener at udsagnet er sandt, og som i øvrigt også kan være negativt, således at brugeren kan negere udsagnet uden at skulle skifte relation. Dette med at alle udvidede tripletter, som jeg fra nu af vil kalde udsagn, har sådan en floating point rating med sig, er faktisk en super vigtig ting for hele idéen. Uden dette ville applikationen ikke blive nær den samme. .\,.\,Og endda selv for mange relationer, hvor man umiddelbart tror, at man kun er interesseret i at høre en sandt-eller-falsk vurdering fra brugere, kan det alligevel være gavnligt med et floating point-tal --- ikke for alle tilfælde (og så må man bare omfortolke tallet til en binær størrelse), men for mange. For eksempel hvis vi tænker på et udsagn: ``hører denne term til en vis kategori eller ej?'' (som underkategori eller som genstand, der hører til kategorien). Her skulle man tro, at man bare var interesseret i et ja-nej-svar fra brugerne, men faktisk kan det her være rigtigt gavnligt, hvis udsagnene alligevel kan gradbøjes, for nogle underkategorier (eller ressourcer) bare mere relevante end andre, og hermed kunne man altså få en nem måde at gøre, så at når en bruger ser på underkategorier til en kategori, så er det de mest relevante underkategorier, der popper frem øverst på listen. 

Jeg fik heller ikke nævnt noget, jeg ville sige om mine ``brugergrupper,'' som jeg har skrevet en del om i tidligere noter (se disse). Angående dette emne, så tror jeg bare man skal starte med den type ``brugergrupper,'' hvor en vis gruppe af brugere (muligvis bare én) starter med en lige mængde af nogle delelige tokens, der giver dem stemmevægt ift.\ at bedømme udsagn. .\,.\,Hov vent, jamen \emph{skal} vurderingerne så komme med udsagnene, eller skal udsagnene gemmes for sig, og så kan brugeres vurderinger af dem gemmes for sig også.\,.\,? Hm.\,.\,. (12:12) .\,.\,Hm, og brugeren, der uploadede udsagnet, bør i så fald også bare gemmes som et separat udsagn, oprettet automatisk af serveren.\,. hm, så man også kan slette det igen uden at slette brugeren, men hvordan ser man så.\,. Nå jo, i princippet kan serveren så oprette to udsagn for at gemme, at brugeren var ophavsmanden; udsagnet selv og så et udsagn om, at denne server siger, at det var den bruger (med 100\,\% sikkerhed, hvorfor ikke?\,.), der uploadede det originalt (eller rettere set med pågældendes servers øjne (men den siger så ikke noget om, hvorvidt andre brugere var først på andre servere)). Ja, sådan kunne det sagtens være.\,. Hm.\,. \ldots Ja, så nu går jeg faktisk ind for tripletter igen (har jeg ellers ikke gjort i lang tid, mener jeg).\,. .\,.\,Hm, og man kan så faktisk bare droppe de der server-vurderinger,
hvis man bare i stedet gør sådanne, at visse relationer er off-limits ift. hvad brugerne selv kan uploade, nemlig de relationer som er beregnet til at blive ``uploadet''af serveren(erne). 

Nå, men tilbage til ``brugergrupper.'' Omtalte tokens kan så deles i flere, og de kan så efterfølgende gives (delvist) ud til andre brugere. En giver af tokens i en brugergruppe må i reglen godt altid annullere en overførsel af tokens, medmindre.\,. Ja, lad mig sige det sådan her: Tokens kan lånes ud til andre brugere, som kan låne dem videre ad libitum, og hvis så en udlåner af tokens skifter mening, kan denne hive sine tokens tilbage med det samme (uanset hvor mange gange, de er lånt videre). Brugere kan også \emph{give} tokens til andre brugere, nemlig hvis de gerne vil pensioneres som ansvarshaver i brugergruppen. Hver token har så en et floating point number, der bestemmer stemmevægten, som gives af denne. Den samlede stemmevægt summer så op til 1. Og bum, så har man allerede et ret effektivt system til at danne diverse grupper.

Pointen med ``brugergrupper'' er så, at brugere skal have mulighed for, når de indstiller et filter-prædikat, at vælge hvilken/hvilke brugergrupper, som vurderingen skal beregnes ud fra. Så i pågældende menu skal der altså gerne for hver filter-prædikat være en knap til at folde en liste af brugergrupper ud (inkl.\ den basale, hvor alle brugere bare har én stemme), og hvor man så, muligvis ved at indstille vertikale barer tilhørende hver brugergruppe, kan indstille sin vægt til hver brugergruppe i filteret. 

Ok, det var allerede rimeligt dækkende, men jeg har stadig en del flere ting, der skal nævnes, og faktisk også som skal overvejes. Men lad mig starte med en positiv ting, og det er, at brugerne via de ovenfor omtalte HTML-skabelon-udvidelser kan implementere diverse knapper og fold-ud-menuer, når ressourcer af en vis type vises i en liste. For eksempel skal der som en standard være en ``udvidelse'' (som dog altså er standard) til visningen af kategorier i lister.\,. lad mig sige `visning af kategori-\emph{referencer}' fra nu af, som giver mindst to knapper: én hvor brugeren bliver ledt hen til underkategorier (og får kategorien tilføjet til workspacet, om ikke andet så i menuen af `seneste termer' (af typen `kategori')), og én hvor de brugeren bliver ledt hen til en visning over ressourcer/termer i kategorien. .\,.\,Nå ja, og der skal så også gerne være en knap, der leder brugeren hen til en visning over prædikater, der relaterer sig specifikt til den kategori. Denne ``udvidelse'' skal så gerne oprettes, inden applikationen åbnes op for almindelige brugere. 

Og lad mig lige indskyde, at filter-menuen gerne skal have nyligt tilføjede prædikater vist i toppen, da man må regne med, at brugere ikke nær så ofte vil behøve at stille på de typiske prædikater. Men hvis brugere alligevel har nogle typiske prædikater, de gerne tit vil stille på, så skal de så bare have lov til at ``pinne'' dem til toppen af menuen, som man siger. 

\ldots Hm, nu overvejer jeg, om der overhovedet er så mange flere ting, der skal siges i denne omgang, for jeg synes egentligt, at løsningen med hurtigt at arbejde i HTML-udvidelser til referencevisningerne faktisk løser meget af det problem, jeg havde, med at det virkede for indviklet at bruge applikationen i udgangspunket. Jeg tænker lige lidt mere over det, men nu vil jeg ellers bare lige tilføje den idé, at der også skal være en (overordnet) undermenu i fold-ud-menuen (som mange brugere i øvrigt sikkert vil have konstant foldet ud, hvis de arbejder på en computer (ikke en telefon)), som simpelthen er en konsol, hvor brugere kan skrive de udsagn (med placeholders), de gerne vil søge på, og også dem de gerne vil uploade, og hvor der så bør være automatiske forslag til udfyldning af ordene, hvor applikationen altså så (primært) søger i termerne i brugerens workspace, når den skal give forslag til udfyldning af ordene (altså `word completion'). (13:39)  

\ldots\ Der vil også være behov for tokens, der ikke kan videregives af modtager (og som modtager i øvrigt ikke skal acceptere eller afslå, men bare får tildelt sig af en anden). Dette kan f.eks.\ bruges til at flagge spammere; så kan de styrede brugere uddele tokens, enten til alle spammere, eller alle ikke-spammere (som man ikke har mistanke til). Brugere kan så bruge disse bruger-grupper i et er\_spammer- eller et kommer\_fra\_en\_spammer-filterprædikat. (18:03)

(16.01.23, 16:30) Der skal også være en slags automatiske brugergruppe tokens, men nærmere bestemt kan man også kalde dette for `automatiske point.' Vi snakker altså point, som kan gives til brugere --- eller til alle mulige andre termer i databasen, nemlig (og bruger-ID'er indgår nemlig også i databasen som termer) --- ud fra data i databasen om dem. Dette kan så specifikt bruges til at implementere, hvad jeg også i mine tidligere noter har kaldt `brugerdrevet machine learning (ML).' Hvis vi så tager en vis korrelationsegenvektor, når man har lavet ML-statistik over brugerne af applikationen, så kan man altså nu, via disse `automatiske point,' tildele brugere point alt efter, hvor stor projektionen af deres brugerdata ind på på gældende egenvektor er. Og dette kan man jo så bruge videre i diverse filter-indstillinger. For eksempel kunne man forestille sig, at man kunne sige: `sorter disse film ud fra `sjovhed,' med særlig vægt på folks vurderinger, som følger den og den korrelationsvektor. Og ja, man kan i øvrigt også gøre mere simple ting, så som bare at sige: `sorter disse film ud fra `sjovhed,' med særlig vægt på folks vurderinger, der også synes at det og det var sjovt --- altså en mere simpel form for statistisk brug a brugerdata i brugerlavede filteralgoritmer. Mulighederne er virkeligt åbne.

Og måden man så kan query'e databasen om sådanne point kan så bare være ud fra en syntaks, der følger det logiske programmeringsparadigme, nemlig således at pointen både gemmes som tripletter i databasen for hver bruger, og hvor man så kan query'e disse point via den relation, der nu hører til pointene. (16:45) .\,.\,Og lige for at præcisere, så er det altså brugerne selv, der kan uploade forslag til nye automatiske point, nemlig ved at de så uploader den relevante metadata, samt den formel, som det hele handler om, nemlig den formel ud fra hvilken de automatiske point bliver givet til termerne (som i øvrigt i reglen vil være af en bestemt type, som så også defineres som en del af omtalte metadata (eller `header-data' er nok mere rigtigt at kalde det.\,.)). 

(17:13) Jeg havde også i sinde at skrive lidt om, hvordan jeg så forestiller mig, at man også kunne implementere en ``debatside-applikation'' i dette system, hvor brugerne kan bruge dette brugergruppesystem, og jeg kunne måske også finde på nogle små nye tilføjelser i denne forbindelse, men jeg tror nu, jeg bare vil lade emnet være for nu. Jeg har skrevet fint om det, i mine tidligere noter, og selvom jeg sikkert kunne finde på nogle små ting at tilføje, så tror jeg ikke, det vil ændre så meget på idéen overordnet set. Så lad mig lade det emne være for nu. Det ville alligevel også skulle implementeres \emph{efter}, at man får den semantiske applikation op og køre.

Jeg bør også på et tidspunkt vende tilbage her og overveje nærmere, hvad jeg skal begrænse en prototype til, for lige nu har jeg nævnt væsentligt flere features, end man bør prøve at få med fra start af. Hm, jeg mener dog, det vil være en god idé, hvis man så hurtigt som muligt gør, så at brugerne selv kan lave omtalte HTML-udvidelser. Men ellers er det nu godt bare at starte simpelt, og så bygge på derfra. (17:20)

\ 

(24.01.23, 11:39) Man kan sagtens bruge triplet-konstruktioner, man kan også sagtens tillade +2-ære relationer, hvis man vil, det betyder ikke så meget, for man kan altid omstrukturere, hvis man finder ud af, at der er en bedre standard. Så længe brugerne har frihed til at skabe de konstruktioner, de vil, og at grammatikken i disse konstruktioner er veldefineret, så går det fint. To gode muligheder er derfor, 1, kun at tillade 3-term-konstruktioner (tripletter), eller at gøre det helt frit ligesom i en logisk database.

Nu kommer det mere vigtige, dog: I første omgang handler det hele om at konstruere `udsagn' (som brugerne så efterfølgende kan rate (bedømme)). Men disse udsagn skal så \emph{ikke} tolkes som i standard formel logik, hvor har en binær (boolsk) værdi, så at sige. I stedet skal de ses som termer, der beholder informationen om hele deres indre konstruktion, når de indgår i en kontekst som sammensat formular. Hermed for man nemlig særligt mulighed/lov til at sige ting som: ``Jeg synes udsagnet er\_sjov(film) er sand til en grad af 9/10 rating score.'' Man åbner altså herved op for en meget mere intuitiv måde at kontruere sætninger på, en hvis man skulle beskrive den samme sætninger ud fra mere formel logik, hvor er\_sjov(film) altså bare ville være en binær værdi over alt, hvor den indgår, og hvor denne sætning så ikke ville give nogen mening. Man kan så også konstruere mange volapyksætninger med denne semantisk, og kan altså lave ugyldige og eller paradoksale sætninger, men det er kun et sundt tegn, ift.\ hvad sproget skal bruges til. 

De helt centrale udsang, som nemlig er de eneste udsagn, der repræsenterer direkte \emph{sandheder} i systemet, det er så rating-udsagnene. Disse består af et bruger(-ID)-subjekt, et udsang-term (så som `er\_sjov(film)') og så en rating score. Tja, eller dvs., der mangler én mere information her, og det er informationen om, hvad konteksten er for ratingscorens talværdi. Her kan man så eksempelvis, hvis man tillader +2-ære relationer, som jeg så forresten i virkeligheden er funktioner, fordi alle udsagn er termer (og disse funktioner vil så i øvrigt også som regel være bijektive, i henhold til hvad jeg lige nævnte om, at information ikke bør gå tabt i udsagnene (indmaden forsvinder ikke, med andre ord; hvert udsagn ``kender'' sit eget udsende på papiret)).\,. hvis man tillader 2-ære relationer, så kan man så tilføje en funktion, der sender et udsagn så som `er\_sjov(film)' til et nyt udsagn, der siger ``er\_sjov(film) ud fra ratingscoren $x$,'' hvor $x$ så også er input til omtalte funktion. Nå ja, så lige med dette eksempel er der så ikke behov for +2-ære relationer, eller funktioner rettere, men hvis man skal kunne sådanne ting, så bør man dog kunne have funktioner af alle mulige typer (og ordner). *(Hm, så never mind, at tripletter er fine for systemet. Jeg synes faktisk, at databasen bare mere bør være som en logisk database.)

*Hov, jeg skal forresten lige nævne, at de eneste restriktioner i databasen, udover på hvor meget data og hvor mange termer hver bruger må uploade hver dag/uge/måned, hvilket i øvrigt vil være en god idé at have, nok ellers bare skal være, at det kun er brugeren selv, der må uploade rating-udsagn, hvor brugerens bruger-ID indgår. Så hvis en bruger-udsagn-rating-instans forekommer i databasen, så er det fordi pågældende bruger har givet den rating. Hver bruger skal også have mulighed for at slette sine egne ratings igen fra databasen (hvorfor det faktisk ikke dur med et decentralt system, synes jeg). I den forbindelse kan jeg så også nævne, at man godt kan få det sådan på sigt, at ressourcer faktisk automatisk sender rating-information til databasen på brugerens vegne (hvis brugeren har valgt de ``HTML-udvidelser,'' der gør dette), hvilket f.eks.\ så kan bruges til at sende, om brugeren har set en vis ressource eller ej (hvilket kan bruges til at fjerne gengangere i et feed, f.eks.), men så kan brugeren altid bare selv fjerne sådant data igen efter eget behov. Nå ja, og herved er det jo så også vigtigt lige at nævne, at brugerne sagtens skal kunne uploade data til deres egen private del af databasen, sådan at f.eks.\ ikke alle kan se den data om, hvad brugereb har set og ikke set, eller kan se alt hvad brugeren har ratet for den sags skyld. Brugerne kan sagtens rate rent anonymt, og så bare kun bruge den data til at forbedre egen oplevelse, hvis de vil. Men de kan så selvfølgelig også vælge at offentliggøre noget af denne data (dog med mulighed for at slette det igen fra den offentlige del af databasen), hvis de gerne vil bidrage til, hvad andre brugere ser af brugerratings (hvad de fleste brugere gerne vil; det er typisk en vigtig del af, hvorfor vi normalt afgiver ratings rundtomkring på internettet). (12:42)

Men kommer brugerne ikke bare til at bruge den samme type rating hele tiden? Nej, jeg har nemlig tænkt på, at det vil være rigtigt gavnligt, hvis brugerne selv kan vælge, hver gang de rater, om de bare vil rate ud fra en treværdi-score, nemlig negativ, neutral, positiv, eller om de vil bruge flere muligheder, f.eks. fem stjerner eller ti stjerner, eller hvad det kunne være. Og her snakker vi så ikke den rating, jeg har beskrevet, hvor brugerne rater ud fra en liste med en masse andre relevante ressourcer i. Her snakker jeg, hvis brugerne bare skal rate ressourcen alene i dens egen kontekst, enten på ressourcens egen side, eller måske når den vises i en liste. 
\ldots(12:42) Her er det jo så vigtigt, at brugerne så kan sætte dette i system, så de alle kan kende forskel på, hvad den pågældende ratingscore repræsenterer. 

Jeg har skrevet ovenfor et sted, at man kun skal have termerne ordnet ud fra det (filter-)prædikat, man rater med hensyn til, når man rater ressourcer ud fra en liste, og at alle andre filter-prædikater så kun skal være et spørgsmål om at sortere ressourcer fra i listen. Men dette behøver ikke nødvendigvis at være sandt. Man kunne således godt tænke sig, at.\,. Tja, eller rettere, det skal nok være det samme prædikat, så som eksempelvis `er\_sjov()', men det behøver ikke nødvendigvis kun at være én type ratingscore, man så bruger til ordningen. Men kunne således godt forestille sig en ordning, hvor både folks negativ-neutral-positiv-ratings er med, hvor femstjernede og tistjernede (etc.) ratings tæller med, og hvor selvfølgelig folks rating-ud-fra-en-liste-ratings også tæller med. Så kan de forskellige typer scorer indgå på forskellige måder ud fra den endelige sortering efter brugerens eget behov, men når brugeren så afgiver sine egne svar, jamen så er det så bare rating-ud-fra-en-liste-scoretypen, der bliver valgt for den rating, der uploades til databasen herved. .\,.\,Hvordan man så blander de forskellige ratingtyper sammen til en enkelt sortering på en fornuftig måde, det er så en noget mere kompliceret sag, men det er også lige meget her, for det er nemt at overbevise sig selv om, at det må kunne lade sig gøre på en fornuftig måde (især hvis man finder en god måde at implementere ``usikkerheder (statistiske) / spredninger'' på i forbindelse med diverse ratings). 

.\,.\,Lad mig lige tænke over, hvad jeg ellers gerne vil sige noget om.\,. (13:07) .\,.\,Hm, jeg kunne sige, at hvis man så bruger, hvad der svarer til en logisk database (i hvert fald i interfacet med brugerne), så vil man så skulle lave en query-API, som brugerne kan bruge i ``HTML-udvidelserne,'' der svarer til logiske query-sprog, men det giver jo næsten sig selv.\,. .\,.\,Hm, det var faktisk muligvis alle de tekniske ting, jeg ville nævne for denne omgang. Så har jeg også nogle mere overordnede ting, som jeg tror, jeg vil skrive på engelsk under en ny sektion. Så kan jeg jo derfor også bare vende tilbage hertil, hvis jeg har nogle tilføjelser til nogen af disse tekniske ting. (13:18)

*Jo, der er faktisk lige den tilføjelse, at min SRC-idé jo også kunne virke godt til denne idé, nemlig især hvis man gerne vil have et fastansat hold af programmører til siden --- og i det hele taget når det kommer til, at man jo gerne, efter min mening, skal have nogle centraliserede databaser, som så kan underskrive kontrakter om ikke at offentliggøre eller videresælge privat data fra brugerne, samt at brugerne skal kunne bede om at få deres data slettet.

*(17:05) Dette er ikke en teknisk tilføjelse, men en bare en kort tilføjelse omkring min ``debatside-applikation.'' Jeg nævner det nok igen i Sektion \ref{Some_hopes_in_terms_of_my_ideas}, men angående min debatsideidé, så kan det godt være, at den ikke rigtigt vil.\,. take off.\,. få god ind i sejlene, før at den videnskabelige verden virkeligt kommer med og deltager i hele projektet med at strukturere, i dette tilfælde viden og videnskabelige diskussioner, i semantiske grafer. Så jeg håber altså på, at den videnskabelige verden vil benytte denne semantiske teknologi mere og mere, og herved vil det jo så selvsagt være relevant at afholde sådanne diskussioner, som jeg tænker dem i forbindelse med, hvad jeg kalder min debatside-idé. Et alternativ ville være, hvis mine tanker omkring e-demokrati fik god vind i sejlene forinden, så tror jeg også, at dette kunne blive en vej til, at få godt gang i sådanne graf-diskussioner, som jeg tænker dem.\,.

*(26.01.23) Vil lige for det første kort nævne, at jeg synes, det giver rigtig god mening, hvis man i bruger-udsagn-rating-entiteterne også har et flag / en reference til, hvordan ratingværdien skal tolkes. For det synes jeg nemlig giver bedst mening rent fortolkningsmæssigt: Så kan man nemlig se udsagnet for sig som sin egen ting, og se ratingen samt dennes fortolkning som sin egen ting også. (12:52)

*(12:52) Nå, den næste, mere vigtige ting, jeg vil tilføje, er, at jeg nu er kommet på, at brugerne måske også skal kunne tilføje URL-RegEx'er til at scrape indhold fra andre sider. Og når man så har disse scrape-formler, så kan brugere så tilføje specifikke inputs til disse RegEx'er, der giver en gyldig URL til en eksisterende Web-ressource. Og så kan databasen i princippet bare gemme selve inputtet, og når brugerne så iagttager pågældende ressource, så kan hjemmesiden bare hente de relevante URI'er fra sættet af de fuldendte URL-RegEx'er og indsætte dem på hjemmesiden. Så dette kunne altså være en hurtig måde at få en hel masse indhold på siden.

*(12:59) Samtidigt åbner dette så også op for, at man ret nemt kan lave et ``overlay,'' som jeg før har kaldt det i mine noter, nemlig en slags annotationsudvidelse til browseren, således at en bruger kan folde en menu ud og se relevant data, særligt ``rating-tags'', som jeg har kaldt det, for en ressource de browser på en anden hjemmeside. Så når brugerne browser andre hjemmesider, kan de altså få adgang til den ``rating folksonomy,'' der tilhører semantik-hjemmesiden. De kan også få adgang til anden data, så som relevante links, inklusiv den/de oprindelige kilde(r) til ressourcen, og også diverse advarsler, f.eks.\ om NSFW/NSFL, og ikke mindst også om `misinformation.' Disse muligheder kunne muligvis være med til at gøre semantik-applikationen/hjemmesiden populær lynhurtig i sammenligning med, hvis brugerne kun kunne få alle disse muligheder, når de browser semantik-hjemmesiden selv. Man kunne i øvrigt også sælge hele denne idé denne vej rundt, altså hvor man starter med at sælge idéen om et tværgående system, hvor brugere kan få adgang til en ``rating folksonomy,'' der fungerer på tværs af alle mulige hjemmesider, og hvor brugerne også kan få andre links og advarsler herved, og så derfra pointere, at denne applikation så også bør have sin egen hjemmeside, hvor brugere kan se alle tingene samlet, endda på en semantisk struktureret måde, der giver et meget effektivt overblik over alting. 
*(RegEx'erne skal jo også gerne hente al mulig gavnlig metadata såsom titler osv., hvis de kan, og dermed bliver det også relativt nemt at finde en ny passede URL (og måske med nye RegEx'er) til ressourcen, hvis nu hjemmesiden, hvor den er hentet fra i første omgang, skulle ændre sig.)

*(13:11) Nå, og den tredje/fjerde ting, jeg også lige ville nævne her, er omkring trust-fordeling. Når det kommer til brugere, der tilføjer nye ting i applikationen, jamen så vil det være rimeligt nemt at sortere skidt fra kanel, for så kan brugere bare stige i tillid, jo mere de tilføjer, der bliver godkendt af andre brugere, men ellers vil det altid også bare være sådan, at sensitive og/eller utålmodige brugere bare kan have et ret skrapt filter for nye tilføjelser, der altså kræver mange up-votes, før de selv får tilføjelsen at se, og mere engagerede brugere kan så have mindre skrappe filtre og dermed blive mere aktivt med til at godkende og afvise nye tilføjelser. Og angående tillid ift.\ bruger-ratings, så kan man sikkert komme rigtig langt i starten ved bare at antage, at alle konti repræsenterer en unik bruger, og så snart siden vokser bare lit, så kan man begynde at implementere et friend-of-a-friend-system, således at man kan begynde at skille bots fra. Så jeg tror dermed faktisk ikke, at dette bliver så svært, og jeg tror således heller ikke, at mine simple, token-baserede ``brugergrupper'' beskrevet ovenfor bliver særligt nødvendige.\,. .\,.\,Og det er rart at man applikationen ikke er tvunget til at vante på, at brugerne for oprettede sådanne halvavancerede systemer (som kræver noget brugerengagement) til at uddele trust, før at applikationen kan blive god og gavnlig. 



\section{Overall selling points for my Web 2.0--3.0 ideas}

(13:19, 24.01.23) This section is best understood if one has read my previous notes on the subject, including the ones above in the previous section (in Danish). But the notes might make some sense still, even without having read my previous notes.

%(13:22) Jeg tager lige en hurtig pause og tænker lidt over, hvad jeg vil sige i denne sektion... ...(13:52) Okay, lad mig prøve at fortsætte.

One little idea, which can be implemented on any conventional Web 2.0 site as well, is my idea for ``rating folksonomies.'' The idea is basically to attach a rating bar to all tags. Even if the site does nothing further about this technology, it will still be nice for users to be able to see a rating score along all the tags that they observe on the site. On from there it is a very short step to start using this extra data to make searching better on the site, and to make feed algorithms better. Thus, it is a very simple, and I believe very useful, idea that is easy to get going with.

The next idea is to have user-driven search filter / feed algorithms. This idea is more complicated, but I have described how it could work in the notes of the previous section. The big selling points here, are that users will then be able to not just get a single feed algorithm (as well as some very simple search filters) that depends on the user's data, but can always choose from an array of algorithms. This gives the users much more freedom of customization on the site, and in a way such that they can shift between different customizations depending on what they are interested at in the moment. Now, if we think about YouTube in its current state, this is a very good example of a quite terrible user experience with the feed algorithm (in my opinion as well as some other's). I am actually afraid to click on anything that I don't recognize, since I am afraid that that will then trigger a whole bunch of stupid recommendation in the future, where I have to repeatedly click `not interested' in order to get that ``contamination'' out of my feed again. Such ridiculous situations will all be past with a more user-driven system such as the one that I imagine. Here users will instead be able to control their own algorithms quite effectively, and will be able to use a wide array of different sittings depending on what the are interested in at the moment.

User-driven algorithms also means that the users don't even have to feed the machine a lot of their personal data in order to get the feed/search result that they desire. They can instead stand on the back of other users' commitment and simply use their preferences. A
Or they can keep their own data completely private and still use it to find out about, where they lie in the general space of user preferences. They can also at anytime open up completely anonymous accounts and import preferences from other accounts (without having to reveal this data to the public). The users will thus be able to get much more freedom in how the use their data, and will have much more control and ownership over it.

And continuing on the topic of feed/search algorithms, I certainly believe that these will get a lot better for the individual user when there is a large open source community behind them (and when the user has so much ability to use a wide range of settings). This is finally a point where the open source part of the idea starts to get important. Once suc a site takes off, the sheer number of users who want to contribute to better making better search/feed algorithms will make the possibilities far exceed what any private team of web developers can muster for their users. This is just my belief, but yeah, I believe it quite strongly (perhaps with the only exception if AI is going to come in and help provide super good and varied feed algorithms somehow.\,.). .\,.\,But yeah, most likely, a big open source community around such an open source site as what I have in mind will be able to achieve much better things than what we know currently.

Another idea where the open source part is really important, is about having the users be able to change the appearance of the site themselves. Again, we are then talking about a case where the site has already taken off and has gained a very big user network around it. One it has this, this open source community will be able to achieve much more in terms of the usability and nt least the ability for customization than what a limited team of web developers can achieve. And here I should mention that part of my ideas related to this subject is that users are able to choose different settings for different types of resources. Each users can thus customize the appearance of the various interfaces on the site in a modular way. (See my previous notes for more details.)

Moving on, another big selling point about my ideas has to do with having a semantic (I guess) structure of all the resources contained (and referenced) on the site such that all resources can be found in a tree (or graph, rather) structure of categories and subcategories and so on. Hm, well perhaps `semantic' is actually not the right term to use here.\,. %(14:35)
.\,.\,Hm well, yes, I guess it is, cause that is essentially what I achieve with having users being able to also choose more and more filter predicates at the same time as they browse the category tree, such that the end up choosing both a subcategory for the resource they are interested in as well as a bunch of predicates which can specify the resource they are interested in further. %(14:39) ..Går lige en lille tur, før jeg fortsætter. (14:46)

%(16:06)
If keyword searches was never invented, such semantic catalogs would probably have been how we would have ordered resources on the web. Such a resource graph might then have been centralized to begin with, but at one point, an open and user-driven implementation would have become popular. I am glad we keyword searches was invested, but I really think we have been missing out on something big all this time. I really think that such user-driven resource graphs over the contents of the web would have been such a useful thin to have. Whenever a website has content added to it, the author of that content would have wanted it to add a reference to this content in whatever semantic ressource graph would be popular at the time, such that more people would see that content. And since the Web of Trust ideas are quite similar to my ``(user-driven) user groups'' in a lot of ways, I am pretty sure that we would have also quickly implemented ways for users to choose different ways of applying trust when it comes to rating useful contributions to said semantic resource graph. 

Anyway, I think that having such (user-driven) structured graphs over all the content on the web will be such a useful thing to get in the future, and I see (as I have described in the previous section) how I site such as the one I have in mind could be one way to get there. So to add a selling point to the list: Having such a semantic structure of content like the one I have described in the previous section could become a massive thing in the future. 

And the last point I want to mention, which is related to the last point, is that I think it will also be very useful to have content and data related to any specific resource ordered with a similar semantic structure. Having ordered comment sections would thus potentially be quite a nice thing to have, and on top of this, there is also related data/content such as related links, annotations, source material, etc., which could benefit from a similar user-driven, semantic structure. (See my previous notes for more details.)

So that concludes the list of selling points that I have in mind. The first ones are something that a regular Web 2.0 site might also be able to implement to some degree. This is kinda unfortunate for someone like me who thinks that the open source way is the ultimate way to go, for if these selling points could also only be realized on a much more user-driven site, it would sell the idea of such user-driven sites all the more. However, my hope is that other people will see the big potential in starting up an open source site which sets out to realize more and more of all these mentioned ideas, and that we can thus get a big community going around starting up such a site. This community will then consist of mainly open source programmers initially, and there will be a time where the site has yet to attract users from the general public, but once some of the first points mentioned in this list of ideas starts to become realized, users will slowly migrate from other Web 2.0 sites and start using this open source version more and more. The following network effect will then mean (as I foresee it) that some of the last points on this list of ideas will start to become realized, and from there, the sky is the limit. %(16:32) 

(13:22, 26.01.23) Let me also quickly mention the point that I think my system where users rate things by moving them around in a list will be good at encouraging users to give a lot of (valuable) rating data to the system. 

(13:38) In accordance with what I have just added in the previous section, there is now also the selling point, that the application will be able to be used on all kinds of other websites as well, namely such that users can see semantic data about resources they are viewing while browsing other sites. 

(15:10) And just to make clear, there is also another great point, which might not be so easy to ``sell'' since it is hard to argue that things will go according to how I imagine them, but which is really the big underlying reason why I'm so interested in all this. The point is that I believe that this technology can get us to a point where all of science can also be structured in a great semantically linked graph such that is becomes easy to look at all point and counterpoints to a given question, and to look at all existing solutions to a problem (and see arguments for their benefits and drawbacks). The same can also be said for open source programming: I believe we can get to a point where all programming solutions (modular) can be ordered in a great semantically linked graph. I believe that my ``Web 2.1'' ideas here, as we can call them, potentially might be able to bring about such a future, and I really think that this will mean so much for our scientific (and societal) advancement.\,.\,! %(Let me by the way mention here in the comments that I have thought about this today and reconsidered if I still really believe that my Web 2.1 ideas can lead to this, and luckily I have sort of arrived at the point where I think I will double down on that belief. For the way I see it, having a semantic graph over web content can very well become very popular, and this might very well further lead to the scientific --- and open source programming --- community/ties also making use of this technology to structure all scientific knowledge and discussion (each individual scientist (or programmer or amateur) taking part partly of selfish reasons to make their work reach a larger audience). And once such a well-structured graph becomes a reality, I believe this will... Hm, let me actually write this in the rendered text instead.. )
Let me by the way mention that I have thought about this today and reconsidered if I still really believe that my Web 2.1 ideas can lead to this, and luckily I have sort of arrived at the point where I think I will double down on that belief. For the way I see it, having a semantic graph over web content can very well become very popular, and this might very well further lead to the scientific --- and open source programming --- community/ties also making use of this technology to structure all scientific knowledge and discussion (each individual scientist (or programmer or amateur) taking part partly of selfish reasons to make their work reach a larger audience). And once such a well-structured graph becomes a reality, I believe this will greatly increase people's --- scientists/programmers as well as all other people --- ability to look up specific knowledge and to engage in discussions and innovation/solution-finding processes. I thus see that this technology can maybe sort of create a giant online collective intelligence --- not an artificial intelligence, but metaphorically speaking still a big collective brain. These are large words, but I really do think that such technology will give us intellectual powers as a civilization that is many times greater than what we have now. Anyway, I hope so. Hm, I guess that this paragraph belongs more in section \ref{Some_hopes_in_terms_of_my_ideas} below than here, but let me keep it here and simply copy (not cut) and paste it below there as well.\,.




\section{Flere tanker om min semantik-applikation}

(30.01.23, 9:51) Jeg var lidt begyndt at second guess'e, hvor stor en gennemslagskraft min hjemmeside/applikation vil kunne have, men nu føler jeg faktisk virkeligt, at jeg har fundet den røde tråd igen, som gør, at jeg igen virkeligt tror, at det vil kunne bliv kæmpe stort, og på ikke så lang tid endda. 

En stor pointe er, at nu har jeg godt nok snakket med om et prædikat såsom `er\_sjov,' og sådanne prædikater er også vigtige, nemlig prædikater der bruges mere til bedømmelse af en ressource frem for en kategorisering af den. Et relateret prædikat til er\_sjov, der i stedet bruges til bedømmelse, kunne være er\_komedie, når vi snakker film, og ellers kunne det være noget såsom har\_humor\_som\_et\_vigtigt\_fokus. Der vil så generelt være meget mere tværgående enighed omkring sidstnævnte typer af prædikater, hvor bedømmelserne af førstnævnte vil afhænge meget mere af personlige holdninger --- og dermed altså også hvilken `brugergruppe,' man ``spørger'' i forbindelse med diverse filterindstillinger. 

Nå, den store pointe er så, at kategoriseringsprædikater vil være mindst ligeså vigtige for brugerne, og jeg tror på, at disse i høj grad også vil være villige til at bedømme kategorier, som vi kan kalde det, frem for bare at bedømme, hvor godt ressourcen lever op til sine kategorier, osv. Og på den måde, så bliver applikationens brugbarhed altså set ikke så todelt, som jeg egentligt lidt har gået og tænkt på det sidste, for det vil i stedet være sådan, at hele den del af applikationen, der handler om at kategorisere ressourcer, i høj grad også vil hænge sammen med tag-rating-delen. Og dermed tror jeg altså lynhurtigt, man vil få brugerne godt i gang med at tilføje og bedømme kategorier. 

For når man som bruger af gængse hjemmesider afgiver bedømmelser, så er det ofte i høj grad for at støtte skaberen og ikke mindst hjælpe til at andre med samme interesser kan finde frem til det samme. Og dette vil kategori-rating tags jo lige netop kunne hjælpe gevaldigt med. Jeg er altså ret overbevist om, at brugerne i høj grad vil benytte sig af disse.

Og oveni, hvis vi går tilbage og ser på, hvad der generelt vil få applikationen til at blive en stor succes efter min mening, så vil applikationen jo hurtigt kunne bruges vildt bredt. Vi snakker jo således slet ikke bare film og videoer, men også tekster (bl.a.\ fra Wikipedia, men også fra alle mulige andre steder), varer af alverdens afskygninger, bøger, spil og alverdens andre ting omkring fritidsinteresser. Og ja, jeg tror altså nu, at der ikke vil gå særligt lang tid, før at brugerne får udbygget en omfattende kategoriserings-semantik-graf over alle sådanne ting. .\,.\,Nå ja, og i øvrigt forestiller jeg mig også, at politiske holdninger og andre meninger også kunne blive en vigtig type ressource. Altså tekster, der opsummerer en eller anden form for mening om noget, og som folk så kan bedømme efter enighed. Dette kan blive en rigtig god måde for folk at udtrykke sig på (politisk og i andre sammenhænge), f.eks.\ hvis nu de hører i fjernsynet eller i radioen om, at ``der har været en stor bevægelse/underskriftindsamling/shitstorm / et stort backlash/.\,.\,you name it.\,. hvor de selv føler, at de ikke selv er repræsenteret i disse reaktioner. Så kan det være rart at kunne gå ind at give sin mening til kende ved at stemme på de relaterede `meninger' på hjemmesiden/applikationen, og også så at kunne se et mere klart billede af, hvor mange mener det ene og hvor mange mener det andet. Og ja, det kan det selvfølgelig også i mange, mange andre sammenhænge (og også i tilfælde, hvor `meningen' ikke er vildt aktuel i nyhederne, men det er den måske for brugeren selv). Men ja, og hvis vi går et skridt tilbage til at kategorisere (og bedømme!) varer *(og servicer forresten) af alverdens typer, så vil det også blive en kæmpe stor ting. Hvis man f.eks.\ ser på Trust Pilot, så vil den hjemmeside/applikations muligheder være vand ift., hvad man kan på min semantik-hjemmeside. For det første vil man kunne kategorisere alle varer i en semantisk grafstruktur, så det er let at finde frem til, hvad man leder efter, og let at sammenligne, og for det andet vil man så også have mange flere parametre, man kan bedømme varerne (og servicerne) ift.\ (og se bedømmelserne for). 

Og ja, angående vidensressourcer, så tror jeg nu også, at applikation lynhurtigt vil blive super gavnlig, og at brugere således vil kunne bruge den til meget nemmere at finde frem til tekster omkring ligepræcis det, de er interesserede i. 

En lille teknisk tilføjelse omkring videns-ressourcerne, hvilket jo bare er tekster, eventuelt hypertekster, plus kilde-URL'en, jamen så ville jeg vælge bare at gemme (hyper)teksterne direkte i databasen fra start af (i modsætning til tungere ting såsom videoer og billeder). Hvis så kildesiden ændrer struktur en anelse, eller hvis selve teksten bliver skrevet en anelse om, så må man alligevel kunne finde tilbage til det eksakte sted, hvor teksten stammer fra, nemlig ved bare at lave en automatisk søgning og finde det bedste match til teksten på kildesiden. *(Jeg glemte lige at nævne her, at man dog nok ikke bør lade brugerne se disse tekster direkte, da de jo let kan være copyright'ede. .\,.\,Hm, men vent, for vil det så egentligt være særligt smart sådan? Måske på sigt, men det vil jo kræve ret meget programmering, måske man kan finde på noget smartere.\,.\,? .\,.\,Ah, mon ikke hvis man bare gemmer de første par sætninger i teksten i stedet (foruden overskriften, hvis der er en), så kan man vel nok ikke komme i klemme. .\,.\,Nej, det skulle undre mig meget, hvis man kan det.)

Men ja, så det korte af det lange er altså, at jeg virkeligt tror, at hjemmesiden/applikati-onen ift.\ hver enkelt type ressource vil gå fra 0 til `nu er siden brugbar' til 100 på virkeligt kort tid, for når først den semantiske struktur er brugbar for en del brugere, så tror jeg udviklingen vil accelerere helt vildt derfra, nemlig fordi flere og flere brugere vil komme til, og disse vil føje flere og flere ressourcer og bedømmelser (inklusiv kategori-bedømmelser) til. (10:43)


(10:54) Jeg har også tænkt på noget andet, som jeg passende lige kan nævne her, inden jeg går videre, og det er, at følgende donationsidé nok virkeligt også vil være gavnlig, nemlig at brugerne i fællesskab (og hver for sig og, ikke mindst, i grupper) kan udarbejde donationsfordelingsopskrifter, som så altså er opskrifter/planer, der bestemmer, hvordan penge doneret til opskriften/planen skal fordeles mellem skabere/bidragsydere (og altså ikke bare skabere, der har uploadet ressourcer specifikt til webapplikationen; det kan også være skabere, som ikke selv har tilføjet deres indhold specifikt til webapplikationen (men til en anden hjemmeside/applikation), men som dog har registreret sig selv og tilføjet en konto man kan donere til). Hver doner kan så selv vælge, hvilken plan/opskrift, de vil bruge. I princippet kan de så vælge en opskrift, der bare giver pengene tilbage til den selv (ved også at registrere sig selv som en skaber), men hele pointen er så, at andre brugere så også kan se, at du ikke er donor til en af de mest populære planer/opskrifter, men i stedet er donor til en måske meget obskur opskrift. Dermed vil andre brugere altså ikke have nær så stor tendens til at bruge dig særligt meget i diverse filteralgoritmer, mere end hvordan de bruger ikke-donerende brugere. (Og det er nemlig en rigtig gavnlig ting, at brugere kan vægte filteralgoritmer ud fra, hvor meget brugere har givet til visse populære og fornuftige donationsopskrifter. 

En lille anden tanke omkring bruger--skaber-økonomien, som jeg lige kom på nu her (de fleste andre idéer jeg nedskriver nu her stammer ellers fra weekenden, hvor jeg var på Fyn), er at man i stedet for at tænke på at starte en SRC over webapplikationsvirksomheden kunne starte den over en IP-fællespulje i stedet. Her har jeg jo før tænkt, at en sådan IP-organisation kunne indgå som et modul i den samlede SRC omkring en sådan hjemmeside/webapplikation, men nu tænker jeg altså: Hvorfor ikke bare nøjes med at foreslå, at skaberne kan gå sammen (efterfølgende) og oprette en SRC til at forene sig omkring deres samlede IP-rettigheder? Så det tror jeg faktisk er min plan nu: Jeg vil oprette en virksomhed omkring denne semantik-webapplikation, som altså skal stå for de grundlæggende ting, ikke mindst at passe databasen (og som tiltrækker penge ved at vise reklamer (muligvis hvor brugerne selv kan slå dem fra (altså uden at bruge en add blocker)) og så ikke mindst via donationer, og som i øvrigt ikke prøver på at ekspandere særligt meget), og så er tanken, at diverse skabere (indholdsskabere og ``ramme-skabere,'' som jeg har kaldt det) selv kan oprette en SRC omkring en sammensat IP-pulje, hvis de vil. 

Ok, og har jeg andet, jeg vil nævne, inden jeg går videre til mine nye idéer omkring webapplikationens interface og alt det.\,.\,? (11:22)


(13:25) Okay, jeg tillod lige mig selv at tænke noget mere over det hele. Lad mig starte med det vigtigste først. Nu tænker jeg ikke længere at fokusere på den der fold-ud-menu, jeg har snakket om ovenfor, ikke i starten i hvert fald. %Lad mig prøve at opsummere, hvad jeg tænker, man bør prøve at konstruere i starten i stedet for.
I stedet forestiller jeg mig, at det bare er helt standard, at hver ressource i en liste får en lille liste af muligheder, ja, som essentielt set så vil være list-prædikater, der hver er dannet af en relation (2 inputs), hvor pågældende ressource automatisk er sat ind som det ene input. Denne lille liste af muligheder må så gerne kunne afhænge af ressource-typen, men er ellers rimeligt konstant. Det vil sige, at brugeren derfor i princippet vælger en liste for hver ressourcetype (f.eks.\ `kategori,' ress.\,.).\,. Nå nej, lad mig kalde det et term i stedet for en ressource, og så kan jeg bruge ressource som en over-termtype, der indeholder (ressource-)termer såsom `videoressourcer,' tekstressourcer,' `meninger' (som jeg har skrevet om ovenfor), `varer' osv. Okay, og for at fortsætte, så vælger brugeren altså derfor i princippet en liste for hver termtype, nemlig i form af en lille liste af relationer. Disse relationer kan så f.eks.\ være `er\_overkategori\_til\_x' (hvor x så er den automatisk indsatte term), `er\_underkategori\_til\_x,' `hører\_under\_kategorien\_x,' `er\_et\_relateret\_link\_til\_x,' `er\_en\_relateret\_ressource\_til\_x,' osv.\ (hvor disse nævnte relationer så ikke alle vil være relevante for alle termtyper (de to første vil nemlig nok bare være relevante kategorier, hvorimod de tre sidste vil være relevante for diverse ressource-termtyper)). 

Selvfølgelig vil de fleste brugere i starten bare bruge de lister her, som webudviklerne (som jeg så forestiller mig at være en del af) vælger (og justerer løbende), men med tiden vil brugerne selv tage over og gøre det for hinanden, som de vil have det (men her snakker vi altså på langt længere sigt). 

.\,.\,Nå ja, men brugerne kan dog fra starten altså vælge imellem nogle forskellige muligheder for hver termtype, og selv oprette nye liste for hver af disse, hvor de selv tilføjer eller fjerne relationer herfra (ift.\ til standardmulighederne). *(Og de skal selvfølgelig også gerne selv kunne vælge brugervægtningen ift.\ ratingen af relationerne i listen.)

Når brugerne så iagttager en given liste over termer, der er blevet bedømt positivt i forhold til et givent prædikat, så kan de så ved at klikke på en term folde denne lidt ud for at få nogle valgmuligheder med den, og her skal den nævnte lille liste altså så også findes. Her kan brugerne så skifte imellem de forskellige valgmuligheder i listen, hvilket så bestemmer, hvilken liste af termer, som vises hvis brugeren vælger at folde en ny liste ud for det givne term. Jeg forestiller mig så, at brugeren kan folde en ny liste ud på to forskellige måder, via to forskellige tilhørende knapper: èn knap med en pil nedad og én knap med en pil til højre. Hvis brugeren trykker på knappen med pilen pegende nedad, vil en liste foldes ud under termet selv (muligvis med et lille indryk), imellem dette og så den næste term i listen. I øvrigt foldes listen kun lidt ud med de øverste fem-ti valgmuligheder til at starte med, og ved endnu et klik på en nedadpil i bunden kan brugeren så få endnu flere valgmuligheder i listen. Alternativt kan brugeren klikke på pilen pegende mod højre, hvorved samme liste så bliver udfoldet i større format i en kolonne ved siden af den forrige kolonne, hvor det givne term fandtes i. Brugeren kan så også skifte frit imellem valgmulighederne over relationer i den lille liste, jeg har snakket om her, hvorved indholdet i listen, hvad end den er foldet ud under termen eller i en kolonne til højre for den forrige, skifter til den nye relation.

Når brugeren trykker på et hvilket som helst givent term, skal der også enten foldes en rating bar (eller to.\,.) ud til at starte med, eller også skal der være en knap til at folde ratingen/erne ud. For alle termer i en liste skal der så i første omgang være en rating bar, som lige præcis handler om prædikatet om, hvor godt pågældende term passer til den liste, den vises i. Eller med andre ord, for enhver liste afhænger jo af et specifikt prædikat, så skal man altså kunne rate termen i forhold til lige netop dette prædikat. .\,.\,Hm, for prædikat-termer skal man så kunne gøre noget mere, men lad mig lige tænke lidt mere, inden jeg fortsætter omkring dette.\,. (14:09)

(14:32) Okay, når det kommer til prædikater, så skal der også være endnu en rating bar, nemlig hvor brugeren kan rate andre termer ud fra pågældende prædikatet (altså i stedet for at rate pågældende prædikat-term ud fra det prædikat, der danner den liste, som pågældende prædikat-term vises i). Og her skal brugeren så kunne skifte subjekttermen til denne rating bar. Titlen (og måske et tilhørende billede/ikon på længere sigt) kan så vises over eller ved siden af denne rating bar, og ved at klikke på en knap nær ved denne titel, skal brugen så kunne cykle imellem alle de aktuelle\,.\,. hm, de aktuelle termer, men det vil jo i høj grad være ressource-termer, vi taler om her, ikke.\,.\,? Jo.\,. .\,.\,Ja, ok, så i første omgang (som noget der vises allerførst i listen over termer, som brugeren kan rate på denne måde --- hvis altså ikke det bare \emph{kun} er ressource-termer, som brugeren skal kunne rate på denne måde, det kan faktisk godt være.\,.) skal alle de aktuelle ressource-termer altså stå i listen over, hvad brugeren kan rate her. Og disse ressource-termer er så altså nærmere bestemt alle de ressourcer, som brugeren har klikket på for nylig. 

For hver eneste rating bar, der vises, hvad så vi snakker den ene eller den anden af de to nævne ratingbarer (hvor den anden kun giver mening, når pågældende term selv er et prædikat), så skal der kunne udfoldes en lille beskrivelse af, hvordan det relevante prædikat (som rates ift.) er defineret mere eksakt (end bare ved at læse dens titel), og når brugeren peger forskellige steder på ratingbaren, så skal der også gerne vises en lille tekst til det specifikke interval, som brugeren holder over, hvor der given en forklaring på, hvordan en rating i dette interval generelt bør fortolkes (ifølge forfatteren). Det kan godt være, at disse tekster vises, når brugeren indstiller knappen på ratingbaren, måske særligt hvis vi snakker et mobile device, men der skal så selvfølgelig altid være en bekræftelse af hver afgivne rating (og hver ændring af en tidligere afgiven rating), hvor brugeren skal trykke bekræft eller annuller. (14:47)

Okay, jeg har det som om, jeg mangler at nævne noget, men lad mig bare lige gå lidt videre for nu. Hvis vi tænker på de filter-indstillinger, jeg har snakket om ovenfor, så kan dette fungere ret meget ligesom, jeg har beskrevet før, måske endda med en fold-ud-menu fra venstre. Jeg forestiller mig dog, at brugeren skal gå til hjemmesiden for applikationen selv for at lave nye filterindstillinger, og at brugeren defor bare eventuelt har en række yndlingsfiltre, som denne kan vælge fra, hvis brugeren tilgår applikationen via et overlay på en anden hjemmeside.\,.

.\,.\,For jeg har jo allerede nævnt ovenfor, at jeg nu forestiller mig, at applikationen ikke bare skal fungere på sin egen hjemmeside, men at brugerne også kan tilgå den, når de browser ressourcer på andre hjemmesider. Her forestiller jeg mig så, at dette overlay (eller hvad man kalder det) skal kunne rulles ind fra højre, hvis brugeren trykker på en knap, og i øvrigt at denne knap skifter udseende, hvis den ressource, som brugeren betragter på den anden hjemmeside allerede er tilføjet til databasen (altså den semantiske), og hvis der så findes relevant data (så som ratings og relevante links m.m.) til ressourcen i databasen. Men jeg forestiller mig dog lidt, at overlay-applikationen kan være en tand mere simpel, end hvad man kan tilgå på webapplikationens egen hjemmeside. Brugeren skal dog selvfølgelig stadig være logget ind i overlay-applikationen og hermed have adgang til de relation-liste-indstillinger m.m., som jeg har nævnt nu her i dag, og jeg synes også nok gerne, at brugeren må kunne folde underlister ud til højre for forrige kolonne i en ny kolonne ved at trykke på pilen til højre, som beskrevet her ovenfor, men ud over disse ting, så kan det dog godt være, at overlayet bare skal være en tand mere begrænset. Men til gengæld bliver brugeren så bare simpelthen dirigeret om til applikationens egen hjemmeside, hvis denne trykker på en valgmulighed, som ikke er implementeret i overlayet, og så skal brugerens nuværende position i hele semantik-grafen, samt de ressourcer brugeren har valgt, bare overføres, så brugeren starter med helt det samme sted, som denne kom fra i overlayet (nu bare med nogle flere valgmuligheder). Og i øvrigt skal denne omdirigering altså ske via åbning af et nyt vindue, så brugeren ikke forlader den side, han/hun var på. 

Så lad os forestille os, at brugeren betragter en ressource på en vis hjemmeside, og nu ser ude i siden, at der findes data til denne ressource i semantik-databasen. Brugeren kan så folde overlayet som en menu fra højre. Her skal brugeren så.\,. Nå ja, det har jeg ikke nævnt! Jeg vil gerne have.\,. Hm.\,. .\,.\,Jo okay, jeg vil også gerne have en standardvisning for en given ressource, hvor alle relationsmulighederne vises som overskrifter i en sammensat liste, hvor der så kun lige vises de allermest populære termer i hver liste, men hvor man så også får mulighed for at folde disse lister mere ud, både ved at trykke pil nedad eller ved at trykke pil til højre (som beskrevet ovenfor). Hm, vi kan så se denne mulighed som en standardmulighed for hver relationsliste (vi snakker altså denne ``lille liste af muligheder,'' som jeg startede med at forklare om i dag), hvilket altså for lige at gentage det giver en liste, som er sammensat (i rækkefølge) over alle de egentlige relationer, som er i denne liste. Så brugeren kan altså se denne standardliste, hvor alle relation-mulighederne kommer efter hinanden, eller brugeren kan også trykke på en specifik mulighed (ikke i den nye søjle med omtalte standardliste men i den forrige søjle med objekttermen selv), således at hele den nye liste så bare \emph{kun} kommer til at indeholde en specifik mulighed i form af en af de pågældende relationer i relation-listen. (Håber dette giver mening, hvis man læser det et par gange.)

Ok. Brugeren kan herved så trykke overlayet frem fra højre og med det samme se en lille oversigt over de mest relevante ratings og links m.m.\ til pågældende ressource. Og ved bare ét klik mere, nemlig på en nedad-pil, kan brugeren så folde en af disse dellister længere ud og for så at se nogle flere muligheder (i.e.\ en række af de næstmest relevante prædikater/links m.m.). (15:20) .\,.\,Og herfra kan brugeren så endda navigere endnu videre i grafen, navnligt måske hvis denne hurtigt lige vil finde en passende kategori og/eller et passende prædikat som ikke indgår i listen (.\,.\,eller f.eks.\ hvis brugeren lige hurtigt vil tilføje et relevant link). Og hvis brugeren så gerne vil bruge webapplikationen endnu mere end dette, såsom f.eks.\ at betragte ressourcen og/eller andre ressourcer i en liste sorteret ud fra visse filterindstillinger (og alt det jazz), så kan brugeren altid bare klikke på en knap, så applikationens hjemmeside åbner i en ny fane, og hvor brugeren så starter i helt samme tilstand (stort set), som denne var i i overlayet (nemlig de samme sted i grafen og med de samme midlertidigt valgte termer). (15:26)


(02.02.23, 9:32) Jeg har nogle få ændringer. På en måde tror jeg nu, at interfacet skal være lidt en blanding af, hvad jeg skrev om, dengang jeg introducerede og forklarede om fold-ud-menuen (fra venstre) ovenfor, nemlig hvor man har arbejdsbord, og hvor man så føjer flere og flere termer til et arbejdsbord, når man navigerer rundt i grafen, og ja, også så en blanding af det jeg lige har forklaret om, brugeren vælger en lille liste af muligheder for hver term type over, hvad man kan folde ud fra (ved at klikke nedad-pil eller højre-pil) en given term. 

Lige nogle lidt selvstændige tilføjelser, der er rare at få sagt med det samme, inden jeg fortsætter med det mere generelle: Nu forestiller jeg mig, at navigation i den semantiske graf primært kommer til (i det interface, jeg vil sigte mod at bygge) at foregå ved, at man folder flere og flere lister ud, ikke kun af over- og underkategorier, men sådan set af (kategori-)prædikater generelt. Og her skal brugeren så faktisk kunne aktivere flere kategori-prædikater på én gang, nemlig ved at klikke på dem (under navigationen/browsingen) og føje dem til sine aktive (kategori-)(filter-)prædikater. Sådanne prædikater behøver altså slet ikke at være disjunkte, og brugeren kan derfor altså sagtens få brug for at vælge flere på én gang i sin søgning. Jeg forestiller mig, at når brugeren klikker et kategori-prædikat aktivt i sin søgning, så skal den (skifte farve og) highlightes i den pågældende liste, samtidigt med at den også føjes til en speciel mappe i arbejdsbordet. 

Og den anden selvstændige tilføjelse er, at man også skal kunne have filter-prædikater, der har antecedenter foran sig, f.eks.\ til at gøre filtreringen afhængig af termtypen, men antecedenter bør også kunne bestå af eller indeholde andre filter-/kategori-prædikater. Hver bruger kan så endda have en hel lille preamble af faste filter-prædikater (sammensat med diverse antecedenter foran sig), som altid er aktive, når brugeren har gang i en søgning.

Nå, en anden ting er så, at jeg nu tror, at brugerne rigtigt gerne bare vil kunne søge efter nøgleord, når det kommer til bedømmelses-prædikater, som det eksempelvis gerne vil bedømme for en ressource de iagttager (måske på en anden hjemmeside og altså dermed via overlayet (som jeg stadig bare kalder det indtil videre)). Her kunne man sikkert komme langt med gængse søgemaskine-funktionaliteter, men derfor kan man stadig også godt gøre sådan, at brugerne kan tilføje nøgleord til prædikaterne. Så nu forestiller jeg mig altså, at forfatteren i første omgang får lov at tilføje nogle nøgleord, og at andre brugere så ellers også selv kan tilføje flere, samt rate tilføjede nøgleord op og ned. 

Så angående overlayet, så tror jeg bare man i staten kan nøjes med den standardvisning, jeg snakkede om her lige ovenfor i denne sektion, nemlig hvor lidt af alt bliver vist, og hvor brugerne så kan folde listerne mere ud (måske bare via nedad-pil i starten), og så ellers et søgefelt, så brugerne kan søge på prædikater.\,. eller andre termer såsom ressourcer.\,. de ikke finder i denne standardvisning. Hvis det så findes i databasen, kan de så rate det som relevant for pågældende ressource, og ellers kan de gå til hjemmesiden for at tilføje et nyt prædikat eller en ny ressource(-reference) selv. 

\ldots Nå ja, og jeg forestiller mig også nu, at når brugeren folder nye søjler ud via højre-pil, så ryger søjler, der allerede står til højre, ikke væk, men i stedet bliver den nye søjle bare indsat imellem de eksisterende søjler (lige til højre for dens forældersøjle), således at de gamle søjler til højre for bare rykker en tak længere til højre allesammen. Brugere skal så bare selv manuelt lukke de søjler, de ikke længere har behov for. 

Hvis jeg finder på nogle flere tilføjelser, der er relateret til de andre ting i denne sektion, i løbet af de næste par dage, så vender jeg nok tilbage og tilføjer dem her. Og ellers vil jeg nu gå i gang med at planlægge, hvad jeg vil begynde at prøve at programmere for min første prototype af applikationen.

*Hm, man kunne gøre sådan, at hvis brugeren holder shift inde, så vil en ny søjle erstatte den, der tidligere stod til højre, i stedet for bare at blive sat imellem dem.\,.

*Kopieret nedenfra: ``Der skal også gerne være en liste over ressourcer, der konstant ændrer sig, når man vægler flere og flere kategoriseringer til, hvilket vil sige, at vi måske faktisk nærmest skal tilbage til det der med at have navigationen i en fold-ud-menu, eller noget der svarer lidt til.\,. .\,.Hm, lad os sige, at (graf-)søjle-prædikatsøgningen og ressourceliste visningen kan foregå i to faner.\,. som dog godt også kan vises side om side i en tredje fanemulighed.''

*Kopieret nedenfra: ``Okay, jeg tror faktisk, at jeg vil gøre det sådan, at forfatteren til et prædikat faktisk kan tilføje et vilkårligt antal intervalbeskrivelser, endda med vilkårlige og muligvis overlappende intervaller. Disse skal så vises i en liste under ratingbaren, hvor teksten for kun de intervaller, hvor bar-knappen er indenfor, vises. På sigt vil jeg så faktisk også gerne have, at brugeren bare kan trykke på en tekst og se intervallet, og så endda vælge, om ratingen så skal gives ud fra bar-knappens position, eller i stedet bare ud fra den highlightede teksts interval, hvorved ratingen så bare forståes som, at brugerens rating ligger inden for dette interval! Så dette kan altså således også blive den måde, hvorpå brugerne basalt set giver hinanden mulighed for at lave mere diskrete ratings! Virker fornuftigt nok.\,:) Men ja, i første omgang til prototypen skal teksten bare vises, og ratingen skal bare gives ud fra bar-knappens position altid. :) ''


*(03.02.23, 10:34) Jeg skal også på sigt have implementeret et lille aritmetisk sprog (også med sammenligninger, og gerne inklusiv en if-then-(m.m.-)syntaks) til mine ``automatiske point,'' hvilket så må blive en slags ``automatiske prædikater og ($n$-ære) relationer.'' I dette sprog skal brugerne også kunne oprette deres egne funktioner, og ikke mindst skal de kunne tilgå rating distributioner via funktioner, hvor de altså kalder en funktion, der så har værdier ud fra den nuværende rating-distribution af et prædikat eller en relation.\,. ja, nej, eller af et udsagn rettere. Desuden skal brugerne også kunne kalde diverse almindelige descriptors (er det ikke det, det hedder?) (altså parametre så som gennemsnit, skewness osv. *(samt også hvor mange afgivne stemmer ratingen har)) fra nogle andre faste funktioner (hvor udsagnet er et input). ``Returværdien'' af et automatisk prædikat eller en automatisk relation bliver så typisk findes i form af en automatisk rating af pågældende.\,. ja, vi kan jo så passende kalde det et `automatisk udsagn' (altså et automatisk prædikat eller en automatisk relation taget på nogle inputs).\,. hm, hvis vi snakker $n$-ære relationer, så kan jeg jo bare sige at $n$ godt kan være 1, og dermed undgå at sige `prædikat' hele tiden.\,. Nå, men ``returværdien'' er så typisk en beregnet rating for den automatiske relation taget på givent input. Men på sigt kunne man også tillade, at automatiske relationer ligeledes kan give ``returværdier'' i form af input-placeholders, således at den automatiske relation altså ikke behøver at få visse dele af dets input men i stedet selv genererer, hvad dette input skal have af værdi i det endelige (automatiske) udsagn. (Det svarer altså lidt til at give en pointer med til en funktion i C, hvortil en returværdi så i sidste ende overskriver den oprindelige værdi på adressen, rent konceptuelt.) Og ja, så kan man så overveje, om man ligefrem så vil implementere et logisk sprog på baggrund af dette, men fordi brugerne jo allerede har mulighed for at implementere funktioner, så er dette nok ikke nødvendigt, og brugerne kan altså således bare nøjes med at have de automatiske relationer som noget, hvor det endelige returværdier findes, og altså ikke som noget, der kan indgå i selve sproget, der koder for returværdierne. (10:54)

*(10:59) Noget andet ret vigtigt er, at ressourcer i grunden bare skal være et begræsnet antal felter, der definerer ressourcen, nærmere bestemt ikke mht.\ \emph{hvor} den kan findes, men i forhold til hvad der definerer, den ting ressourc(e-referec)en refererer til.\,. Og hvis så duplianter findes på siden, så skal hjemmesiden og brugernetværket altså i reglen sigte efter at slå duplianterne sammen! Så brugerne kan altså hjælpe med at flagge, når der er duplianter (inklusiv når en ressourcetype er duplikeret), og hjemmeside-crewet skal så tjekke dette, og hvis flaggingen er korrekt, så skal duplianterne slås sammen i databasen. Det vil sige, at man ser på den hemmelige info om, hvilke bruger-ID'er ingår i diverse ratings for udsagn, hvor dublianterne indgår (i hver deres udsagn), og så merger databasen disse udsagn, sådan at alle brugere har stemt én gang. Brugere der har stemt på begge ressourcer til samme udsagn (hvilket nok ikke er så mange), de får så en notifikation om, at to af deres tidligere afstemninger er blevet merget til én (måske med gennemsnittet som det endelige svar, hvis det kan lade sig gøre), og kan så eventuelt rette denne rating, hvis de vil. Sådan noget som URL'er til en ressource, jamen det skal så gerne indgå som et 0-til-mange-felt for ressourcen, sådan at brugere altså selv kan føje flere URL'er til. Dette kan så foregå ved, at databasen opretter en ny relation til den pågældende ressourcetype, som så får et passende navn, der indeholder ressourcetypens navn som et slags efternavn, og hvor forfatteren til ressourcetypen så bestemmer fornavnet. Foreksempel kunne relationen komme til at hedde `Movie.hasLocation(),' og inputsne kan så være en URL og en dato for, hvornår URL'en virkede, samt selvfølgelig den pågældende ``Movie.'' Og ja, brugerne kan så efterfølgende rate diverse URL-forslag. Desuden skal der også være et Obsolete-prædikat, som brugerne bør bruge, hvis f.eks.\ en tidligere URL var gyldig (og derfor har en høj gyldighedsrating i udgangspunktet), men at den pludselig er blevet ugyldig. Således kan brugerne altså hurtigt signalere, at en URL er blevet ugyldig, uden at de skal ``kæmpe mod'' den oprindelige gyldighedsrating (som så i stedet bare bør fortolkes som `var URL'en gyldig ved den pågældende dato'), og samtidigt gør dette så også, at man efterfølgende vil kunne se, om en given URL var gyldig (og populær) dengang den blev oprettet (hvilket man ikke kan, hvis brugernetværket skulle ændre den oprindelige gyldighedsrating, nemlig hvis de ikke havde Obsolete-prædikatet). (11:23) .\,.\,Nå ja, og det at flagge dublianter kan (og bør) selvfølgelig også bare ske via en dertil indrettet relation i databasen. 


\section{My first prototype}

(10:30, 02.02.23) Jeg tror jeg vil kalde projektet (og applikationen/hjemmesiden) for SemDB, indtil videre.\,. Hm, lad mig lige hurtigt se, om det er taget.\,. .\,.\,Hm, kunne ikke finde nogen hits, der var særligt relaterede, så lad mig rigtignok bare bruge dette (SemDB) som det midlertidige navn.

For det første kan jeg nævne, at jeg vente med overlayet, så dette bliver altså ikke en del af den allerførste prototype. 

.\,.\,Lad mig også udskyde RegEx-halløjet og i stedet bare selv prøve at populere databasen med nogle eksempelressourcer.\,.

Jeg skal implementere, at man kan oprette sig og logge ind som bruger.\,. .\,.\,Brugere skal kunne tilføje nye prædikater.\,. .\,.\,Brugere skal kunne samle sig et ikke-struktureret (for jeg vil udskude, at de selv kan oprette mapper osv.) arbejdsbord over.\,. Hm, eller skal jeg prøve at føje struktur til.\,.\,? .\,.\,Nej, ikke med det allerførste.\,. De skal så bare have en enkelt liste over prædikater, og én over ressourcer (never mind relationer for nu), hvor de så bare kan fjerne elementer fra listen som den eneste struktur-ændrende handling her. 

Hm, lad mig nøjes med forfatter-tilføjede nøglefraser til prædikaterne.\,. .\,.\,Lad mig også nøjes med en enkelt type rating, nemlig bare den kontinuere type (fra et negativt tal til et positivt), og lad mig vente med at gøre sådan, at forfatterne kan tilføje intervalfortolkningsbeskrivelser. Så prædikaterne har altså bare en titel, nogle nøgleord/-fraser, en beskrivelse, og det er det for nu. .\,.\,(Så eventuelle intervalfortolkningsbeskrivelser føjes altså bare til beskrivelsen her for prototypen.)

I starten kan brugerne bare vælge imellem et lille antal af prædefinerede filterindstillinger for hvert prædikat (og med en knap til at flippe kurven horisontalt, så man ordner fra negativ til positiv i stedet).\,. 

.\,.\,Hm, lad mig lige tænke over, hvor meget jeg vil gøre ud af flersøjle-prædikatsøgningen i starten, før jeg begynder på oerlayet.\,.

I øvrigt skal filterindstillingerne kun foregå i en menu i højre side i starten, så når brugeren ser et prædikat i en liste, skal de altså kun kunne læse om det, og så vælge og tilføje det til arbejdsbordet --- og sikkert også kunne folde en ny søjle (eller underliste) ud fra den, men det vil jeg lige tænke over.\,. 

.\,.\,Jeg vil forresten bare bruge en PHP-server (og med den type SQL-database, der lige hører til den, jeg finder (.\,.\,hm, som sikkert bliver en Apache-server.\,.)). 

Okay, jeg går en tur i solskinnet og tænker videre over, hvor meget af flersøjle-navigati-onen, jeg skal tilføje her i starten, samt også hvordan brugeren skal finde frem til ressourcetermer og bedømmelsesprædikater.\,. (11:24)

(12:33) Okay, jeg tror vist bare, at jeg for prædikater skal have to muligheder i starten, når det kommer til at udfolde børnelister/-søjler, nemlig `relevante kategoriseringsprædikater' og `relevante bedømmelsesprædikater.' .\,.\,Hm, eller rettere `kategoriseringsprædikater som er relevante til brug for at lave en underinddeling, når givne prædikat er valgt.' .\,. .\,.\,Kortere sagt kunne man bare sige `relevante underkategoriseringsprædikater,' eller endnu kortere: `underkategoriseringer.' 

Der skal også gerne være en liste over ressourcer, der konstant ændrer sig, når man vægler flere og flere kategoriseringer til, hvilket vil sige, at vi måske faktisk nærmest skal tilbage til det der med at have navigationen i en fold-ud-menu, eller noget der svarer lidt til.\,. .\,.Hm, lad os sige, at (graf-)søjle-prædikatsøgningen og ressourceliste visningen kan foregå i to faner.\,. som dog godt også kan vises side om side i en tredje fanemulighed. 

Hm, udover at brugere skal kunne føje prædikater til listen over aktive prædikater, skal brugere så også kunne rate relevans for den pågældende søjle, direkte når brugeren har klikket på et prædikat i en søjle.

Lad mig forresten bare holde mig til søjler og dermed altså udskyde omtalte nedad-pils funktionalitet til et senere tidspunkt (og altså kun have højre-pilen). 

\ldots Ressourcer skal kunne rates efter hver enkelt af de valgte prædikater (som inkluderer de aktive prædikater), og barnesøjle-/fold-ud-mulighederne for ressourcer kan bare være `relevante bedømmelsesprædikater,' `relevante kategorier'.\,. Nå nej, never mind. Begge disse to ting er ikke nødvndige (af hver dere grund).\,. .\,.\,Men `relevante ressourcer' er selvfølgelig en god ting.\,. .\,.\,Nå jo forresten `relevante bedømmelsesprædikater' skal faktisk med.\,. Hm.\,. \ldots Der skal rigtignok være `relevante bedømmelsesprædikater' som en fast relation til ressourcetermer, men det er så bare vigtigt, at man sørger for at brugerne også kan få bedømmelsesprædikat-forslag fra ressourcens kategorier i stedet (altså fra når et prædikat er et `relevante bedømmelsesprædikat' til et kategoriprædikat, og hvor ressourcen så er dømt som inden for den kategori).\,. 


\ldots\ Okay, jeg tror faktisk, at jeg vil gøre det sådan, at forfatteren til et prædikat faktisk kan tilføje et vilkårligt antal intervalbeskrivelser, endda med vilkårlige og muligvis overlappende intervaller. Disse skal så vises i en liste under ratingbaren, hvor teksten for kun de intervaller, hvor bar-knappen er indenfor, vises. På sigt vil jeg så faktisk også gerne have, at brugeren bare kan trykke på en tekst og se intervallet, og så endda vælge, om ratingen så skal gives ud fra bar-knappens position, eller i stedet bare ud fra den highlightede teksts interval, hvorved ratingen så bare forståes som, at brugerens rating ligger inden for dette interval! Så dette kan altså således også blive den måde, hvorpå brugerne basalt set giver hinanden mulighed for at lave mere diskrete ratings! Virker fornuftigt nok.\,:) Men ja, i første omgang til prototypen skal teksten bare vises, og ratingen skal bare gives ud fra bar-knappens position altid. :) (16:14)

Hm, når brugeren tilføjer et prædikat til arbejdsbordet, kan denne tilføje det som aktivt eller ikke aktivt. Jeg tror ikke jeg vil lave to lister til aktive og ikke-aktive prædikater i prototypen (bare have én liste) i arbejdsbordet. I stedet skal de aktive prædikater bare highlightes, og brugeren kan så slå prædikater til og fra her, samt ændre på filterindstillingskurverne, og selvfølgelig også fjerne prædikater fra listen igen som nævnt. 






\section{Flere tanker om semantik-applikationen imens jeg arbejder på prototype}

(04.02.23, 9:54) Jeg føler virkeligt, at jeg har ramt noget rigtigt godt med mine seneste tanker. Førhen tænkte jeg jo mere på at starte med tag-ratings og et kategori(serings)træ (eller rettere en graf) som noget, der var hver for sig. Men nu bliver kategoriseringen meget mere bottom-up, også direkte ud fra rating-tags'ne, og det tror jeg altså bare kommer til at gøre så meget for, at applikationen kan komme hurtigt i gang (og at folk nemlig kommer godt i gang med at kategorisere ting på en rigtig god og naturlig måde). 

(9:59) Nå, men jeg har også nogle tekniske tilføjelser, jeg vil nævne. For det første skal URL'er ophæves til en ret vigtig termtype/datatype for systemet. Når hjemmesiden har godkendt en vis URL-RegEx, som kan hentes data fra, så skal brugerne være rimeligt frie til bare at sende URL'er til databasen, der matcher, gerne endda som en hel strøm af forslag, hvor databasen så bare kan time strømmen ud, hvis der er gået lang tid siden den sidst fik en ny URL --- og afbryde strømmen, hvis der er flere ikke-gyldige URL'er i den. 

Jeg vil også.\,. %Hm, jeg skal lige have nget at spise, før jeg kan fortsætte.. (10:04) 
%(10:16):
\ldots gerne have, at datafelter bliver en anden fast type, hvilket nærmere bestemt er relationsentiteter hver især mellem en ressource(-reference), et navn på datafeltet (f.eks.\ `medvirkende skuespiller'), en datatype (tekst, tal eller binær) og så et (andet) %(for datatypen kan også bestemmes af et byte-flag) 
byte-flag, der bestemmer, om det er en 1-, 0--1-, 0--mange- eller 1--mange-relation (f.eks.\ 0--mange hvis vi ser på `medvirkende skuespiller' i en film). Brugerne kan så rate, om et givent datafelt er relevant for en ressourcereference. Bemærk at disse felter så ikke er en del af, hvad der allerede er brugt til at karakterisere ressourcereference; alle felterne i en ressourcereference er nøglefelter, og alle datafelter er ikke nøglefelter, og er sågar nullable. .\,.\,(Så når jeg har skrevet f.eks.\ 1--mange, så er dette bare et signal om, at man ved at ressourcen har mindst én i virkeligheden, men der kan alligevel stadig godt stå null i den semantiske database.\,.) Nå, og brugerne kan så tilføje data til et givent datafelt, og her kan det bemærkes, at al sådan data kan implementeres i en relationel database som en binær relation, nemlig over et givent datafelts hash-nøgle (for sådan en mener jeg også, at hvert datafelt bør have) samt det givne data.\,. ja, og så skal der jo så også lige være en ny hash-nøgle her også.\,. .\,.\,Ja, jo.\,. Brugere kan herefter så rate disse datafeltinstanser, som vi kan kalde dem, op og ned, og herved kan brugerne altså føje data til eksisterende ressourcereferencer på semantisk vis. %(10:38)

URL'er er så et slags specielt datafelt, som en ressourcereference altid har 0--mange af.\,. Hm, og hvad med datareferencer.\,.\,? .\,.\,Nå ja, det var da egentligt lidt meningen, at der skulle have været en URL i stedet for den faktiske data.\,. Hm, men skal man ikke så bare inddele det i to typer datafelter, hvor den ene gemmer data i selve databasen, og hvor den anden i stedet bare ``derefererer'' dataen fra en URL i stedet.\,.\,? .\,.\,Jo, fint. .\,.\,Her skal det så nævnes, at applikationen dog kun rent faktisk vil hente data fra en URL, hvis det kommer fra en URL-RegEx, der allerede er tillid til (så brugere skal først have deres URL'er godkendt). (10:49)


\section{Nye tanker og idéer! (Attributter! Exisd! Idéer om query-sproget m.m.!)}

(09.02.23, 11:09) Jeg har en hel del gode nye idéer, som jeg har tænkt mig at skrive om (og tænke færdig om, når det kommer til visse dele af det). Men nu vil jeg lige starte med at sige, at jeg lige har fundet på et muligt (umiddelbart rimeligt awesome (men jeg skal selvfølgelig have lidt tid til at summe over det / tygge på det)) navn til web-applikationen! Jeg er lige kommet på, at jeg måske kunne kalde det Exisd. Extendable Interface for a Semantic Database. Umiddelbart ret nice, og sikkert ikke brugt til noget andet ellers. Lige inden jeg kom på det, tænkte jeg også på Exodus, nemlig ift.\ noget a la: Extentable.\,. interface for an Open Database of User Semantics. Umiddelbart ligger der bestemt også noget potentiale i denne idé, hvis man arbejder videre på den --- jeg kan især virkeligt godt lide slutningen (dus) --- men på den anden side synes jeg også, at to stavelser klart slår tre.\,. *(Og betydningen af `exodus' rammer også ret meget ved siden af, og i modsætning til Exisd, så synes jeg, at man tænker mere over betydningen af `Exodus,' når man hører/læser ordet.) .\,.\,Anyway, jeg vil tænke videre over det, men fedt endeligt at have nogle mere mundrette (og i det hele taget ret gode) bud på banen! .\,.\,(Og ja, så exisd.com kunne altså være et muligt domænenavn til hjemmesiden.\,.)

*(Nu tror jeg måske, at hjemmesiden skal hedde sema (.net og/eller .com) i stedet.\,. (14:17, 01.03.23))

(11:50) Nå, lad mig skrive om nogle flere af mine nye tanker, navnlig omkring de grundlæggende typer og den grundlæggende semantik. 

De grundlæggende typer, hvis vi ser på en abstraktion over, hvad databasen skal implementere, skal være diverse konstante grundlæggende datatyper såsom `int,' `float,' `date,' `time,' `date-time,' `binary' og `string.' Som jeg forestiller mig database-implementationen, så skal `int' og `float' altid stå på en plads i en databaserelation (i.e.\ en databasetabel), hvor der alligevel skal være plads til en reference også, så for simpelheden skyld (også fordi `floats' gerne må kunne være double precision minimum) så skal `int' og `float' samt alle reference-adresser bare være 8 bytes lange (altså long, double og long hhv.). Hvis brugerne vil snakke om andre datatyper såsom longint, og hvad har vi, så må de altså selv implementere dem via `object'-typere, som jeg kommer til lige om lidt. Angående `string,' så skal der bare være én type, men databasen kan dog selvfølgelig godt implementere mindst to typer, sådan at der både er en datatype 8 byte lange strings, og også en (eller flere) string-reference-type, hvor databasen slår op i en eller flere andre tabeller. Men som sagt: i abstraktionslaget lige over databasen skal der altså kun være én string-type. Denne skal i øvrigt have en fast encoding. Så igen, hvis brugere vil implementere andre encodings, så skal de selv gøre det via object-typerne. Denne faste encoding skal gerne være UTF-8, eller måske en HTML-escaped ændret udgave af UTF-8. .\,.\,Ja, det kommer lidt an på, hvorhenne saniteringsansvaret skal ligge (altså i hvilket lag), det skal jeg lige tænke over på et tidspunkt (når det passer sig). 

Der skal så som nævnt også være en `object'-type, som bliver den mest centrale type, kan man sige, på nær måske `string,' som også bliver ret central. Disse objekttyper bliver faktisk også defineret af (UTF-8-)strings, men forskellen er, at hvor en string-type (og vi er altså stadig i abstraktionen lige over databasen (.\,.\,tja, som man i princippet også kan kalde en database, for `database' er jo selv en abstraktion (og fås i mange udgaver, ikke bare relationel))) altid bør fortolkes som refererende til strengen selv, så skal en objekttype fortolkes som referere til den entitet som strengen taler om. I princippet kan formatet af, hvad vi kan kalde objektstregen, være alt muligt, men der skal dog gerne være en standard allerede til at begynde med for hvordan man formulerer et objekt via objektstrengen. Og her tænker jeg så simpelthen bare Javascripts syntaks for at definere Javascript-objekter, dog måske faktisk uden tuborgparenteserne, det ved jeg ikke. Men det skal altså gerne bare være en kommasepareret liste af attributdefinitioner, alle på formen ``$<$attribute name$>$=$<$attribute value$>$, hm, hvor attribute name så skal backslash-escape'e alle instanser af `=' samt af `\textbackslash,' og hvor attribute value skal backslash-escape alle instanser af `,' samt af `\textbackslash.'

Så alle objekter bliver altså defineret ud fra en række attributter, men dette er slet ikke alt, jeg hr at sige om attributter! For en anden ny idé går nemlig ud på, at brugerne stærkt skal anbefales generelt altid at prøve at (om-)formulere deres relationer, som de har tænkt sig at føje til databasen, som attributter! Så f.eks.: I stedet for at oprette en relation, der siger ``hasSubcategory,'' så bør de bare kalde relationen for ``Subcategory'' i stedet. Og et andet godt eksempel er, at ``hasRelatedArticle(WhichIsTheSecondInput)'' i stedet bare bliver til ``RelatedArticle.'' Jeg forudsiger, at det kommer til at forsimple tingene en hel del, både udseendesmæssigt, men faktisk også rent forståelses mæssigt, for så er det altid let at forstå, at subjektet i relationen er den der har noget, og at navneordende og tillægsordene, der forekommer i relationsnavnet altid har det med at beskrive objektet --- uden at dette behøver at specificeret via alle mulige andre små ord i en sætning, hvilket nemlig ofte kan være rigtigt kompliceret, især hvis sætningen er tvunget til at starte med ``has,'' og at man derfor i reglen vil være tvunget til at udskifte subjektet i sætningen, hvis man vil begynde at kvalificere objektet! Så ja, at holde sig til at prøve at formulere relationerne som attributter i stedet gør det bare SÅ meget nemmere (vil jeg forudsige)! Herved kan langt de fleste relationer kunne formuleres på formen: ``[Tillægsord, Sammensat tillægsord]$<$Navneord $|$ Sammensat navneord $>$.'' (12:49)

Prædikater må på den anden side gerne have formen ``is$<$Tillægsord$>$'' eller andet lignende, altså formen af lowerCamelCase sætninger, hvor subjektet implicit er det første (og eneste) input, og hvor første ord er et verbum. (Dette er i modsætning til attribut-formen, som altså efter min mening bør være UpperCamelCase og med et implicit verbum samt også implicit subjekt og objekt (og hvor attributnavnet så beskriver objektet).) 

Med disse standarder på plads for vi så et udgangspunkt, hvorfra vi kan definere alverdens semantik. Et passende spørgsmål er så: Hvilken type skal relationerne (som altså også kan (og bør!) fortolkes som attributter) og prædikaterne så have? De skal enten have string-typen eller objekt-typen! .\,.\,Hm, tja, vent lige, for jeg har ikke tænkt på, at det faktisk \emph{kan} lade sig gøre, kun at bruge objekttyper til dem, hvilket hænger sammen med, at attributterne i objektstrengene ikke behøver at følge de samme regler som relationsattributterne (for disse to ting skal faktisk bruges helt forskelligt, hvilket jeg vil vende tilbage til).\,. Hm.\,. (13:05) \ldots Hm, på den anden side var jeg jo egentligt alligevel nået frem til, at alle datatyper bliver til, hvad vi måske kunne kalde dynamiske objekter, så at sige.\,. så måske betyder denne overvejelse egentligt ikke så meget.\,.\,?\,.\,. .\,.\,Jo, så never mind.\,. Så alle datatyper kan fortolkes som objekter, nemlig ved altså at lade dem indgå i relationer, hvor relationen er formuleret som en attribut. I princippet kan relationer og prædikater dermed også bare have alle typer, men i praksis giver det selvfølgelig kun mening.\,. tja, hvis de er strenge eller konstante objekter, skulle jeg til at sige, men i princippet kunne man også vælge binær.\,. Tja, men det ville dog være meget mærkeligt at gøre, medmindre at en gruppe brugere på en eller anden måde kan finde gavn af dette på et tidspunkt. Men ja, i reglen bør relationer og prædikater altså enten være strings, og mere specifikt altså som følger den ovennævnte standard (på nær at brugerne også godt \emph{må} formulere relationer på mere konventionel vis, selvom de dog stærkt er opfordret til at formulere dem som attributter i stedet), og eller kan de være konstante objekter.\,. Hm, jeg skal forresten finde på en bedre måde at skelne mellem objektstreng-objekter og streng-objekter.\,. .\,.\,Hm.\,. .\,.\,Hm, jeg kunne måske bare kalde objektstrengene for `objektdefinitioner' i stedet.\,. .\,.\,Ja, det kommer vist til at give rigtig god mening.\,.(!) .\,.\,Klart. Ok, så alle datatyper bør fortolkes som objekter i princippet, og så kan man så dele alle objekter ind i to overordnede kategorier, nemlig i, hvad vi kunne kalde `datamonader' (hvilke så fås i flere underkategorier alt efter den pågældende datatype --- så vi har f.eks.\ `string-monader' og `int-monader' osv.), og så i, hvad vi kunne kalde.\,. .\,.\,hm, man kunne bl.a.\ kalde dem `attributdefinerede objekter.' (13:42) .\,.\,Yes! .\,.\,Hm, eller i stedet for `datamonader,' kan vi også bare kalde dem data\emph{instanser} i stedet, det virker simplere og bedre.\,:) 
.\,.\,Hm, ja, og faktisk burde man næsten kalde det for `attributdefinerede instanser' i stedet.\,. tja, eller det er så spørgsmålet, om vi skal sige ``objekter'' eller ``instanser''.\,. måske er det bedre at sige ``objekter'' i stedet faktisk.\,. .\,.\,Ja, yes, lad os gøre det!\,. 

Så langt, så godt! Lad mig se, hvad skal jeg så fortsætte med at forklare om.\,.\,? (13:50) .\,.\,Nå jo, jeg skal jo først og fremmest lige pointere, at en objektdefinition så typisk ikke er beregnet til at blive brugt i den semantiske databases QL. I stedet forventes det, at brugerne selv tilføjer faktiske attributter (som i princippet altså er omfortolkede relationer) til objekterne, bl.a.\ så at attributterne fra objektdefinitionen også kommer med og bliver til ``faktiske attributter.'' Bemærk, at dette faktisk gør, at man endda kan rette i objekters definerende attributter, nemlig hvis der ikke er nogen tvivl om, hvad objektet repræsenterer, men at der alligevel er sneget sig en fejl ind i definitionen. Et godt eksempel på dette (som dog slet ikke er det eneste eksempel) kunne være, hvis nu man skraber sig til an masse objekter andre steder fra på webbet, men at der så er en lille fejl på en af de lokationer, %...(14:09):
typisk vil man så alligevel kunne regne ud, hvilket objekt der er tale om. Brugernetværket behøver derfor ikke nødvendigvis så at lave et nyt objekt og gentage deres ratings omkring det, men kan så i stedet bare rette i de ``faktiske attributter,'' der indeholder pågældende information. Et andet tilfælde kunne være, hvis nu en af de definerende attributter ændrer sig. Lad os sige at man har en objektklasse af vindere af en eller anden pris, men at én prisvinder pludselig får deres pris annulleret. For ikke at miste ratingdata kan brugernetværket så sagtens bare omformulere de faktiske attributter, så de igen bliver tidssvarende, uden at det altså gør noget, at den oprindelige, ikke-tidssvarende objektdefinition beholdes (for denne bruges altså alligevel bare til at sætte objektet i gang, så at sige). Objektdefinitioner skal altså bare være rimeligt entydige, når de formuleres, hvis man gerne vil have objektet til at bestå, men behøver altså ikke at være fuldt ud korrekt og til alle tider. Endvidere kan objektdefinitioner også godt indeholde en formel tvetydighed, uden at dette gør, at brugernetværket bliver nød til at kassere objektet, for så længe brugernetværket ikke er i tvivl om, hvad var refereret til originalt med objektdefinitionen, så gør det ikke noget, at man senere finder frem til, at der også kunne være en anden fortolkning. Endvidere kan det også være, at brugernetværket får lyst til at dele tidligere objektklasser op i flere versioner. .\,.\,Hm, jeg kan faktisk ikke lige komme på noget godt eksempel, men anyway, lad os sige at netværket gerne vil dele en tidligere klasse op i to udgaver.\,. Tja, never mind, jeg behøver ikke at gå så meget i dybden med det her --- pointen er alligevel bare, at det er ret smart at objekters definitioner ikke behøver at være korrekte (og til alle tider) og hamret ind i sten fra starten af, men at man godt i praksis kan rette på objektdefinitionerne løbende (også selvom den faktiske `objektdefinition'(sstreng) forbliver den samme) uden at miste værdifuld ratingdata omkring objektet. (14:24)

.\,.\,Hm, lad mig lige hurtigt præcisere, at den semantiske database altså kender forskel på et attributdefineret objekt defineret ud fra en given string og så et string object defineret ud fra samme givne string. Så selvom disse to objekter er defineret ud fra samme data, så har de alligevel en typeforskel i den semantiske database, der gør dem forskellige fra hinanden. 

.\,.\,Nu kommer vi vel så til `udsagnene' i den semantiske database (som altså er en abstraktion i et lag over den relationelle database, jeg tænker skal implementere den semantiske database). Et udsagn består, foruden et unikt id (som altså også er med i abstraktionen), af et subjekt-objekt, et relations-/prædikat-objekt, og muligvis et objekt-objekt, alt efter om relations-/prædikat-objektet skal tolkes som en relation eller et prædikat. Her synes jeg så, det er værd at bemærke, at jeg faktisk også forestiller mig, at dette skal implementeres som en enkelt relation i den underliggende relationelle database, som altså både indeholder relations- såvel som prædikat-udsagn, og hvor der så bare lige er et bool-flag, der siger, om det er det ene eller det andet (og hvis flaget er sat til IS\_PREDICATE så skal objekt-objektet selvfølgelig bare altid være null). Herved er det altså udsagnet selv, der ved, om det er et relations- eller et prædikat-udsagn, og hermed skal man altså slet ikke tænke på typer i abstraktionen (a.k.a.\ den semantiske database), når det kommer til at danne udsagn. Så rent typemæssigt består `udsagn'- (eller `statement'-)typen i den semantiske database altså bare af: RelationStatement of Object $\times$ Object $\times$ Object $|$ PredicateStatement of Object $\times$ Object, og hvor objekt så har de førnævnte undertyper af `attributdefinerede objekter,' `string-objekter,' `int-objekter,' osv. Og det er så op til brugerne af den semantiske database selv ikke f.eks.\ at sætte et talobjekt in på en relations plads, eller ikke at sætte f.eks.\ AttDefObj(`Type=predicate, Title=isFunny, Description=[...]') eller StrObj(`isFunny') ind som andet objekt i et prædikat-udsagn. .\,.\,Hm, nu bliver jeg lidt i tvivl om ikke, man bare skal lægge op til en standard om at bruge lowerCamelCase overalt i stedet for attribut- prædikat- og relationsnavne, det synes jeg faktisk.\,. .\,.\,Jo, lad mig sige det for nu. Så kunne jeg altså derfor have skrevet AttDefObj(`type=predicate, title=isFunny, description=[...]') og StrObj(`isFunny') i stedet. Bemærk forresten at man i modsætning til i Javascript og XML m.m.\ ikke behøver at putte gåseøjne omkring værdierne, for det er kun mennesker, der skal læse det alligevel, aldrig maskiner. Maskiner skal nemlig kun læse de ``faktiske attributter'' m.m., som forklaret ovenfor. .\,.\,Hm, men jeg tænker godt nok også at bruge en lidt tilsvarende syntaks for query-sproget, så det kan jo godt være, at man så for objektdefinitionerne vil vælge at holde sig til en tilsvarende syntaks også, nemlig for konsistensens skyld. Men ja, heldigvis er dette i sidste ende bare op til brugerne, for igen: Det er kun mennesker, der skal læse objektdefinitionerne, ikke maskiner (på nær hvis man vil udplukke det strengobjekt som er defineret ud fra samme streng for så at lave streng-operationer på det, hvilket jeg nemlig vil have, at man skal kunne, men det kommer jeg til på et tidspunkt). (Men i forhold til at fortolke værdierne i et attributdefineret objekt, så er det altså kun i reglen mennesker, der skal gøre dette.) 

Nå ja, og i tråd med, at jeg altså gerne vil implementere relations- og prædikatudsagnene i samme tabel i den underliggende (relationelle) database, så skal StatementID'erne også bare løbe fra ulong 0 til ulong $0 - 1$, hvor prædikat- og relationsudsagn altså bare er helt blandet sammen, og hvor ID-nummeret altså bare afhænger af, hvornår udsagnet blev oprettet (igen uagtet undertypen). 

Nu når vi jo så til Rating-typen i den semantiske database, hvilket så består af et udsagnsID, et brugerID, et flag der angiver rating-typen og så ellers to dataobjekter, hvoraf det første meget gerne skal være en double float, der beskriver gennemsnitspunktet for brugerens rating. En af de halt basale ratingtyper kan så være, hvor det andet dataobjekt også er en double float, der beskriver interval radiussen, således at sådanne ratings altså gives som en slags step-funktioner, der så altså er defineret ud fra et midtpunkt og en (halv) intervalbredde. Desuden må ratings også meget gerne indeholde et timestamp (date--time) for, hvornår de blev givet. I modsætning til de andre ting i den semantiske database, så skal brugere ikke generelt have adgang til andre brugeres ratings, altså medmindre at brugerne har givet tilladelse til andet (og ikke har trukket denne tilladelse tilbage, hvad brugere nemlig også skal kunne når som helst). .\,.\,Det kan dog godt være, at man i betaversionen af applikationen bare undlade at implementere denne del, og i stedet bare advare alle brugere i betaversionen om, at alle deres ratings vises offentligt indtil betaversionen slutter. .\,.\,Man ja, lad mig vende tilbage til emnet omkring, hvem kan se hvad, og om hvordan brugere har ret til altid at null'e deres egne bidrag og/eller data, der forbinder dem med objekter m.m.\ i databasen, for det er ikke et vildt centralt eller presserende emne. (15:33)

.\,.\,Sikke tiden er fløjet, men det er jo også en omfattende ny omgang idéer, jeg har skulle skrive om. Jeg mangler nemlig også endda at skrive mere om QL'et, og så skal jeg også skrive om nogle nye idéer ift.\ det med at brugere skal kunne oprette HTML-, CSS- og Javascript-biblioteker/-udvidelser i databasen, som andre brugere så skal kunne loade og bruge (hvis de kan se, at mange har gennemgået koden og godkendt den). Mine ben summer helt vildt efter at blive rørt lidt (som i: helt vildt meget, faktisk), men når jeg kommer tilbage, så kan jeg måske bare lige skrive noget kort om QL'et, skrive om brugerudvidelserne, og så sikkert vende tilbage til QL'et, for jeg regner med, at jeg skal bruge nogle af de kommende dage på at få det på plads.\,. Men ja, gåtur nu! (15:45)

(16:44) Okay, jeg er kommet i tanke om, at man jo selvfølgelig ikke bør bruge strengobjekter som prædikater eller relationer, for det strider jo klart imod den semantik, jeg har lagt op til (nemlig hvor alle dataobjekter kun skal fortolkes som den værdi, de repræsenterer). Og dermed giver det faktisk også mening at kræve, at prædikater og relationer i udsagnene faktisk skal være attributdefinerede objekter, hvilket jo så også sagtens kan lade sig gøre, for den semantiske database kender jo som nævnt allerede forskel på objekt-undertyperne. 

På denne måde kan man forresten også, indså jeg så i samme forbindelse, nok gøre så at.\,. ja, det kan man.\,. gøre så at attribut-(/relations-/prædikat-)nøgleordene kan ændre stil efter brugerens behov.\,. .\,.\,Jeg vender tilbage til dette emne, når jeg når til QL'et, men jeg forestiller mig nemlig så, at brugere kan hive passende nøgleord ud af objekterne (fra deres ``faktiske attributter'' --- hvilket vi forresten også kunne kalde `levende attributter'.\,.), og identificere dem med objektets objektID, nemlig som hvad der svarer til variabeldefinitioner i QL'et. .\,. 

(17:04) På den anden side! Hvad med at jeg bare siger, at der også skal være endnu en objekttype, nemlig en `attribute'-type, som så lige præcis er defineret af strenge, der repræsenterer prædikater eller relationer, og som så følger den standard jeg talte om her tidligere på dagen (altså hvor relationer er formuleret som attributter i stedet, og hvor predikater omvendt gerne starter med et verbum (og gerne med lowerCamelCase-konventionen))?\,!\,. .\,. .\,.\,Hm, tjo tja, lad mig lige tænke lidt over det.\,. .\,.\,Tjo, måske har jeg faktisk fat i noget ret godt her, for i bund og grund handler det så om, at man så kan bruge attributnavnene direkte i QL'et, hvilket jo så netop giver mening, fordi hver attributnavn kun kan referere til ét attributobjekt, og i øvrigt også fordi navnet har en programmeringsvenlig form.\,. nå ja, måske skulle man endda kræve, at attributnavne ligefrem er ASCII, således at alle kan være med på trods af forskellige keyboard layouts. Det virker som en meget god idé.\,. Hm, og skal man så fjerne UTF-8-typen, eller skal have to typer, eller skal man som tredje mulighed bare.\,. tja, ikke have en ASCII type alligvel, men bare tjekke for hvert nyt attributobjekt, at strengen ikke indeholder ikke-ASCII.\,.\,? .\,.\,Det sidste er nok faktisk det nemmeste og det bedste.\,. (17:27) 

.\,.\,Hm, måske kunne man faktisk godt gå tilbage til den standard jeg beskrev, med UpperCC for attributter og lowerCC for prædikater (og eventuelle relationer), hvor sidstnævnte så starter med et verbum. For der er nemlig ingen, der siger, at man behøver at bruge samme konvention for objektdefinitionerne.\,. Hov vent, nej, for navnene skal jo gerne være programmeringsvenlige til QL'et, så derfor skal det faktisk være lowerCC det hele. 

Hm, jeg skal nu lige tænke lidt mere over, om det giver mening.\,. eller rettere, hvor godt det giver mening at have det på den måde med de her ``attributobjekter''.\,. .\,.\,Hm, kan det ske, at det kunne være sådan, at disse ``attributobjekter'' så bare bør være beregnet til meget fundamentale attributter, som altså indtager meget centrale pladser i hele semantikken, og at man, ligeså snart man bevæger sig væk fra de helt fundamentale --- meta!\,.\,. --- ting, så i stedet bør begynde at bruge de ``attributdefinerede objekter'' i stedet.\,.\,? (17:39) 
.\,.\,Hm, alternativt kunne man forresten også bare ændre navnet og fortolkningen af `attributdefineret objekt'-typen, så den også inkluderer objekter, der alene er defineret ud fra lowerCC-navne (nemlig med den attribut-/prædikat-/relations-fortolkning, jeg har snakket meget om).\,. Hm.\,. .\,.\,Tja, og dog: hvorfor ikke dele det op i to typer?\,. .\,. 

Hm, nu tænker jeg så at gøre, så at man enten kan bruge strenge inkapslet i gåseøje eller bruge variable --- eller objektID'er, hvis man virkeligt vil det.\,. nå nej, vent. Lad mig sige det sådan her: Man kan enten bruge strenge inkapslet i gåseøje eller objektID'er, når man referere til en attribut i QL'et, og desuden kan man også altid bruge variable, som så enten kan indeholde en streng eller et objektID. Men ja, jeg vil jo snakke videre om QL'ets opbygning på et senere tidspunkt.\,. .\,.\,Men jo, jeg synes umiddelbart, at dette giver.\,. hm.\,. .\,.\,Jo, det giver mening, for så bør programmører bare i reglen starte med at omdanne alle attributstrengene af de mest almindelige attributter til variable i stedet, sådan at man herefter kan undlade alle gåseøjnene.\,. Hm, men vent, hvad er idéen så med attributobjekter, for så kan man da ligeså godt bare bruge attributdefinerede objekter i stedet?\,.\,. Hm.\,. .\,.\,Ja.\,. (18:04) .\,.\,Ja, jo, men er det så ikke bare det; tilbage til at dele ting op i dataobjekter (af diverse undertyper) og attributdefinerede objekter og til så at kræve at alle prædikater/relationer/attributter skal være af sidstnævnte type?\,.\,. .\,.\,Virker fornuftigt nok, og så er det forventet, at alle bruger et helt grundlæggende bibliotek i første omgang til at definere variable, der repræsenterer de helt grundlæggende attributter. (18:08) .\,.\,Jo, fedt! 

.\,.\,Hm, lad mig egentligt begynde at kalde det `semantiske objekter' i stedet for `attributdefinerede objekter'.\,.\,!\,:) (18:13)

.\,.\,Hm, det eneste er, at objekter nok rammer lidt ved siden af, når vi jo f.eks.\ snakker prædikater og relationer, så hvad med at kalde det `semantiske entiteter' i stedet! Og ligeledes kan jeg så kalde det `dataentiteter' i stedet, hvilket så videre inkluderer `string entities,' `int entities,' osv. Fedt! Især den ændring med at erstatte `attributdefineret' med `semantisk,' det er virkeligt bare en dejlig ændring.\,.\,!\,:) 

(10.02.23, 9:51) Bemærk, at det nu jo heldigvis i princippet bliver ligemeget, det med at opfordre til at bruge en særlig standard for prædikatnavne og relations-/attributnavne. Men fordi jeg har tænkt mig at designe QL'et, som jeg har tænkt mig, så vil det stadig blive ret naturligt, og en god idé(!), det med generelt at gå efter at formulere relationsvariabelnavne som attributnavne. 

I går aftes fik jeg tænkt en del mere over QL'et, og jeg fik også tænkt over, hvad der lidt er det store emne/problem ligenu for mig, hvilket er implementationen af ``brugergrupperne.'' Angående det sidste er jeg så faktisk kommet lidt frem til, at databasen nok kan komme rigtig langt med den helt åbne del af den, altså den del af den som alle har adgang til at se.(.\,!) For brugere får så bare et buger-ID, når de opretter sig, og har i udgangspunktet ikke noget brugernavn i den offentlige database. Det kan de så tilegne sig ved at gå ind på sit eget brugerobjekt, eller rettere sin brugerentitet ifølge min nye terminologi, og up-rate en given brugernavnsattribut. Hjemmesiden kan så have en bot, der parser for grimme ord, og hvis ikke sådanne findes, hvis brugernavnet ikke allerede er tilknyttet en anden bruger, og hvis botten kan se, at brugernavnet er up-ratet af brugeren selv (med det givne bruger-ID), så kan den give et up-rate på navnet også. Ved så at bruge en `brugergruppe' kun bestående af den bot, kan brugernetværket altså herved nemt get'e brugeres selvvalgte brugernavne, hvis de har nogen, og få det vist passende steder i applikationen. 

Lad os så forestille os, at hjemmesiden har en privat database over brugere. For hver bruger kan den private database så.\,. ja, ikke engang gemme hvilke bruger-ID'er er tilknyttet hvilke privat-database-brugere, men bare for hver bruger gemme antallet af oprettede offentlig-database-brugere (hver med et offentligt bruger-ID i den offentlige database). I den offentlige database kan hver bruger så også bare få en offentlig krypteringsnøgle, som kan bruges til at indsende uploads, inklusiv ratings, med. Men den private database gemmer altså ikke den offentlige nøgle selv, den videresender den bare til den offentlige database, når den får den, og sletter den så selv. Og når det er sket, så kan den private database bare forhøje en counter med én, nemlig som så repræsenterer den private brugers antal af offentlige brugere. Hermed kan den private database så begrænse, hvor mange offentlige brugere, den vil tillade hver private bruger at have, men dette antal må gerne være så stort som 10 eller tæt på. På denne måde er hver bruger nemlig sikret, at de har nok forskellige identiteter på den offentlige side, således at de kan undgå at hver enkel (på nær måske én) offentlige profil kan tilknyttes vedkomnes virkelige identitet --- eller tilknyttes en af vedkommendes online identiteter for den sags skyld --- hvis brugeren ikke ønsker dette. Ok! Og med dette, så kan man sikkert bare gøre brugerentiteterne samt deres ratings til noget, som alle i princippet har adgang til, og komme rigtig langt med dette! Det tror jeg på! .\,.\,Og det forsimpler jo virkeligt nogle ting, samtidigt med at det også åbner op for rigtig mange muligheder for brugernetværket med et enkelt slag! Virkeligt nice!\,:) 

Det gør også, at den offentlige database nu også potentielt set kan implementeres som en spredt, decentral database. For hver del af den spredte (distributed) database kan så bare have sin egen private database, som de stoler på i forhold til at være en kilde til offentlige brugernøgler (og som ikke tillader for mange per private bruger). Hm, dette leder jo så med det samme til at tænke på, om ikke man så skulle indføre et præfiks til alle bruger-ID'er i princippet, sådan at man åbner op for, at den offentlige database på et tidspunkt kan blive spredt, hvorved hver afdeling af den spredte database så kan sætte sig på sit eget præfiks og så eller nummerere alle sine brugere i rækkefølge fra 0 til ulong $0-1$.(?) .\,.\,Hm, men så skal man vel også have en præfiks på alle adresser i det hele taget.\,. det kan jeg mærke, at jeg ikke har nok forstand på (altså spredte databaser) til at kunne forudsige. .\,.\,Ja, så lad mig selv undlade at tænke på sådanne præfikser, og hvad har vi, for heldigvis kan man jo altid bare tilføje sådanne med tilbagevirkende.\,. Nej, vent.\,. Hm.\,. .\,.\,Ah: Jo, man kan tilføje præfikser på alle adresser med ``tilbagevirkende kraft,'' men man kan dog ikke tilføje det til de semantiske objekter med tilbagevirkende kraft, så hvis vi ser på det semantiske.\,. den semantiske entitet, der skal repræsentere en offentlig brugerprofil, så skal det altså gerne lige præciseres, at hvad bruger-ID'et refererer til (nemlig en bruger i den originale af de semantiske databaser/databaseafdelinger), det er klart. Hm, men jeg skal så lige tænke over, om brugerentiteter udelukkende skal være semantiske entiteter, eller om der også skal være en hvis bruger-ID-dataentitetstype.\,.\,? (10:41)

.\,.\,Forresten, angående det med præfikser, så vil den første database aldrig nå op på de høje nok long adresser, så efterfølgende databaser/databaseafdelinger kan i princippet bare starte fra en passende stor long-adresse, og så nummerere alle sine adresser derfra. For hvis de nederste bytes er 0 i den valgte startadresse, så vil dette jo bare svare til at vælge et præfiks. (Jeg ville bare lige nævne det, men jeg har ikke tænkt mig at tænke mere over det emne (omkring en spredt database)).

Angående brugerentiteterne, så skal dette jo nok bare være semantiske entiteter med en fast skema for entitetsdefinitionerne, hvor databasen, eller rettere databasecontrolleren, uploader en sådan entitet, hver gang en ny brugerprofil oprettes. Her skal brugerprofilens (unikke) offentlige krypteringsnøgle så indsættes. Og når en bruger uploader en rating til databasen, så krypteres dette upload bare med den tilhørende private krypteringsnøgle, hvorved databasen så kan tjekke, at ratingen stammer fra den givne bruger, og hvis dette stemmer, så opretter databasen en rating i databasen, hvor brugerreferencen så simpelthen bare bliver den semantiske brugerentitets adresse i databasen, og altså ikke selve bruger-ID'et. Det lyder altså ret fornuftigt.\,;)\,\textasciicircum\textasciicircum\ 

\ldots (11:18) Inden jeg går videre, skal jeg også lige nævne, at det så er meningen, at brugere kan bruge vilkårlige tredjeparter til at hjælpe brugeren med at fordele tillid fra én offentlig profil til en anden (mere anonym) profil. Dette kan ske ved at brugeren krypterer en meddelelse med flere af af sine offentlige krypteringsnøgler og sender den i hemmelighed til en tredjepartsinstans, som vekomne stoler på ikke vil røbe hemmeligheden og vil slette hemmeligheden fra hukommelsen, efter at proceduren er fuldført. Instansen kan så tjekke, at de givne profiler er tilknyttede, og kan så beregne en vis samlet tillid, samt muligvis en vektor der approksimativt beskriver brugerens samlede interesser og/eller holdninger (muligvis krydret med en lille tilfældig vektor som plusses på). Og herefter kan instansen så per brugerens forespørgsler så oprette ratings i den offentlige semantiske database omkring de profiler, som brugeren ønsker.\,. nå nej, omkring \emph{den} profil, for i reglen vil man kun gøre det for en profil ad gangen (som modtager tillids-, interesse- og/eller holdningsbekræftende data om sig) for ikke at afsløre tilknytningen offentligt. *(Tja, eller også kan man bare bede instansen om at holde på hemmeligheden i et forlænget tidsrum sådan at den kan rate flere profiler i det tidsrum, nemlig ved så at tilføje tilfældige delays mellem hver profils ratings (og hvor vektorernes tilfældige krydderi så også ændres for hver gang).) Instansen har således en offentlig profil (hvor omverdenen altså kender profilens tilknytningen til instansen) i den offentlige database, hvor den så efterfølgende kan oprette ratings, for den givne brugerprofil som ønsket. .\,. Og når den har oprettet de ønskede ratings, sletter den altså så alle hemmelighederne igen fra brugeren af. Efter hele denne procedure kan andre brugere i brugernetværket nu (eventuelt; hvis de altså har tillid til instansen) bruge instansens ratings til at hjælpe dem med at fordele tillid m.m.\ til diverse brugerprofiler. (11:36)

Ok! Inden jeg fortsætter omkring QL'et, så bør jeg lige snakke lidt om web applikationens interface, og om hvordan brugerne selv kan udvide det. Lad mig starte med at tegne et billede af, hvordan jeg forestiller mig at en tidlig implementation af interfacet kunne se ud. Jeg forestiller mig nu for det første, at der skal være en QL-kolonne/søjle / -fold-ud-menu til venstre, hvor avancerede brugere (hvilket jeg så lidt regner med at alle de helt tidlige brugere vil være (eller rettere blive; relativt til de efterfølgende brugere)) kan skrive og gemme QL-scripts. Når et QL-script (query language, btw) har kørt, så kan scriptet enten vælge, at outputtet skal være en ny kolonne helt til venstre, en kolonne helt til højre, en kolonne lige til højre (eller venstre) for QL-kolonnen (da denne også muligvis kan forekomme som en søjle inde imellem andre søjler/kolonner), eller om outputtet skal åbnes i en ny fane i browseren, eller bare i et nyt vindue i samme browserfane, hvor brugeren så kan skifte mellem disse applikationsvinduer. Det typiske output vil så være en liste af semantiske entiteter, som regel af en vis samme ``type.'' Her er det så vigtigt at pointere, at ``typen'' her bare er defineret ud fra en semantisk (``levende'') attribut ligesom alt andet omkring entiteten (lige på nær dens entitetsdefinition). Men ``type'' skal nu alligevel gerne være en ret fundamental attribut, som hjemmesiden selv i høj grad i starten hjælper med at sætte for hver entitet (og helst i forbindelsen med oprettelsen af entiteten). .\,.\,Hm, ja, man kunne faktisk benytte sig af en vis konvention starten om, at brugere (såvel som hjemmesidens selv ift.\ dennes bidrag/``uploads'') \emph{skal} definere typen i starten af enhver ny semantisk entitet. Hvis en bruger så definerer en typen mærkeligt/forkert ift.\ de efterfølgende definerende (semantiske) attributter i definitionen, jamen så kan brugernetværket bare let kassere entiteten (for det vil nemlig være så godt som umuligt at overse ``typen,'' ift.\ hvordan jeg tænker, at det kommer til at blive, nemlig fordi jeg tror, at ``typen'' vil blive et helt centralt element i alle (gængse, fornuftige) QL-scripts). Jeg forestiller mig så, at hver (tidlig, avanceret) bruger i princippet så vælger en HTML-skabelon for hver type, eller rettere to: En til brug når entiteten vises i en liste og én til brug, når entiteten vises på dens egen ``side,'' så at sige (som jeg også har været inde på før). %(12:00) 
%(12:08):
.\,.\,Noget der så måske er nyt, er at jeg nu forestiller mig, at mulighederne som brugerne har ift.\ at gå til entitetens egen ``side'' eller at folde flere søjler ud på baggrund af entiteten --- eller at tilføje nye variabeldefinitioner til ens QL-script til venstre! --- det skal alt sammen bare implementeres i omtalte HTML-skabeloner (som også godt må indeholde Javascript!) fra starten af. Så man åbner altså det hele op for brugerne fra starten af (og hvor de tidlige brugere altså herved er programmører). Og nu er jeg godt nok bevæget mig lidt væk fra, hvordan jeg forstiller mig et tidligt interface, men lad mig bare fortsætte med dette mere generelle omkring interfacet, og hvordan det kan udvides af brugerne, og så kan jeg senere fortsætte omkring, hvordan jeg forestiller mig en tidlig implementation. (Hm, lad mig lige skifte paragraf og fortsætte omkring det generelle.\,.)

Den gode pointe er så, at det rent sikkerhedsmæssigt ikke kommer til at være anderledes, end hvis brugeren selv programmerede noget i javascript og så åbnede det i en browser. Her kan man jo også søge online på kodeudsnit, hvilket man så delvist kan gennemgå selv og delvist kan vurdere tillid til ud fra, hvordan andre online brugere har ratet kodeudsnittet på siden, hvor man tager det fra. For det skal nemlig ikke være sådan, umiddelbart, at de tidlige brugere kommer til at loade deres HTML--JS-biblioteker/preamble-QL-scripts via queries, som så kan ændre sig i princippet fra gang til gang! I stedet er det meningen, at brugerne refererer til bibliotekerne/scriptsne direkte via deres entitets-ID'er(/-adresser) i databasen, hvilket nemlig ikke ændrer sig fra gang til gang. Så ja, og fordi alle biblioteks-/preamble-script-referencer er konstante, så er det altså helt ligesom at kode javascript i almindelighed. Når vi så ser på en specifik HTML--JS-skabelon, som brugeren vælger til en vis entitetstype (altså den semantiske type), så skal der selvfølgelig være en klar konvention om, at al Javascript i disse skabeloner kun ændrer på ting inde i skabelonen, og altså ikke ændrer på nogen globale variable osv. Og hvis en bruger uploader en skabelon, der gør dette, så vil den jo bare aldrig blive stemt op af nogen troværdig bruger. Hjemmesiden bør forresten også selv hjælpe til med at verificere at skabeloner ikke gør nogle uhensigtsmæssige og/eller skadelige ting, men i sidste ende er det vigtigt ikke at stole på noget, medmindre man kan se at nogle af de troværdige avancerede (måske tidlige) brugere har up-ratet det (og ingen af dem har down-ratet det). 

Hjemmeside-interfacet skal så fordre brugerne med indbyggede JS-funktioner, som de kan gøre brug af i deres HTML(--CSS)--JS-skabeloner, som så bl.a.\ kan bruges til de nævnte ting såsom at åbne nye kolonner ved siden af den relevante kolonne eller i en af enderne, og såsom at tilføje nye variable til brugerens script til højre. Disse funktioner skal også selv inkludere muligheden for at bygge diverse QL-scripts. Bl.a.\ kunne man have en funktion, der parser en string skrevet i pågældende QL-sprog og returnerer et slags query objekt, som brugeren/programmøren så videre kan bruge til at åbne nye kolonner. Jeg har ikke nævt det endnu, men selve listerne i hver kolonne skal også have en HTML--osv.-skabelon, som brugerne så i princippet selv kan vælge. .\,.\,Ah, man kunne eventuelt gøre det sådan, at man laver en funktion, der tager en reference til en liste-HTML--osv.-skabelon samt en QL-string, og så åbner en ny kolonne (ud fra noget ekstra input som også specificerer valget om, hvor og hvordan denne skal åbnes) og videregiver QL-strengen, eller en umiddelbar oversættelse af den i form af et query-objekt, til den nyåbnede kolonne, hvorefter den refererede liste-HTML--osv.-skabelon så kan gå i gang med at bruge query-strengen/-objektet til at ufylde listen med entiteter. Så kan det så videre være denne liste-blabla-skabelons ansvar at vælge den blabla-skabelon, som bestemmer, hvordan entiteterne skal vises i listerne. Bemærk, at der bliver en cirkularitet i dette (fordi den åbnede kolonne så igen kan indeholde entiteter, der skal tildeles den skabelon, som man åbnede listen med i første omgang), men dt kan man sikkert sagtens løse på en god måde. (12:49)

Og ja, når det så kommer til alle disse skabeloner, så er det altså alle sammen nogen som brugeren selv skal gå ind og vælge til (altså når vi er i hjemmesidens tidlige stadie, hvor brugerne er programmører). Så på den måde bliver der altså ikke fare for (og dette kan man let sikre), at interfacet åbner henter flere skabeloner under brugerens normale brug af interfacet. Alle skabeloner skal nemlig bare åbnes som en del af QL-sproget (som altså derved næsten kan siges at blive lidt mere end bare et QL) preamble/header. Og preamblen/headeren bliver altså en ting, der er helt adskilt fra brugerens, lad os kalde det et `arbejdsscript.' Headeren, lad mig kalde den det, kommer til at indeholde skabelon-includes, og den kommer faktisk også til at indeholde noget andet ret vigtigt, nemlig nogle indledende indstillinger for hver ``type,'' lad mig forresten kalde det den `semantiske type' fra nu af, som så nemlig automatisk bliver sat på som et indledende filter for alle efterfølgende queries af pågældende type, medmindre altså at man escaper disse indledende indstillinger igen. Dette gør at brugeren selv kan sætte et personligt filter for, hvilke entiteter brugeren generelt gerne vil se optrædende i diverse kolonne-lister, som brugeren åbner i interfacet. Dette filter kommer så nedenunder alt, hvad en bruger, der har valgt et bart header-filter, ville se, hvis denne bruger brugte de samme skabeloner i interfacet. Så for at opsummere, så kommer headeren altså til at bestå (indtil jeg kommer i tanke om andre ting også) af skabelonsvalg for hver semantiske type samt grundfilter-valg for hver semantiske type. 

Og nu kunne man så spørge: Jamen, vil det så sige, at brugerne kun kommer til at kunne se entiteter af de semantiske typer, de allerede har godkendt i deres header? Ja! Eller faktisk nej, ikke nødvendigvis, for brugeren kan nemlig også helt selv vælge et filter for, hvad der skal ske med resten. Så hvis vi forstiller os en række header definitioner, så kan man altså starte med en grundlæggende indstilling for alle semantiske typer, som så efterfølgende kan overskrives af alle brugeren følgende skabelons- og grundfilter-indstillinger. Men et oplagt valg ville faktisk være simpelthen at udelukke alle entiteter, der ikke har en type som brugeren kender (og så må man bare holde øje med på anden vis, om der skulle tilføjes nogle andre semantiske typer (med tilhørende skabeloner), som brugeren kunne være interesseret i at begynde at gøre brug af også). Men! Til gengæld så er det så i høj grad værd at opfordre til / lægge op til, at brugerne også i høj grad benytter sig af undertyper! .\,.\,Hm, sådanne undertyper kan forresten benævnes i den semantiske definition ved, at man skriver ``$<$super type$>$.$<$subtype$>$=.\,. Nej, vent.\,. Nej, man skriver selvfølgelig bare ``subtype=$<$super type name (including dots if super type is itself a subtype)$>$.$<$subtype name$>$''. Og så er det altså mening, at brugere så også kan bruge disse semantiske undertyper i deres header, nemlig til så at overskrive valg for supertypen.\,:) (13:19)

.\,.\,Måske skal en kolonne også kende sine egne børne kolonner (og altså holde en liste over deres ID'er), således at en kolonne også herved kan få mulighed for at opdatere/overskrive en eksisterende barnekolonne. Ja, det lyder ret fornuftigt.\,:) 

Det er faktisk lige før, at jeg ikke behøver at sige så meget mere om, hvad jeg forestiller mig for en tidlig (brugerdrevet) implementation af interfacet (hvad jeg ellers skrev for lidt siden, at jeg ville vende tilbage til), for jeg har jo faktisk gennemgået det ret meget før, så det ville lidt bare blive en gentagelse af de pointer. Ja, så jeg tror altså, at jeg bare går videre til at snakke om ``QL'et'' nu her.\,. (13:24)

(13:49) Hm, jeg tænkte lige på, at jeg nok kan finde et bedre navn end Exisd med tiden, når jeg også har navngivet ``QL'et,'' og så kom jeg så til at tænke på, at der jo bliver to sprog i det, jeg har refereret til nu her som ``QL'et'' i de seneste paragrafer. Der bliver det faktiske QL for det første, og så bliver der interface-indstillings-sproget, som jo så nok nærmest kan siges at blive et JS-framework til at bygge interfaces, der så snakker direkte (tilsyneladende) med en semantisk database.\,. .\,.\,Og ja, i forhold til navnet på hjemmesiden, så kan det så bare.\,. ja, ligesom have navn efter dette framework.\,. Nå nej, vent, for der er så både et interface-indstillings-sprog, og så et ``sprog'' til at skriveskabelonerne i, som så bare er et JS-bibliotek. .\,.\,Ja, så tre sprog i virkeligheden, hvoraf det sidste så bare er et JS-bibliotek, og altså ikke er et egentligt selvstændigt sprog. Interface-indstillings-sproget kommer så til at kunne include JS-filer skrevet med omtalte bibliotek, og det kommer også til at have QL-sproget som et indre sprog i sig (eller hvad man nu teknisk kalder sådanne ``indre sprog,'' hvis ikke man bare kalder det det, det kan jeg ikke huske.\,.). (14:00)

%Jeg, og mine ben ikke mindst, bliver lige nødt til at gå en tur. Og når jeg vender tilbage, så kan jeg så lige skrive om, hvad jeg tænker omkring den helt grundlæggende syntaks i QL'et (altså det faktiske QL).. (14:07)

(15:18) Okay, jeg er lige kommet hjem fra en gåtur og har lige her sidst på gåturen fået nogle nye vigtige tanker! Jeg har desværre ikke så meget mere tid i dag, før jeg skal noget, og jeg kunne virkeligt godt tænke mig at nå at færdiggøre denne omgang noter i dag, så jeg må bare prøve ad at skynde mig og hamre derudaf.

Først en lille hurtig indskydning: Angående HTML--osv.-skabelonerne, bl.a.\ til at vise selve entiteterne i listerne, så skal disse altså selvfølgelig også selv kunne query'e databasen med QL'et (med AJAX) for at få de ressourcer, som skabelonen gerne vil indsætte i sig selv (inklusiv også eventuelt til diverse knapper og andre interface-funktionaliteter). Ville bare lige sikre mig, at dette var på plads.

Og en meget lille indskudt ting: Alle gemte strenge i den semantiske databasen skal være html-escaped, i hvert fald når de serveres af databasen, således at at hvis en bruger skal hente noget kode fra databasen, så skal brugeren/programmøren selv encode det tilbage til gyldig HTML(--CSS--JS), hvis han/hun vil dette. Det omvendte tilfælde ville være, hvis brugere altid skulle sanitere strenge fra databasen som en aktiv handling. Nej, i stedet skal det være de-saniteringen, der skal være den aktive handling fra programmørens side af. 

Nå, og nu videre til brugergrupper og ratingtyper. Det er jo her faktisk rigtigt fedt, at jeg er tilbage til et system, hvor alle brugere har adgang til al data i databasen (altså den offentlige (semantiske) af de to som hjemmesiden bruger (ikke den førnævnte private database)). For det gør også, at brugergrupper nu kan implementeres via bots, og altså implementeres i applikationslaget (så at sige)! Jeg skal lige tænke lidt mere over, hvordan dette kommer til at bruges i QL'et, så lad mig lige gå videre og nævne noget kort om ratingtyper først.

Det helt korte af det, jeg vil nævne om ratingtyper er, at disse også nu kan implementeres i ``applikationslaget!'' Brugerne kan altså også her i princippet selv implementere bots (eller menneskebrugere for den sags skyld, hvis de har tiden --- og hvis brugergruppen måske ikke er så stor (ift.\ hvor mange menneskebrugere har ansvaret for den).\,. Hov, vent!\,x) Nu snakker jeg jo om ratingtyper, ikke om ``brugergrupper,'' så never mind: for ratingtyper vil det selvfølgelig altid bare være bots, der udfører opgaven), der læser ratingdata fra databasen og så beregner nogle parametre for hvert relevant udsagn ud fra disse grundlæggende rating, hvorefter botten så kan tilføje sin egen type rating, ikke af det samme udsagn, men af et udsagn, der relaterer sig til udsagnet (og altså som har udsagnet som objekt (.\,.\,hov, det har jeg forresten også glemt at snakke om!\,.\.)), og som så indeholder information i sin ratingværdi om, en given descriptor-parameter omkring brugernes rating-fordeling. 

Okay, lad mig så lige tænke lidt videre over disse to ting, samt hvordan det kommer til at indgå i QL'et --- og lad mig prøve at tænke lidt hurtigt.\,.\,!\,;) (15:40)

.\,.\,Nå ja, jeg skal jo lige i hvert fald nævne nogle nye ting omkring QL-headeren, nemlig for det første, at de semantiske typer og undertyper i første omgang i headeren lige selv skal defineres, nærmere bestemt ved at man altså definerer, hvordan man get'er dem fra databasen i første omgang. Selvfølgelig kan man så ikke bruge denne information i de query-statements (eller konstante definitioner), der skal definere dette, så jeg skal lige sikre mig, at det ikke kommer til at blive cyklisk, men at type-gettingen kan defineres på en fornuftig måde til at starte med (muligvis med sit eget indledende sprog, hvem ved.\,.). Ok, og så tror jeg så også, at det bliver vigtigt at brugeren i headeren også får defineret en særlig `brugerentitets'-type, som brugeren nok kommer til at gøre meget brug af (fordi den type så skal bruges i alle efterfølgende queries, når `brugergruppen' (man spørger i query'en) skal defineres for query'en). Hm, det kan da forresten være, hvis nu jeg ikke kan finde på en god måde at fjerne det cykliske i det, at man så i stedet bare bør sige, at typer og undertyper defineres på en helt fast måde i entitetsdefinitionerne (som altid kan parses eksakt af databasen/serveren), og at alle brugere så \emph{skal} holde sig til den konvention (medmindre de vil risikere at blive totalt ned-ratet af alle de gamle brugere). Ja, så den udvej er der også altid (og i så fald kan det så også være, at man vil vælge at separere type- og undertype-definitionerne for sig, og så ændre den gamle `semantiske entitetsdefinition' til ikke at behøve at inkludere typen og eventuelle undertyper af entiteten). Så det er altså altid en mulighed.\,. Ok. .\,.\,Nå ja, angående typen `brugerentitet' (og her snakker vi altså den ``semantiske type'').\,. Hm.\,. %(15:54)

.\,.\,Hm, jeg har desværre ikke så meget tid tilbage.\,. (15:55)

.\,.\,Hm, men det er ikke bare sådan, at man nu, fordi alt det med ``brugergrupper'' og rating-descriptorer bliver implementeret i applikationslaget, så bare kan nøjes med et helt simpelt QL, altså et hvor man for hver query statement (som så også kan bruges til at definere variable, som man kan bruge i efterfølgende query statements) bare basalt set behøver at pege på et prædikat-udsang.\,. som altså rettere er et udsagn på formen this.$<$Predicate$>$, this.$<$Relation$>$.$<$Entity$>$ eller $<$Entity$>$.$<$Relation$>$.this, hvor `this'-keyword'et altså står i stedet for de entiteter, man gerne vil query'e.\,? Hm.\,. .\,.\,Nå, jeg har ikke rigtigt mere tid, så det må jeg lige tænke videre over på vejen (og måske tage nogle noter på min telefon, eventuelt). Der var vist dog også lige en anden ting, som jeg eget gerne lige ville nå at nævne.\,.(?) (16:04)

.\,.\,Nå nej, det skal jo rettere være noget i retning af: ``this . $<$Predicate$>$ ?, this . $<$Relation$>$ . $<$Entity$>$ ?'', ``$<$Entity$>$ . $<$Relation$>$ . this ?'', this . $<$Attribute$>$ == $<$Entity$>$ ?'', ``$<$Entity$>$ . $<$Attribute$>$ == this ?'' (hvor whitespaces er ligemeget).\,. 

.\,.\,Nå jo, der var en ting om, hvordan man eventuelt kan benytte de der intervalbredder for de almindelige ratings, men det må jeg skrive om i morgen (og måske på telefonen på vejen).\,. (16:15) .\,.\,Men helt kort sagt handler det om, at man starter fra de mindste intervalbredder af og så ligger hver rating oven i alle dens eventuelle indre ratings, hvis der er nogen, fordelt ligeligt, hvis vi altså snakker stepfunktioner, og så forstætter man så bare denne proces for alle rating én ad gangen med større og større intervalbredder. Til sidst ligger man så det hele over i et histogram, og så har man en god, sigende rating-fordeling, som man så videre kan bruge til at udtrække descriptors fra. (16:18)

%Fra toget på vej til byen (teater): 
	%"(10.02.23, 17:15) Nu hvor hele den semantiske database er åben for læsning, så kunne et simpelt QL bare være en undermængde af SQL.. ...Tja, nej, lad mig lave et lille QL-sprog, det er beregnet til det. I øvrigt så skal man jo uanset hvad have mindst én bruger med i syntaksen. Så hvis vi tager det, jeg skrev hjemme for lidt tid siden, så kan der være en brugervægtning-expression lige efter spørgsmålstegnet. Og dette kan så bare være et lineært aritmetisk udtryk i form af en parentes med konstanter ganget med variable, som repræsenterer enkelte brugere hver især. Men "en enkelt bruger" kan så til gengæld nu repræsentere en hel brugergruppe (nemlig ved at brugeren så er en bot, der varetager brugergruppen --- ved at summe ratings sammen).
	%
	%Og i forhold til at sammensætte ratings til et samlet filter, så kan QL'et også bare bruge simple aritmetisk udtryk til at opnå dette."
%

(11.02.23, 9:03) Jeg tænkte i går i toget, at man jo nu i princippet også bare kunne gøre QL'et til en undermængde af SQL, nu hvor databasen alligevel er helt open, men nej. Implementationen af den semantiske database skal være skjult, så derfor skal den semantiske database også have sin egen form for QL. Nu her i sengen i tidligere i morges kom jeg i øvrigt til at tænke på navne, og kom på at SEARQL måske kunne være et muligt navn til QL'et. (Jeg tænkte så, at det bliver lidt problematisk, hvis man skal finde på et filefternavn til det, men nej, her kan man bare skrive .srql eller .srq.\,.) .\,.\,Nå ja, og SEAR står altså her for `semantic entity and ratings'.\,. 

Nu har jeg så også tænkt lidt videre over, hvad jeg skulle gøre med de der ``brugergrupper,'' og her er jeg så kommet frem til to ting. Det ene er, at man jo nemt kan gette, om en entitet er en brugerentitet, for man kan jo i databasen kan jo bare slå op om der findes ratings fra den bruger.\,. ja, og databasen skal selvfølgelig også selv kende alle brugere, så det kan forresten godt være, at alle brugere bare \emph{skal} have sådan et unikt (long) bruger-ID. Ja. Nå, og den anden, virkeligt gode ting (som jeg også havde lidt i tankerne i går, men jeg kom lidt fra det igen, fordi der var så meget), er, at man skal kunne lave brugergrupper ud fra prædikat-expression kald (med tilhørende indledende bruger / brugergruppe, som enten er ansvarlig, eller som man bare bruger til, at definere den nye brugergruppe). Lad mig forresten nævne, at jeg tænker at et brugergruppe-udtryk altid skal komme efter spørgsmålstegnet, i den cirka-syntaks, jeg skrev i går. Dette kan så være en brugerentitet --- og altså gerne entitets-ID'et frem for bruger-ID'et (sidstnævnte kan bare være synligt i den semantiske definition af entiteten), men det kan også være et andet prædikat--brugergruppe-expression (gerne holdt i en variabel, dog). Der skal i øvrigt også gerne være et all keyword, som repræsenterer brugergruppen af alle brugere, ikke at man kommer til at bruge det så meget, og ikke fordi man ikke kan implementere det på anden vis, men jeg synes på en eller anden måde (måske), at det er passende alligevel at have.\,. %(9:30)
Og ja, jeg skal også juske at sige, at brugergruppe-udtryk i øvrigt også kan være en linearkombination af tidligere definerede brugergrupper. Så sammenlagt kan man altså definere nye brugergrupper aritmetisk ud fra gamle, og man kan også danne nye brugergrupper ud fra gamle ved at udspørge de gamle om en vis semantisk rating (med et vilkårligt prædikat) af alle brugere (og hvor ikke-ratede brugere i den forbindelse så bare får vægten 0 i brugergruppen). .\,.\,Og lad mig nævne, at det forresten ikke gør noget, hvis brugerne bruger et prædikat--brugergruppe-udtryk, der også giver ratings til ikke brugere, for der skal altid bare være et (grund-)grundfilter, der gør at alle ikke-brugerentiteter altid bliver sorteret fra automatisk for prædikat--brugergruppe-udtryk, der indgår i et brugergruppe-udtryk. (9:37)


(13.01.23, 10:01) Okay, jeg har en hel masse flere tilføjelser nu. Jeg føler virkeligt, at jeg er ved at have godt overordnet styr på det/de grundlæggende lag i systemet nu. .\,.\,Hm, hvor skal jeg starte.\,. .\,.\,Hm, godt spørgsmål, lad mig lige prøve at gå igennem det hele i tankerne en gang og så vende tilbage.\,. 

\ldots Hm, nu kom jeg forresten lige på et nyt navn: UDA (udtales you-dee-ay) for User-Driven Application, og så kan jeg mere specifikt kalde min en SUDA (es-you-dee-ay or suda (perhaps with `oo' sound)), nemlig en Semantic User-Driven Application. (10:48) %..Hm, jeg næsten mærke, at det bliver det..:D..

.\,.\,Hm, hvis det ligger godt i munden, kunne man så næsten kalde min applikation for Asuda.\,. (A for a (som i: ``a semantic user-driven application).\,.) (10:55) .\,.\,Nej, for det navn clasher med, hvis man skal sige ``a SUDA'' i en sætning.\,. hm, \emph{hvis} man altså ikke siger es-you-dee-ay da i stedet.\,. *(hvad man nok vil.\,.) .\,.\,Hm, jeg har også for nylig tænkt på SemNet *(som i: Semantic Network) som et navn til min web applikation, og det kunne jo egentligt også være en mulighed. (Og SemNet kan så bare siges at være en SUDA.\,.)

.\,.\,Nå, men jeg skal videre i teksten.\,. 

Okay, lad mig starte med, at brugerrating-entiteter i databasen også skal være `udsagn,' nemlig hvor man så specifikt tager et andet `udsagn' og bruger som relations-entitet i tripletten. Eller rettere, for nu vil jeg så også have, at man også skal kunne fortolke entiteter som funktioner/constuctors, så faktisk kan man så i første omgang tage en funktion på udsagnet, der går det til en relation, og specifikt altså rate-bar relation, nemlig fordi serveren så kan gemme brugerratings ved at denne udsagn ud fra den relation (med bruger-ID'et som første input og ratingværdien som det andet input). 
Det at brugerratings nu også er udsagns-entiteter gør, at brugerne også kan bruge semantisk logik omkring dem. For eksempel kan de således query'e databasen for, hvilke brugere har ratet et vist udsagn over eller under en vis værdi, hvilket er meget brugbart --- og rart at denne mulighed kommer automatisk nu, fordi man jo alligevel skulle kunne lave tilsvarende queries for vilkårlige udsagn. .\,.\,Tja, eller der bliver faktisk en lille forskel, for ``brugergruppen'' man spørger for at udtrække en hvis brugerrating vil jo altid bare være underforstået (nemlig en underforstået grundlæggende bruger/bot i databasen.\,.).\,. .\,.\,Hm.\,. 
.\,.\,Ja, det kommer til at svare til, at der bare er en automatisk grundlæggende bruger, der forbindes med queries til entiteter af typen ratingentiteter (og mere om sådanne typer senere i dag), og at denne bruger bare automatisk siger 1 (fuld rating) til alle disse udsagn, således at gyldigheden af dem bare afhænger af, om de eksisterer i databasen.\,. Hm, hvilket vil sige, at man egentligt også bare kunne sørge for, at det er omtalte bruger/bot, der bare bestemmer typen `rating(entitet)'.\,. .\,.\,Ja, og dette kan så bare implementeres ved at man gør `rating' til en fundamental type, der bestemmes automatisk af database(servere)n selv. For jeg vil nemlig alligevel gerne have det sådan alligevel, og jeg vil i øvrigt også gerne have at typen `bruger' på tilsvarende vis også skal være sådan en fundamental type. (11:38) 

\ldots Hm, men skal alle uploads ikke have en bruger på sig, så kunne man ikke også bare gøre det.\,. ja, på en lidt anden måde, lad mig lige se.\,. 

\ldots (12:25) Hm, det er ligefør, at alle rating-aggregater bare skal implementeres via ``bot-brugere'' i princippet (og databaseserveren har så bare nogle grundlæggende ``bots'' og kan også oprette flere, hvis der er nok efterspørgsel efter det).\,.(?\,.\,.) 
.\,.\,Og `brugergrupper' kan nemlig så også i princippet implementeres via bots, nemlig som databaseserveren/serversystemet/hjemmesiden så også bare eventuelt kan påtage sig at administrere (ud fra en fast protokol, ligesom), hvis der er nok stemning (som i: nok stemmer) for det.\,. 

For ja, noget af det seneste, jeg kom frem til, før jeg satte mig for at skrive i dag, var nemlig, at brugergrupper altid skal oprettes som entiteter i databasen, og godkendes, før de kan tages i brug. Og derfor kan dette jo også sagtens implementeres ved, at databasen så godkender en brugergruppe ved at oprette en bot til at oprette og vedligeholde stemmer samlet fra denne brugergruppe.\,. (12:37) .\,.\,(Brugere skal dog stadig kunne lave linearkombinationer af brugergrupper i queries, men de kan så ikke nødvendigvis --- ikke i første version af QL'et --- indsætte nye, custom-made brugergrupper her i disse udtryk (ved at indsætte et prædikat-udtryk med this-typen `bruger').)

.\,.\,Jeg har også en masse andet, jeg skal have skrevet om, særligt også tilføjelser omkring ADA-delen af det (og om hvordan bruger loader scripts og XML ved applikationens opstart, og ikke mindst hvordan XML-datastrukturer kan opdateres for hver bruger --- og om at bruge difs/deltas!), men lad mig lige gå en tur (i det her ultrafine vejr, som det er for tiden) og lige prøve at summe det her grundlæggende omkring databasen mere på plads.\,. (12:55)


(16:20) Okay, efter gåtur og efter at have tænkt videre efterfølgende så tror jeg endelig, at jeg er ved at have typesystemet (et lidt nyt et) og implementationen nogenlunde på plads. Lad os se. Vi har for det førte nogle datatyper. Jeg mener nu, at der skal gælde, at alle datatyper af en fast længde mindre eller lig long (8 byte) skal forekomme direkte i tabellen. Så når man vil referere til en dataentitet, så gør man det altså ved simpelthen at angive typen først, og hvis det er an datatype mindre eller lig en long, så skriver man den så direkte i den efterfølgende kolonne (hvis man skulle opstille det i en fornuftig tabel). Og for datatyper/typer såsom `string,' `blob' og `semantic term,' så giver man så en reference i stedet, som så også (indtil man på et eventuelt tidspunkt i fremtiden bliver nødt til at tilføje flere bytes) er en long. Men ift.\ implementationen i den relationelle database, så kan man altså stadig se på datatypen, i hvilken relation/tabel, man skal slå referencen/ID'et op i. Så entiteter med forskellige typer kan altså godt have kolliderende ID'er (men self.\ ikke, når de har samme type). Nå, udover datatyperne er der også.\,. Hm, nu kaldte jeg det lige `semantic term,' men i virkeligheden bør det hellere hede `atomic (semantic) term' og `compound (semantic) term'.\,. .\,.\,Hm nej, lad mig kalde det et `semantic atomic term' og bare et `compound term,' hvilket så er en overtype, hvorimod `semantic atomic term' er en helt specifik type. .\,.\,Hm, nej, det dur faktisk ikke; lad mig finde et andet navn for `semantic atomic term'.\,. .\,.\,Hm, hvad med `interpreted term,' hvor man måske så kan sige `iterm'.\,. nej, det ser mærkeligt ud.\,. .\,.\,Hm, lad mig egentligt også hellere kalde det et `described term' i stedet.\,. .\,.\,Og jeg behøver ikke forkortelse som sådan (DescribedTerm virker fint). Ok. Og så har vi CompoundTerm's, som har undertyperne MonadicTerm of Term $\times$ DescribedTerm og DyadicTerm of  Term $\times$ DescribedTerm $\times$ Term. Disse compound terms vil typisk repræsentere udsagn, men de kan dog også repræsentere funktionelle udtryk. Nå ja, og vi har i øvrigt også typen User, hvilket bare holdet et bruger-ID (long) --- ligesom at DescribedTerm i øvrigt holder en string (hvilket ses direkte som en string i den semantiske database, men som så dog er implementeret som en string-reference, nemlig til et string-ID i en String-relation/-tabel i den undeliggende relationelle database, hvor anden kolonne i den tabel så rent faktisk er en VARCHAR(n) (og grunden til at det skal være sådan, er i øvrigt altså for, at jeg kan have 8-byte data stående overalt i de overordnede relationer/tabeller)). Og sidst (mener jeg nok) men ikke mindst har vi så typen, SemanticInput, hvilket altså er rating-typen (bare hvor jeg har generaliseret navnet an anelse), som har formen, User $\times$ CompoundTerm $\times$ Term. Her er det sidste Term selvfølgelig rating-værdien/-dataen, og bemærk, at fordi alle typer, hvor det kan lade sig gøre at putte dataet direkte ind (nemlig hvis de er mindre eller lig en long), får gjort dette, så vil talværdierne altså stå direkte i den relationel-database-tabel/-relation, der implementerer `semantic inputs.' Fordi vi sammenlagt har så få typer, som vi har (nemlig en håndfuld datatyper og så en fåtal af ikke-datatyper), så kan flaget i databasetabellerne (som både forekommer i den semantiske og i implementationen i den relationelle database), der bestemmer datatypen (når dette er nødvendigt, hvad det eksempelvis ikke er for User i SemanticInput; her kan man bare have en long uden at have noget flag foran), bare være en char. (17:16)

Det næste man så egentligt bør snakke om, efter at man har snakket om den semantiske database, det er jo oplagt QL'et. Men fordi jeg har så mange andre små ting, jeg også skal sige, så lad mig lige prøve at få klaret en del af de ting først.\,. 

.\,.\,Nå ja, jeg kan jo passende starte med at snakke om difs/deltas, for dette skal jo også indgå som en type i den semantiske database!\,.\,. (17:19) .\,.\,Hm, dette bliver så en rekursiv type.\,. Hvad skal vi kalde den.\,.\,? .\,.\,Hm, man skal jo næsten også gerne kunne tage udsnit fra flere eksisterende strenge/tekster på én gang, så hvad skal vi sige der.\,.\,? .\,.\,Oh well, det kan jeg vende tilbage til. Pointen er bare, at der også skal være en DeltaString- eller CompoundString- eller EditedString-, eller hvad-vi-nu-skal-kalde-den-type, som altså danner en ny string ud fra nogle gamle strenge samt eventuelt nogle nye tilføjelser/indsættelser. 

(17:27) Lad mig så snakke om nogle ting mere oppe lige under applikationslaget.\,. For det første skal jeg have nævnt, at der gerne skal være en privat/lukket database også, som gør mere end bare det der med at tælle brugerprofiler pr.\ brugerkonto. Men det skal dog være valgfrit, om man vil gøre brug af denne private database, eller om man vil gøre noget andet, hvilket eventuelt godt kan være bare at sende alle inputs direkte til den offentlige database, hvis man vil det. I øvrigt skal man stadig bare ``logge på'' den offentlige database ved.\,. ja, eller rettere, man logger ikke på, men man sender bare sine inputs krypteret med den offentlige nøgle. Det jeg vist på et tidspunkt sagde med, at den offentlige krypteringsnøgle bare \emph{bliver} bruger-ID'et gælder dog ikke; databasen giver hver brugerprofil en long, der udgør bruger-ID'et, hvilket så bliver omdrejningspunkt for semantikken. 

Men brugerne skal altså også have mulighed for at uploade inputs til en privat database. Her kan de så bl.a.\ uploade og redigere data omkring indstillinger i deres eget personlige interface (altså den jeg kalder en UDA, fordi brugerne i princippet kan ændre den stort set vilkårligt). Om brugeren gemmer til denne private database, til den offentlige eller en blanding, så vil brugeren uanset hvad skulle fortælle databasen (selvom de jo godt kan starte et populært sted og så bare blive der), hvilke nogle scripts og HTML m.m., de gerne vil have loadet i deres applikation under opstarten. Alle scripts kan så få eventuelt inputdata via XML, der også hentes fra databasen under opstart. Her skal brugerne så sørge for, at alle scripts, der skal/kan bruge ekstern XML-data, sørger for at erklære og tjekke et navn på en fast måde (som jeg skal have fundet på), hvor det sikres, at der altså vil returneres en fejl, hvis to loadede scripts bruger det samme navn. Hvis scriptsne så loader uden fejl, så ``ved'' hvert script så, at det er frit til at tilgå og muligvis ændre i (hvis brugeren, der loader scriptet har tilladt dette) et specifikt XML-element (som så har en attribut a la dataIdentifier=$<$unique name$>$). Og scriptet, hvis det har fået lov, må så gerne ``flushe'' sit XML-objekt tilbage til databasen (som regel den private, men det bestemmer brugeren, der loader scriptet), således at brugeren kan loade sine ændringer siden sidst på ny, når denne starter webapplikationen op en anden gang i fremtiden. (17:45)

Angående det jeg på et tidspunkt skrev ovenfor omkring at undgå de cykliske i at loade lister, som så loader samme type elementer, så er svaret her selvfølgelig bare, at man først definerer sit listekolonne-script/-HTML, og kan så bagefter tilføje ressourcetyper til dette script, samt tilhørende visnings-script/-HTML til hver af disse typer. 

(17:48) I øvrigt, nu hvor vi er næsten helt ude i applikationslaget, så tænker jeg at UDA'en kan starte med at have disse ting: listevisningskolonner, som altså bruges til at vise en liste over ressourcer (med tilhørende filtre), som brugeren har spurgt efter (på den ene eller den anden måde); ratingkolonner til når man har selekteret en ressource og bare lige vil have en hurtig oversigt over gode mulige ratings/``rating-tags,'' man så kan benytte; ressourcevisningskolonner, som er ligesom ressourcesider, bare i miniformat; ressourcesider, hvilket så er, når man virkeligt har klikket helt ind på en ressource (vist i stort format for sig selv; ikke klemt inde mellem andre kolonner); terminalkolonner, hvor den avancerede bruger kan lege med at udforme queries i QL'et (og med variable, som er defineret i et tilhørende XML-dataobjekt); samt også; sidst men ikke mindst, kontrolkolonner, som er ligesom terminal kolonner men bare sat op så brugeren skal trykke på knapper og gøre ved som de fleste brugere er vant til for at opnå de samme ting, som de avancerede brugere kan opnå i terminalen (men måske altså bare lidt mindre end dette (men på sigt dog ikke foruden noget, som den almindelige bruger vil savne)). (18:00) .\,.\,Nå ja, og så skal der også være en kolonne eller side, der handler om at indstille start-op-indstillingerne for applikationen (og loade scripts/HTML/CSS og XML-data, samt definere typer og grundfiltre, hvilket jeg kommer til senere). 

(18:59) Jeg tror faktisk, jeg vil inkludere listetyper! Så skal der være 12 forskellige listetyper, nemlig med fra 0 til 11 elementer i sig (så den første er altså den tomme mængde/liste). Og så vil jeg kalde det MonadicStatement og DyadicStatement i stedet, og så ellers bare have et FunctionalTerm of DescribedTerm $\times$ Term, hvor.\,. Nå nej, og jeg vil så heller ikke kun have DescribedTerm som mulige prædikater, relationer eller funktioner, men disse kan også alle være af FunctionalTerm-typen i stedet. Så FunctionalTerm of (DescripedTerm  $|$ FunctionalTerm) $\times$ Term (så typen er altså rekursiv). Og Term her kan så særligt også være en listetype, hvilket netop gør at alle funktioner bare kan være umiddelbart unære. Hvis man gerne vil lave en funktion, som skal kunne gives lister længere end elleve elementer, så kan man sagtens det. Man kan selvfølgelig for det første give den lister af lister i stedet (eller af funktioner taget på lister), men man kan også bare give den.\,. Ja, eller det er jo så også at give den lister af lister i princippet, men hvis man altså meget gerne vil have, at alle elementer opfattes som ligestående, side om side med hinanden, så kan benytte en konvention om at implementere dette ved specifikt at lade det 11.\ input have typen af en ny liste, inklusiv den tomme liste, hvis det samlede antal elementer er rundt, og man er ved den sidste af alle tier-grupperne. .\,.\,Ok, og en sidegevindst er i øvrigt, at nu kan man lade databasen tjekke, at der enten er tale om et MonadicStatement eller et DyadicStatement, hvilket nok vil være godt til at guide brugere til aldrig at rate andet end termer, der semantisk set bør fortolkes som et udsagn (og altså til ikke at begynde at rate ikke-statement-termer direkte med et implicit prædikat; det vil vi helst undgå). (19:17)

.\,.\,Hm, på den anden side vil dette jo netop friste brugerne til at bruge direkte get-funktioner, i stedet for at bruge mere abstrakte get-funktioner, der kan tage højde (i princippet) for efterfølgende rettelser.\,. Så ja, lad mig lige tænke over, hvad der er bedst, for på den ene side gør man det jo nemmere for de første brugere, ved at indføre lister (med automatiske getElement()-funktioner), men på den anden side, så kan brugerne så også blive forvente med disse simple og automatiske funktioner.\,. (Så ja, det må jeg lige tænke over.\,.) 

.\,.\,Ah, men på den anden side, så vil det jo også være ret smart, hvis applikationen kan hente de uredigerede ting først og bare tjekke for de værste faresignaler, og når der så bliver tid, eller når brugeren klikker sig videre ind på ressourcen, så kan applikationen så lave mere grundige gets. Nice!\,:) Fedt nok, så indfører jeg nok de lister der. (19:27)


(14.02.23, 8:54) Hm, jeg kunne også indføre lister uden at indføre funktioner.\,. .\,.\,Hm, det ville måske ikke være en dum idé.\,. Og man kan endda så sige, at jamen funktioner kan jo også bare udelades i første version af systemet (men hvor man bare holder dem klar til at blive indført, så snart der bliver behov for dem, hvis der gør det).\,. .\,.\,Yes, og måske bliver der faktisk aldrig behov for at indføre funktioner. Og det giver mig så det bedste af begge verdner, for nu bliver de tidlige programmører (hvilket jo nok i høj grad bliver mig selv) tvunget til at get'e (gette) attributter omkring et objekt via semantiske queries, hvilket gør implementationen meget mere åben overfor efterfølgende rettelser og ikke mindst også for, at brugere kan få mulighed for at indstille metoderne til deres egne behov. Men samtidigt kan man så bare bede om en enkelt liste som programmør, hvilket.\,. ja, det gør tingene en anelse nemmere, men ikke mindst gør det det også nemmere, hvis brugeren skal indstille get-metoden/erne for et objekt, for så skal de kun ændre indstillingerne for én metode pr.\ objekt (altså fordi der så kun behøver at være én get-metode, som get'er hele listen af relevant data for et objekt). .\,.\,Ja, det er altså virkeligt nice på den måde. Så jeg indfører listetyperne som beskrevet i går aftes, men jeg fjerner så funktionstypen igen (og beholder typenavnene MonadicStatement og DyadicStatement), om ikke andet så bare indtil der alligevel viser sig (hypotetisk) at blive efterspørgsel efter den af en eller anden grund. :) (9:09)

(11:45) Okay, jeg tror, jeg ved, hvordan det grundlæggende QL skal implementeres. Jeg er faktisk gået over til nu, at det bare skal være en slags undermængde af SQL (når det kommer til selects men ikke til inserts), og at den implementation af den semantiske database, jeg har i tankerne (og har skrevet om her i går), faktisk bare skal blotlægges, sådan at denne implementation faktisk bare \emph{bliver} den semantiske database så at sige. Og det særegnede QL (\emph{hvis} man indfører et) skal så bare indføres/bygges i applikationslaget. 

Angående databasen, så skal jeg bare bruge CHAR til typeflaget, således at det bare kan sendes som en ASCII-char over http. Og det jeg så lige har tænkt over, er, hvordan rating-værdierne skal implementeres, og nu har jeg så fundet ud af, at de simpelthen bare skal implementeres som en long, eller rettere en BIGINT. Denne long/BIGINT bør så.\,. hov, eller rettere: Ratingværdien kan være af en arbitrær type (og kommer altså derfor med et typeflag forinden værdien), men den klare standard skal dog være at bruge BIGINT/long. Denne long skal så fortolkes som gennemsnittes for brugerens rating (hvor man selvfølgelig dividerer med  9223372036854775808). Og det smarte kommer så nu: Fordi de sidste cifre jo vil være semantisk fuldstændigt ubetydelige/underordnede (startende allerede fra den 4. --- måske endda fra og med den 4.\ eller endda den 3. --- byte), så kan brugerne altså frit tillade sig at bruge disse (sidste) cifre til at indkode anden semantik i ratingen. En god mulighed kunne jo således f.eks.\ være, at lade de første 4 bytes udgøre ratingmidtpunktet, og lade de efterfølgende 1--4 (hvad der lige giver bedst mening, for måske er selv én byte rigeligt til dette) bytes kode for intervalbredden af ratingen (i henhold til det, jeg har snakket om ovenfor). Bemærk, at selv hvis man nu kun bruger 2 bytes til at kode for midtpunktet, så kan gennemsnittet af alle (eller en gruppe af) sådanne ratings stadig godt fortolkes med en højere præcision. (12:08)

(12:25) Jeg tænkte lige lidt over, om man ikke også skulle have kilde-bruger og timestamp med for hver ikke-SemanticInput-entitet, men nu kom jeg så lige til at tænke på, at man som bruger alt andet end lige altid gerne vil up-rate et nyt upload i en eller anden forstand, typisk ift.\ et eller andet prædikat, som kunne have et passende navn a la `isUseful$<$Type$>$()' --- eller være en relation a la `isUsefulEntityOfType(type)'.\,. .\,.\,Og fordi man alligevel forventer at et hvert upload/insert kommer med sådan en rating lige bagefter, så kan man jo derfor også bare gøre dette til en konvention, nemlig at brugerne altid up-rater.\,. lad os sige `isUsefulEntityOfType(type)'.\,. eller rettere `$<$Type$>$.UsefulEntity==myNewEntity,' hvis man gerne vil formulere det på mere objekt-orienteret vis (hvad jeg jo synes, man bør), (at brugerne altid up-rater dette) med det samme (og altså i selvsamme insert-kommando), når de uploader en entitet. .\,.\,Ja, man kunne endda ligefrem kræve dette fra serverens side for alle nye uploads. 

.\,.\,Hm, eller skal man bare tilføje bruger og timestamps på hver entitet.\,.\, Tja, måske ikke, men lad mig lige lade spørgsmålet stå en anelse åbent.\,. .\,.\,Angående insert-kommandoer, så er det klart, at brugeren bare skal uplaode indholdet, og så er det serveren/databasen selv der sætter et passende ID for uploadet, samt en bruger og et timestamp, om ikke andet hvis vi altså snakker et SemanticInput (hvilket selvfølgelig skal have bruger og timestamp på sig).\,. (12:42)

(13:31) Okay, nu er jeg vist næsten klar til at skrive de sidste ting, jeg mangler at komme ind på, hvorefter jeg så nok så småt kan gå i gang med programmeringen.

Hvis vi ser på, hvad der så skal ske når brugeren logger på hjemmesiden.\,. Hm, eller lad mig starte med at nævne, at der på hjemmesiden, inden man er logget ind, gerne må være lidt about-information, og også gerne en liste af sponsorer, hvilket jeg tror bliver ret vigtigt for hjemmesidens økonomi. Ok. Når man så logger ind, så er noget af det første, der sker, efter at man/browseren/applikationen lige har fået bruger-ID'et i hånden (efter også at have fået oprettet og autoriseret forbindelsen) samt nogle helt grundlæggende andre variable, at applikationen efterspørger en række af start scripts/HTML/XML, der skal loades. Dette kan ske ved, at databasen spørges efter en liste over script (strings), som brugeren har gemt en positiv (skarpt) rating for. Alle disse script/HTML-strings hentes så og loades i rækkefølge efter pågældende rating-værdi, fra lavest (tættets på 0) til højest. Hvert script kan så potentielt set query'e databasen efter flere scripts / mere HTML/XML, eventuelt også på tilsvarende vis, og kan nemlig eventuelt vente lidt med at gøre dette, så den samlede side bedre kan loade sådan lidt ad gangen, hvis nu man har mange ting til at ske i sit samlede start-script. Og så er vi faktisk allerede stort set videre til applikationslaget, for jeg har allerede forklaret om, at hvert script så kan have sit eget XML-input (som kan loades separat fra databasen), og at der også skal være en funktion til at ``flushe'' og opdatere denne data. Nå ja, lad mig dog lige påpege, at databaseentiteterne der koder for brugerens egne indstillinger og præferencer, de kan eventuelt være uploadet til en privatdatabase, som man også har forbindelse til udover den offentlige. Brugeren behøver derfor ingenlunde at lade sine indstillinger være synlige for offentligheden, men kan dog godt vælge det (og på sigt vil dette faktisk nok blive ligeså sikkert i princippet i nogen tilfælde, fordi man så i stedet kan vælge at sørge for at gøre brugerprofilen umulig at sammenkoble med personen.\,.). 

Så ja, nu kommer vi så til applikationslaget, og her er mulighederne selvsagt åbne. Men jeg har dog nogle idéer til, hvor man kunne starte, både på mellemkort sigt og på helt kort sigt, for på den helt korte bane vil jeg nemlig bare implementere et rigtigt simpelt system, hvor brugerne primært bare opretter prædikater og kategorier, og så rater de ressourcer, som loades ind på siden med diverse ``rating-tags'' (og hvor de har nogle forskellige muligheder for at åbne nye kolonner ud fra en lille gruppe af forskellige typer entiteter (hvor vi her altså snakker brugerdefinerede typer)). Hov, og lad mig lige i den forbindelse nævne en kolonne-type, som jeg havde glemt ovenfor, og det er prædikat-kolloner, hvor man ser info om et givent prædikat.\,. hm, selvom dette dog også kunne hører ind under ressourcekolonnetypen.\,. Men ja, dette er jo det jeg skal i gang med at programmere, lige efter at jeg har fået back-end'en og applikationsopstarten på plads.

Angående idéerne til applikationsimplementationen på mellemkort sigt, så handler dette om.\,. .\,.\,ja, eller selvfølgelig vil der være nogle brugerflademæssige ting, som jeg ikke vil implementere i starten, men vil vente med til lidt længere sigt igen. Men hvis vi også ser bort fra dette emne, så er en virkeligt vigtig ting på den halvkorte bane at få implementeret en lille standard for, hvordan brugere kan indstille nogle af de grundlæggende ting omkring deres interface. I første omgang skal brugeren have godkendt nogle grundlæggende scripts, der skal køre i applikationens opstart. Men herefter skal brugeren også indstille nogle flere ting. Så selvom dette foregår i selve applikationslaget (hvor brugerne har total frihed i princippet), så kan vi altså stadig med fordel snakke om, at der skal ligge et nedre lag i dette applikationslag, hvor brugerne kan indstille helt grundlæggende ting omkring applikationen, og endnu mere specifikt omkring hvordan applikation må/skal interagere med databasen, og hvordan den skal tjekke og godkende det data, den får fra databasen.

Her forestiller jeg mig så, at man laver nogle små sprog/filformater til formålene, netop så så mange som muligt af brugerne kan sætte sig ind i disse formater og dermed også være i stand til at ændre dem direkte, uden at skulle lære at gennemskue XML først (hvilket jeg personligt heller ikke bryder mig om; man bliver helt skeløjet).\,. Så vi snakker faktisk en form for config-filer, hvis man kender det. Og i disse configscripts skal brugerne så kunne ændre indstillinger for forskellige ting, og her tænker jeg så særligt på følgende ting. Der skal være et config-script, der bestemmer, hvilke nogle domæner, som applikationen må hente URI'er fra. Eventuelt kunne det endda gøres sådan, at brugeren både bestemmer en RegEx for URL'en, samt bestemmer en salgs RegEx (muligvis binær) for dataen. Og måske kunne brugeren endda eventuelt få lov at vælge en transducer, der oversætter det godkendte (af den ``binære RegEx'' (altså en automaton, men brugeren skal jo kunne skrive den på en eller anden måde.\,.)) format til et nyt format, inden det kan indsættes i applikationens HTML.\,. .\,.\,Men ja, i starten skal dette selvfølgelig dog bare være et spørgsmål om at godkende URL'er, og på lidt længere sigt kan det så også måske handle om at parse og godkende de tilhørende URI'er. Det var den ene ting. (14:15)

En anden ting er at definere nogle brugerdefinerede typer for databasen. Dette bliver nok en ret grundlæggende ting, og altså noget som gøres tidligt i den samlede række start-scripts. Og til hver brugerdefineret type, så skal brugeren for det første kunne præcisere, hvordan applikationen skal verificere, at en entitet har den pågældende type, hvilket typisk vil handle om at spørge en brugergruppe om et specifikt prædikat (der så er taget på den givne entitet). 

Og her kan jeg så passende lige indskyde en paragraf om brugergrupperne. Vi er som sagt i applikationslaget, så dette implementeres bare her, men jeg forestiller mig, at der skal være en bestemt fast syntaks for at benævne en brugergruppe, hvilket altså i adgangspunket skal være en linearkombination af bruger-ID'er, nemlig altså hver med konstanter foran. Disse konstanter skal så tolkes som en vægtning af hver bruger --- som jo også kan være en bot, der implementerer en brugergruppe i databaselaget, når gennemsnittet udregnes. Så hvis bruger nr.\ 123 har stemt 0.1 til en rating, og bruger 456 har stemt 0.5 til en rating, og man bruger linearkombinationen, (3 * 123 + 1 * 456), så bliver resultatet for den givne rating altså et (vægtet) gennemsnit på $(0.3 + 0.5)/(3+1)=0.2$. Men dette er ikke det hele, for man kan så også have lov til at bruge et `inf'-keyword i stedet for en konstant (kun en enkelt dog), som giver en uendeligt vægting af brugeren, hvis brugeren altså har givet en rating. Lad os sige at bruger 123 har givet en rating på 0.1, bruger 124 har givet en rating på 0.2 og bruger 135 har ikke givet nogen rating. Så vil resultatet af (inf * 123 + 2 * 124 + 3 * 135) give resultatet, $0.1$ --- og (5 * 123 + 2 * 124 + 3 * 135) ville i øvrigt give resultatet, $(0.5 + 0.4)/(5+2)=0.128571428\ldots$ (he, jeg har ikke divideret i hovedet i lang, lang tid.\,.).\,. Ok, og i øvrigt kunne der også lige være et `me'-keyword til at benævne sig selv, og så kan man jo med fordel bruge `inf * me' i mange sammenhænge. Og sidst men ikke mindst kan man også sætte en konstant ind på brugerens plads, hvilket jo set i bakspejlet gør det lidt forvirrende, at jeg allerede har sat tal ind på brugernes pladser nu her til at repræsentere bruger-ID'er, men i praksis skal der altså i sidste ende ikke være tvivl om, hvornår et bruger-ID indsættes, og hvornår en tal-konstant indsættes. Og hvor en konstant indsættes, så skal det altså tolkes tilsvarende som, at en fiktiv bruger har ratet pågældende prædikat med lige det tal.\,. nå ja, dette tal vil jo altid være et kommatal (mellem -1 og 1), så selvfølgelig vil man nemt kunne vælge en syntaks, hvor man kan kende forskel (for der er en triviel løsning på dette). 

Angående det med at bruge en konstant fiktiv rating i brugergrupperne, så er det faktisk det jeg selv regner med at gøre i den første implementation af applikationen. Jeg regner således bare med at vise et ratinggennemsnit overalt, som dog lige er ændret ved at det har en vis konstant * 0.0 plusset på, så at sige. Så jeg regner altså med at bruge en brugergruppe a la `(1 * meanbot + 5 * 0.0)' (hvilket jo også bare kan skrives som `(meanbot + 5 * 0.0)') . Her er `meanbot' så et kaldenavn der referere til en grundlæggende bot, der rater alle statement ud fra samlede mængde (ikke-karantænede/-udsmidte) brugeres ratings (og som opdatere disse ratings løbende). 
I øvrigt er det værd at nævne, at jeg så forestiller mig, at denne ``meanbot'' så bare kan bruge de sidste (2--3) bytes i dens ratings til at indkode, hvor mange brugere (ikke-karantænede/-udsmidte), der samlet set har ratet udsagnet på det givne tidspunkt. (14:50)

%..Tager lige en kort.. hold da op, egentligt vildt at den allerede er blevet tre. Nå, men jeg tager altså nok lige en kort pause, inden jeg skriver resten..

(15:33) Okay, for så at vende tilbage til de brugerdefinerede typer, så skal brugerne også (i ``config-scriptet'') ikke mindst kunne sætte et grundfilter for hver type. Alle entiteter som de højereliggende applikationsscripts henter skal så i reglen filtreres med disse grundfiltre (der passer til den relevante type). Bemærk at dette så også i reglen (med mindre brugeren har specificeret noget andet (og har mulighed for at gøre dette)) gælder for alt tilhørende data, som applikationen get'er til en hvis entitet, da dette data jo også vil have en type. Og i tilfælde, hvor noget data ikke kan bestemmes til en af de brugerdefinerede typer, så kan brugeren også sætte et other-filter, som filtrerer alle entiteter, der ikke kan tildeles en type ud fra brugerens konfigurationer. 

Men på lidt længere sigt skal brugerne nok endda også gå ind og kunne bestemme specifikke.\,. Nå nej, nu snakkede jeg om et grundfilter, men brugeren skal så \emph{også} (på sigt) kunne ind og bestemme brugergrupperne for specifikke get-metoder. Lad os f.eks.\ sige, at brugeren klikker sig en på en video-ressource. Nu skal applikationen så hente data til videoen. Lad os så sige, at brugeren gerne vil have både undertekster og annotationer til videoen, hvilket applikationen jo så efterfølgende kan hente/``get'e'' til brugeren. Og her kan man så forestille sig, at brugeren gerne vil bruge én brugergruppe til at vælge, hvilke undertekster er mest passende for brugeren, men bruge en anden brugergruppe til at vurdere, hvilke annotationer er passende for videoen. Derfor skal brugeren altså gerne (på sigt) kunne config'e brugergruppen for hver enkle get-metode tilhørende en type. Dette er også derfor (og man kan også nævne mange andre eksempler, som dog har med det samme princip at gøre), at jeg gerne vil have, at man på sigt går væk fra, at gette al data til en ressource i én samlet liste (hvad man nok gerne vil gøre for nemhedens skyld i starten), og i stedet går over til implementere individuelle get-metoder til hver.\,. ``attribut'' til et objekt / en ressource, så at sige. Og så kan hver bruger nemlig selv config'e disse get-metoder yderligere, og specifikt altså gerne ved simpelthen bare at gå ind og ændre brugergruppen (i form af et linearkombination-udtryk som dem, jeg skrev lige før her ovenfor) for hver enkle get-metode. (15:48)

.\,.\,Hm, og var det det omkring dette nederste lad i applikationslaget (når vi lige ser bort fra QL'et.\,.), eller var der mere, jeg skullle sige i denne omgang.\,.\,? .\,.\,Jeg det må næsten være det.\,. Nice.\,:) Okay, jeg har så stadig nogle flere ting, jeg lige skal tænke lidt over. Nogle er ret små (dem skal jeg bare gå at summe lidt over sammenlagt), og så er der nogle lidt større ting, såsom bl.a.\ QL'et (som jo ikke bare skal være SQL, det er klart, selvom det i høj grad nu bare skal minde om, når det kommer til selects), som jo lige er en af de største todos sammen med at få styr på databasen helt præcis --- og også i øvrigt de der delta-(/remix-)strings! --- som jeg jo skal programmere som noget af det første. Men angående applikationslaget, så mangler jeg også at tænke lidt mere over, ikke de \emph{grundlæggende} filtre, men de efterfølgende filtre, som brugeren skal kunne indstille for applikationen. Jeg har noteret til mig selv, at jeg lige skal huske at nævne her, at brugerne gerne må kunne plotte deres filter-fordelingsfunktioner, når de har konstrueret nogle, men jeg skal jo nok lige tænke lidt mere over hele den del.\,. 

.\,.\,Hm, jeg kan lige nævne, at der gerne også må være et `all'-keyword til at konfigurere type-brugergrupper og -filtre (og get-brugergrupper), på samme måde som at der skulle være et `other'-keyword. Og så gælder konfigurationerne for ``all-typen'' så selvfølgelig bare for alle typer, hvor de for ``other-typen'' bare gælder for de entiteter, der ikke matcher nogen brugerdefineret type. 

Og en anden lille hurtig ting er, at databasen selvfølgelig gerne må slette entiteter igen, hvis de ikke længere rigtigt er i brug (og/eller er nedvurderet tilstrækkeligt af repræsentative udsnit af brugerne). Særligt må databasen jo gerne slette gamle ratings fra bots, hvis ingen bruger dem.\,. .\,.\,Tja, og det vil jo bare vise sig, hvordan det bedst giver mening.\,. Men hvis man sletter entiteter, så kan man bare frigøre pladsen og entitets-ID'et (for den pågældende entitetstype), således at nye uploads kan tildeles disse i stedet. 

Okay, jeg skal altså lige have tænkt lidt mere over de ikke-grundlæggende filtre (dem som brugerne frit kan vælge til og fra og udskifte i deres normale brug af applikationen), men ellers kan jeg altså så småt begynde at gå i gang med at programmere den grundlæggende del (startende med den semantiske database og det grundlæggende QL).\,:) Virkeligt nogle fede tilføjelser i denne omgang! (.\,.\,Altså her over de seneste dage, tænker jeg på.) Fedt at være nået hertil! :) (16:15)

(18:07) Jeg har fundet på nogle flere tilføjelser. Angående string-encodingen, så skal man jo selvfølgelig bare bruge den der htmlspecialcharacters()-funktion. Og det er så både det format, man sender til serveren og det format, man får af af serveren. Når man så skal loade scripts/HTML, så skal man så bare specielt i det tilfælde konvertere tilbage. (Og serveren tjekker selvfølgelig altid, at inputtede strings er af det format.)

Angående QL'et, så tror jeg faktisk, at det bare netop skal være en undermængde af SQL, simpelthen. Og så kan man altså implementere eventuelle mere specialbyggede QL-sprog i applikationslaget (UDA-laget). Så man sender altså sine select statements til serveren, som så parser dem med en automaton (en kompileret RegEx) og sender det videre til serveren, hvis det godkendes.

Når det så kommer til insert statements, så er der lige en anelse mere at sige. For det første vil jeg nok gerne trække det tilbage med, at det kun er ratings/semantic inputs, der får timestamp og bruger-ID. For jeg er kommet i tanke om, at nu hvor man (også) kan tilgå databasen rent SQL-style, så behøver man jo ikke at vurdere alle entiteters ``usefulness''.\,. Så ja, nu tænker jeg faktisk lidt bare, at bruger-ID og timestamp kommer med over alt. 

Det gør så faktisk, at insert-statementsne også bare kan være en undermængde af SQL, hvor serveren så skal tjekke at bruger-ID og timestamp kan godkendes. Og her har jeg så nemlig tænkt noget andet, og det er, at man jo så med fordel kunne gøre det sådan, at hvis timestampet er sat til en fremtidig tid (mere end bare nogle sekunder), så kan serveren vælge at tjekke, om der er plads i en buffer og så putte den midlertidigt over i denne, indtil timestampet bliver aktuelt, hvorefter serveren så kan uploade entiteten til den offentlige database. Og denne buffer skal altså være i en privat database. Dette giver en simpel måde, hvor brugere kan obfuskere upload-tidspunktet, hvilket nemlig kan være godt for at forøge anonymitet. Og så tænkte jeg så også, at en måde at implementere, at entiteter kun bliver uploadet til en privat database så bare kunne være ved at sætte en nul-timestamp (eller bare en der ligger før nutiden). For ellers skal man jo vedlægge et flag, men når man alligevel har pladsen til det.\,. tje, medmindre at der kan være en fordel for brugeren i at holde styr på sine egne private timestamps (for sine privat-database-uploads).\,.(?) (18:24) .\,.\,Oh well, ellers må man jo bare sende et public/private-flag (måske i form af `u' og `r' henholdsvis.\,.) med til serveren sammen med insert-statementet, som så altså bare i sig selv kan være fra en undermængde af SQL.\,. Hm, og hvad med selects, skal kan man også have behov for.\,. ja.\,. Her kan man også have behov for at sige ``søg kun i den offentlige database'' --- og måske endda også selects, skal kan man også have behov for.\,. ja.\,. Her kan man også have behov for at sige ``søg kun i den private database'' (foruden ``søg kun i begge databaser''). Så lad der også bare skulle sendes et char-flag med i købet for select-statementsne også. .\,.\,Hov, jeg skal lige komme ind på, at serveren jo.\,. Nå nej, det kommer sig jo gratis af, at man ikke behøver at inkludere værdier i insert statements i SQL, når disse værdier bliver sat automatisk i databasen. Så serveren behøver slet ikke at vide, hvad bruger-ID'et skal være, og brugerne skal så heller ikke have det med, når kommandoerne sendes til serveren. Ja, jamen så er det da bare det! Og ja, det er så applikationens altså applikationens ansvar at sætte timestampet, bare lige for at understrege dette. Ok! Jamen så bliver QL-delen ligepludselig ikke nogen særlig stor opgave.\,:) (18:35)


(15.02.23, 10:10) Timestamps kan jo også sættes automatisk af databasen, så jeg skal nok hellere lave det sådan, at brugere kan undlader at sende timestamps med, og måske kan de så bare sende et eventuelt delay med til serveren (ved siden af SQL-udsagnet).

\ldots Hm, jeg tror faktisk, at jeg skal bruge TINYINTs til at indkode databasetyperne.\,. %.\,.\,Hov, det har MySQL ikke.\,. ..Åh, jo..

\ldots\ Hm, jeg skal lige tænke over, om man bare skal sige, at man kun har BIGINT/long values til SemanticInputs.\,. men på den anden side, så er det kun en TINYINT/char til forskel.\,. .\,.\,Ja, lad mig bare sige, at det kan være det hele.\,. .\,.\,Men det bør dog være en fast konvention, at \emph{hvis} der indsættes en long/BIGINT, så \emph{skal} de første (én til fire) bytes i long-værdien repræsentere et midtpunkt/gennemsnit for ratingen. (13:54)

(14:21) Hm, det går først op for mig nu, at timestamps fylder mere end 8 bytes.\,. .\,.\,Ah nej, det kan godt være på 7 bytes. Ok, så kan man godt indsætte det som en BIGINT.\,. .\,.\,Og man \emph{kan} endda bruge 8 bytes (går jeg stærkt ud fra), hvis man vil have to decimaler på sekunderne.\,. 

(18:27) Hm, jeg behøver nok ikke den der ``meanbot'' i starten, for lad mig bare starte med at tillade AVG() i queries, og så tænker jeg forresten nu, at man skal tage gennemsnittet på ratingværdier ved at sige AVG(value $>>$ 32) (altså hvor $>>$ er right shift-operatoren (som MySQL vist rigtignok har)). .\,.\,Nå ja, og så skal der forresten lige være et indledende select, hvor man sorterer alle andre end den seneste rating fra for hver bruger--statement-kombination. 

.\,.\,Hm, på den anden side, hvorfor ikke bare bruge den der meanbot, for jeg kan jo altid bare sige, at gamle meanbot-inputs i høj grad skal slettes (altså hvor man ikke nødvendigvis sletter alle gamle.\,. Hov, vent, selvfølgelig kan man slette bottens gamle inputs ad libitum, for indtil man sletter gamle bruger-ratings, så vil de jo altid kunne gendannes!\,.).\,. Ja, så lad mig bare indføre den bot, så.\,. (18:38) 

.\,.\,Hm, jeg kan da egentligt også bare starte med at have en regel om, at nye bruger-ratings altid bare overskriver de gamle (når statementet er det samme), for mon ikke de fleste brugere alligevel helst vil have, at deres gamle ratings ikke bliver bevaret. Og så kan man spare lidt plads i den tidlige database. Så jo, lad mig bare sige det. .\,.\,Hm, men så vil det jo så sige, at der \emph{kan} være en fordel i at gemme gamle bot-inputs. Så lad mig sige.\,. Tja, og dog, for hvis det handler om at spare plads, så vil man sikkert spare mere ved at holde på bruger-ratings og så slette alle bot-ratings, for det vil nu nok være relativt sjældent, at brugere vil ændre deres ratings sammenlignet med, hvor tit der kommer nye ratings til et statement (udsagn) (og dermed hvor tit mean-botten --- eller avg-botten, kunne vi også kalde den --- skal opdatere sin rating til samme udsagn).\,. Ok, så vi siger hold på brugerdata og overskriv al bot-data (altså i starten/betaversionen.\,.). (18:46)


(16.02.23, 14:29) Jeg har nogle flere tilføjelser. For det første er der en tilføjelse om, at serveren/erne faktisk \emph{skal} kræve nogle udsagn-ratings omkring en entitet, som en bruger gerne vil uploade. Og derfor \emph{kan} vi lige netop godt droppe timestamp- og user-felterne for alle ikke-SemanticInput-entiteter. Og grunden til, at serverne bør kræve dette, er at brugerne alligevel altid gerne skal vurdere typerne og kategorierne for en ny entitet. 

Angående uploads, så tror jeg, jeg vil indføre et up- og down-rating knapper tidligt i betaversionen, og så vil jeg nok bare bruge en konvention om at disse ratings skal være på max-værdien af en (signed) long, og at intervalbredden (som så i dette tilfælde vil kunne læses alene på 5.\ byte) så sættes til det samme (som jo er halvdelen af max-værdien for en ulong). Og når brugere så vælger prædikater til et nyt upload, så skal applikationen bare automatisk sende sådanne up-rates med. 

Nå, en endnu mere interessant tilføjelse er, at jeg vil indføre compound predicates, som nærmest kan ses som en slags virtuel entitetstype. Man erklærer dem nemlig ved at vælge en relationsentitet samt en objektentitet (til at sætte ind på nr.\ 2 plads i relationen). Herved oprettes så en ny entitet (med eget entitets-ID --- og med en ny databasetype-tinyint-kode), og det, der så gør den ``virtuel,'' er for det første, at databasen så automatisk kopiere alle ratings fra eksisterende DyadicStatements med lige netop den kombination af relation og objekt og giver den til nyoprettede MonadicStatement, som tilsvarer DyadicStatements'ne, men hvor relation og objekt nu altså er udskiftet med den tilsvarende, nyoprettede CompoundPredicate. Og for det andet skal hver ny rating af enten et CompoundPredicate-MonadicStatement eller en relation med en relation--objekt-kombination, der svarer til et CompoundPredicate, have sin rating kopieret automatisk til den anden udgave af sig selv. 

.\,.\,Hm, lad mig dog lige spørge mig selv igen, om ikke det så var nemmere at fjerne Dyadic-Statement-typen, og så bare nøjes med compound predicates.\,.\,? Hm, jeg føler/husker, at der var en god grund, men lad mig nu lige se.\,. .\,.\,Ja, grunden er jo, at man tit kommer til at holde en entitet i hånden, hvor man så gerne vil søge efter en passende objekt-entitet (``objekt'' som i `sætningsobjekt') ud fra en given relationsentitet, som man også holder i hånden. Men hvis man så kun har compound predicates, så.\,. .\,.\,Ja, så kræver det vel et ret vildt/tungt (tabel-)join, gør det ikke.\,.\,? (14:55) .\,.\,Hm nej, for det kræver jo kun ét join for at opnå et view, hvor man har subjekt, prædikat, eventuel relation (hvis prædikatet er compound) og objekt (hvis prædikatet er compound). Og så kan brugerne bare søge i dette view. Jamen skal jeg så virkeligt fjerne DyadicStatements?? Det virker lidt mærkeligt, for konventionelt er DyadicStatements jo det \emph{eneste} man har, hvis vi tænker på det de konventionelle `semantiske web'-teknologier.\,.(!).\,. (15:01) .\,.\,Oh well, vi har dem jo stadigvæk i form af omtalte view, og ja, det giver jo klart god mening at undgå, at dataen skal kopieres i databasen (af flere grunde), så mon ikke bare, det er det, jeg gør.\,. (15:04)

.\,.\,Det koster os lige en gemt long/BIGINT mere i databasen for hver DyadicStatement, hvor man ikke regner med, at nogen vil være interesseret i at bruge prædikatet (men hvor brugerne regnes med altid bare at skulle bruge objektet, efter at de har subjektet (og relationen) i hånden), men sådan må det jo bare være.\,. .\,.\,Og til gengæld sparer vi en TINYINT for hver SemanticInput, og det må jo faktisk næsten gøre, at det kan svare sig rent datastørrelse-mæssigt. (For mon ikke der bliver flere end 8 ratings pr.\ DyadicStatement i snit.\,. det må der gøre.\,.\,:)) 

Ok, og den næste store ting er så, at jeg i betaversionen vil tillade (og implementere), at brugerne kan loade pre-parsede CSS- og HTML-includes til deres applikation ad libitum, hvor man så særligt sørger for, at HTML'et bare ikke må indeholde andre hrefs eller script-srcs, end hvad brugeren på forhånd har godkendt i en indledende config-``fil,'' som hentes til at starte med (fra brugerens private database-afdeling). Og i øvrigt må der så (selvfølgelig) heller ikke være nogen scripts, der har noget kode-indhold, og som altså ikke henter al deres kode fra en src. Brugerne skal så kunne ændre på deres egne href-/script-src-configs, men hvis brugeren klikker sig ind på denne config side, skal der så bare med det samme komme en skarp advarsel om ikke at ændre eller tilføje nogen kilde med mindre man har dobbelt- eller tripeltjekket, at kilden er sikker, gerne ved at søge på webbet eller ved at søge i den semantiske database / det semantiske netværk omkring kilden, og rigtig gerne ved at gøre begge ting! (hvorfor jeg skrev ``tripeltjekke''). 

Så her får vi altså allerede en ret nem måde, hvorpå brugerne allerede kan gå i gang på sikker vis med at indstille alle mulige præferencer for applikationen. 

Ok, men lad mig nu skifte til en ny sektion, hvor jeg så vil tilføje noter omkring, hvad betaversionen skal sigte imod at indeholde (så altså hvad jeg så småt vil sigte mod at bygge). Jeg har nogle få ting, jeg vil skrive nu, og ellers vil jeg sikkert tilføje ting løbende, imens jeg arbejder. Men hvis jeg kommer på nogle flere tilføjelser til noget af det mere grundlæggende, så tror jeg nok, at jeg bare vil tilføje dem i forlængelse af denne sektion (hvor jeg så bare giver nye dataangivelser, men ikke angiver * for ``tilføjet senere end den oprindelige tekst,'' som jeg ellers lidt fjollet har valgt at gøre for nogen af de ovenstående sektioner). (15:33, 16.02.23)


(17.02.23, 12:39) Jeg kom lige på en rigtig nyttig tanke her i formiddags, som helt klart at værd at skrive i denne sektion. Den er, at man i applikationslaget --- og i min betaversion --- skal indføre standard for at skrive attributter ned for en ny DescribedTerm/DescribedEntity med en tilhørende automatisk oprettelse af relations-statements (som nu altså oprettes via et compound predicate (sammensat prædikat)). Jeg tænker så, at indføre en parser til at parse entity descriptions på formen, ``$<$attribut$>$=$<$værdi$>$,$<$attribut$>$=$<$værdi$>$,\ldots'' Og for hver attribut søges der så på, om der findes prædikat-funktion (altså en relation omdannet til en anden-ordens funktion), der svarer til `$\lambda$value : hasAttribute $<$attribut$>$ = value,' og hvis ikke denne allerede findes oprettes en ny. Herefter uploades så et sammensat prædikat, dannet ved at tage den relevante $<$værdi$>$ og give til input i denne prædikat-funktion. Og når dette prædikat så er dannet --- eller dvs.\ først så søges der jo på, om det allerede er dannet, kan man sige (om end dette tjek så er serverens eller databasens ansvar (men det skal jo nok være databasens)) --- så sørger man så for, at en automatisk up-rating af dette prædikat (som altså fortæller at ``$<$attribut$>$=$<$værdi$>$'' for et af attribut--værdi-parrene i beskrivelse-strengen) bliver givet omkring den nye entitet som uploades med denne beskrivelse. 

Dette giver så et rigtigt godt udgangspunkt for applikationen, som gør at brugere allerede fra start lærer, at attributter skal/bør get'es på semantisk vis via relationer/prædikater. Og samtidigt klarer det også den opgave, jeg alligevel skulle finde ud af, hvor at jeg jo skulle gøre det til en standard, at brugerene får uploadet nogle kategori-beskrivende (m.m.) prædikater om den nye entitet, de er ved at uploade. For nu kan dette nemlig altsammen bare ske på en rigtig nem måde (ikke mindst for brugerne), hvor disse prædikater bare automatisk bliver parset fra beskrivelsesstrengen og uploadet.\,! Så med denne tilføjelse er man altså lynhurtigt bare godt i gang så at sige.(!) 

Lige for at komme mere ind på syntaksen, så vil jeg så nok altså gøre standarden til, at brugerne skal (hvis den parser jeg implementerer skal fungere) udforme beskrivelses strengen ud fra den nævnte syntaks, men hvor whitespace dog er tilladt mellem alle tegnene. Og jeg vil også tillade, at man laver attributter og værdier med længere strenge, hvor der også gerne må være kommaer og whitespaces i, og hertil skal jeg så lige finde ud af, hvordan de skal indkapsle disse strenge. Her kunne man jo bare sige, at det skal bruge gåseøjne yderst, og at alle indre gåseøje så skal escapes med `\textbackslash' (Og hvor `\textbackslash' så i stedet skrives som `\textbackslash\textbackslash'), men jeg har også tænkt på at bruge `\{\}' i stedet, og det tiltaler mig nu helt klart også.\,. .\,.\,Ja, for så bliver det mere naturligt at lave newlines.\,. Plus jeg kunne også bruge `\{\}' som en måde, hvorpå brugerne har lov at bryde syntaksen (uden at forvirre parseren).\,. Hm.\,. (13:09) .\,.\,Hm, jeg kan altså mærke, at jeg hælder til at bruge `\{\}'.\,. .\,.\,Parseren ignorerer så en `\{\}'-indkapslet delstreng, der står imellem to kommaer (eller efter sidste komma), og.\,. Hm vent, hvad med at tillade brug af begge indkapslingsmetoder.\,. Ah, og attributter behøves jo faktisk ikke at indkapsles! Okay, det giver mening. Og værdi-strenge kan så indkapsles enten med `""' eller med `\{\}', og så vil jeg også sige, at alle indledende eller afsluttende newlines *(al whitespace i det hele taget, rettere) bliver ignoreret/slettet for `\{\}'-syntaksen, medmindre altså der står et `\textbackslash' foran. Der må desuden godt være indvendige `\{\}'-parenteser, men hvis man vil skrive et `\}' uden at der først har været et (ikke-afsluttet) `\{', så kan brugeren så gøre dette ved at skrive `\textbackslash\}' i stedet, hvilket tolkes som `\}' --- dog medmindre at der også et `\textbackslash' (eller et ulige antal af dem) lige foran dette `\textbackslash\}'. Og brugen kan også skrive `\textbackslash\{' frit, uden at det tæller med som begyndelsen på en nestet `\{\}'-parentes. Så ja, det er altså min umiddelbare forestilling (nu) for denne syntaks.\,. (13:22)

(14:06, 17.02.23) Ah, i stedet for at indføre den der mean-/avg-bot, så kunne jeg også bare indføre et view med en automatisk beregnet AVG() (eller rettere AVG($x$ $>>$ 32) $<<$ 32), som brugerne så får adgang til. Og ja, i samme view kan jeg i øvrigt også give COUNT()'en for antallet af brugerratings. 

(17:25) Hm, i stedet for at have Compound-/FunctionalTerms, så tror jeg måske, jeg i stedet bare laver DescribedTerms om, så de får et description\_schema (i stedet for bare en description) samt et (nullable) schema\_input. For dette gør så tilmed også, at det bliver mere oplagt for brugerne at definere faste skemaer for nye uploads af entiteter af forskellige (semantiske) typer. .\,. \ldots Ja, og så laver jeg også bare en standard (i applikationslaget) til parseren for, hvordan man skal erklære inputvariablene, og hvordan disse så automatisk skal sættes ind i beskrivelsen/beskrivelsesskemaet, inden at attribut--værdi-parsingen udføres. (17:39)

(18.02.23, 11:22) Okay, jeg tror faktisk, at DescribedTerm (eller hvad jeg ender med at kalde det) i stedet simpelthen skal defineres med en liste af prædikater først til at bestemme type/kategori, og som nr.\ 2 liste skal der så komme en liste af attributter, hvor applikationen så faktisk automatisk selv finder de mest populære attributlister fra hver type/kategori-prædikat og så sætter dem sammen i én samlet liste. Disse attributter skal så tilsammen udgøre alle de ``definerende felter'' for entiteten, man er ved at uploade. Derefter kommer en ny attributliste, som applikationen også prøver at hente automatisk, hvor entitetsforfatteren så kan tilføje data omkring entiteten (altså data, der ikke behøves for at referere til / definere entiteten, men som relaterer sig til entiteten alligevel (og som brugere typisk gerne vil have serveret, når de iagttager entiteten)). Og ja, så skal der altså også være en femte liste, der så holder forfatterens (eventuelle!) inputs i disse datafelter. 

.\,.\,Hm, nu hvor dette så bliver meget specielt rettet mod at oprette ressource-entiteter, ville de så ikke give mening at genindføre en relations-/prædikat-funktion-/funktion-type.\,.\,.? \ldots Ja, for man regner jo ikke med, at nogen vil søge på det specifikke prædikat, der bliver dannet i en tilføj-data-, tilføj-links- eller tilføj-beskrivende/definerende-data/tekst-relation.\,. 
.\,.\,Hm, på den anden side, så kunne dette godt ske lige netop med tilføj-links-relationer.\,. Hm.\,. .\,.\,Hov, men den tilføjede data skal da heller ikke være en del af selve DescribedTerm; det kan bare være en del af, hvad applikationen spørger til, når man vil oprette et nyt term. Og derfor kunne man jo bare lade være med at tilføje data for sådanne relationer --- som så typisk bare vil have en fast liste af prædikater, der definerer relationen, og så en.\,. hov, men hvad man attribut-navnelisten?\,.\,. \ldots Hm, attributterne er jo også i sig selv relationer, så.\,. Okay, lad mig lige tænke over, hvad der bedst giver mening.\,. (12:09) .\,.\,Ah, man kunne vel i princippet bare oprette et ret grundlæggende Apply()/Insert(Sentence)Object()-term-skema.\,. (/-relation).\,. (12:13)

.\,.\,(12:22) Ah, nu ved jeg, hvad jeg gør. Jeg beholder de seneste ændringer i DescribedTerm, men jeg indfører så faktisk også relationer igen, men ikke via DyadicStatements. I stedet indfører jeg dem via CompoundPredicates.\,. /CompoundTerms.\,.  

\ldots (12:41) Hm, nu tror jeg faktisk hellere, jeg vil.\,. Nå ja, det bliver jo egentligt lidt det samme, hvad den databasen angår. Så jeg tror altså, jeg vil indføre CompoundPredicate (ikke CompoundTerm! for det er ikke meningen, at man skal danne andre funktioner end prædikat-funktioner!), og at jeg vil ændre DescribedTerm som beskrevet, og nu forestiller jeg mig så at lægge op til, at CompoundPredicates så altid (måske på nær i få tilfælde) skal ses og bruges som attributbestemmelser. Så når brugeren indfører en relation, så skal de meget hellere se det som, at de indfører en attribut til en vis type/kategori. Og ja, det er jo lige netop disse attributter (i form af hvad man også sagtens kan se/tolke som relationer), som applikationen skal hente i nævnte liste nr.\ 2, når en ny entitet / et nyt term oprettes. .\,.\,Og den store forskel på at se det som relationer og på at se det som attributter er altså, at relationer ofte ses som noget generelt, der giver mening at snakke om for alle entiteter, og som altså derfor ikke har et egentligt domæne så at sige, men hvor attributter i langt højere grad tolkes som havende et domæne, specifikt nemlig et domæne for subjektet i relationen (og også tit for objektet, men det er faktisk ikke så vigtigt for os). Og det vigtige ligger nemlig i, at brugerne gerne må udforme relationerne til meget specifikke typer/kategorier. Og hvis så en relation/attribut kan gå igen på tværs af kategorier, jamen så må man bare tilføje den en passende overkategori, og hvis nu den kan bruges på tværs af overkategorier, jamen så må man bare tilføje den hver især til alle de relevante overkategorier!\,. Simpelthen!\,. (12:54) .\,.\,Hm, og en anden tilsvarende fortolkning er jo så bare, at i stedet for at se relationerne som attributter, så ser man dem bare som domæne-specifikke relationer, hvilket nemlig giver det samme.\,.\,:) (12:57)

.\,.\,Hm, men spørgsmålet er dog, om ikke jeg vil kalde det for attributter frem for.\,. ja, ``domæne-specifikke relationer,'' for det sidste er alligevel en mundfuld, hvis man gerne vil præcisere det.\,. .\,.\,Oh well, men hvis jeg holder mig til at kalde det CompoundPredicates i databasen, så ligger dette jo bare åbent for fortolkning i applikationslaget.\,. 

.\,.\,Ah, men et godt spørgsmål er, om man skal lade CompoundPredicates være førsteklas-sestermer, eller om man i stedet bare skal sige, at de må fremhæves til førsteklassestermer via (Described)Terms (på en eller anden måde.\,.), før de bliver dette.\,.\,? .\,.\,Hov, men de skal jo være første.\,. nå nej, for man kunne jo måske også ændre Statements, lad mig lige se en gang.\,. .\,.\,(Hm, hvis ikke de behøver at være førsteklasseborgere, så kunne man eventuelt ændre Statements til altid at have tre inputs, som jeg også havde det en gang.\,.) .\,.\,Hm, det virker faktisk på en måde rigtigt (i.e.\ at det er det, jeg bør gøre), men lad mig lige overveje, hvordan brugerne så kan tilgå relation/attribut--input/værdi-kombinationen som et prædikat.\,. (13:16) .\,.\,Hm, hvad med at brugere kan oprette ``virtuelle prædikater'' på samme måde, som jeg har været inde på før.\,.\,? .\,.\,Hm, men så skal dette jo også indgå i den fundamentale del af databasen (for det skal jo gemmes, hvilke virtulle prædikater er blevet oprettet.\,. tja, medmindre.\,. hm.\,.).\,. .\,.\,Men lad mig da lige nævne den mulighed, jeg skulle netop til at nævne, hvilket er at oprette en VirtualPredicate-type, .\,.\,som så kommer til at svare helt til CompoundPredicate, bortset fra at når man rater et sådant, så er det i virkeligheden den relaterede relation--input-/attribut--værdi-kombination, der bliver ratet i stedet. .\,.\,Hm, men lad mig lige tænke lidt over det.\,. (13:30) 

.\,.\,Hov, nu fik jeg også lige en alternativ tanke: Hvad med at droppe prædikater, og så bare formulere alt med relationer i stedet?\,.\,. For selv hvs vi tænker på prædikater såsom ``isFunny,'' jamen her kan man jo også bare definere `is(adjective)'-relationen, og så definere alverdens adjektiver. Og hvad angår kategorier, så er det jo også netop ret naturligt, at sige `hørerUnder(Kategori)' og så indputte kategorien `fysik' f.eks.\ i stedet for at tænke på et helt prædikat om at `tilhøre(r)KategorienFysik.' .\,.\,Og ja, selv hvad angår tillægsordprædikater, så er det nok endda også mere naturligt for os (ift.\ hvordan vi typisk tænker og gør med vores naturlige sprog) at tænke i at definere adjektiver frem for hele prædikater. Så ja, det er da lige før, at jeg skal fjerne prædikaterne og så bare kun bruge relationer (ligesom konventionelle sem-web-teknologier). Så skal jeg bare lige overveje det her med, at brugerne gerne også skal.\,. ja, definere domæner til hver relation, men det spørgsmål svarer jo næsten sig selv: Man skal så bare lægge op til i systemet, at hver ny relation bliver tildelt domæner (og især faktisk hvad subjektet angår, selvom objektdomænet også nok bør angives, da det også kan hjælpe med forståelsen af relationen).\,. (13:45) .\,.\,Det skal dog ikke forstås som, at databasen (eller control-serveren) skal verificere disse domæner. I stedet hjælper domænerne bare med forståelsen/fortolkningen af relationen, og ikke mindst gør det nemmere at søge i relationer --- og at finde relationer, der passer på lige det man søger. .\,.,Hm, men vent, for prædikater er stadig nice at søge på, så.\,. Ah, men så søger man jo bare på unikke relation--objekt-kombinationer, når man vil søge på prædikater.\,. .\,.\,Hm, nu tænkte jeg lige på: skal alle termer så ikke bare bestå.\,. nej, det giver ikke mening, lad mig lige tænke videre.\,. .\,.\,Ah, nu ved jeg det måske. Hvis alle prædikater nu bare formuleres som relation--objektinput-kombinationer, kan vi så ikke bare lave typen Predicate, som har disse to felter, og så.\,. ja, er det så ikke nærmest bare det.\,.\,? .\,.\,Ja, som så bare svarer helt til CompoundPredicate fra før, bare hvor Statements så \emph{kun} tager prædikat-input af denne type, og hvor vi så heller ikke behøver at kalde dem ``Compound,'' hvis det jo alligevel ikke er andre muligheder. Hm, jeg tror, det bliver svaret (og så beholder jeg altså umiddelbart, som jeg bliver ved med at sige, de seneste ændringer der for DescribedTerm).\,. (13:59) .\,.\,Hm, jeg skal nok faktisk gå væk fra at kalde det ``termer'' og over til at kalde det Entities i stedet, for i matematik og i formel logik er ``termer'' jo aldrig prædikat- eller relationssymboler, mener jeg (og jeg har også lige søgt kort på det), så ja, lad mig sige `entiteter' i stedet.\,. .\,.\,Ja, og så kan `termer' passende være, hvad man kalder overtypen/-kategorien af entiteter, der ikke er hverken prædikater eller relationer --- eller lister. (14:07)

(14:45) Hm, jeg tror muligvis, jeg vil føje endnu en type til i form af `kendte ord' (eller hvad jeg skal kalde det), som altså er entiteter, der bare er beskrevet med et enkelt ord eller navn, eller en enkelt titel eller sammensat navneord.\,. .\,.\,Hm, eller også kunne man bare implementere dette via mine DescripedEntities, hvor første input så beskriver, at der er tale om ting, der i høj grad bør kunne forstås uden yderligere kontekst end bare ordet/navnet/titlen, og hvor inputtet så er dette ord/navne/denne titel, men det kan jeg lige tænke over.\,. .\,.\,Hm, nej, måske var min første tanke bedre, nemlig med bare at sige, at relationer --- især de meget grundlæggende af slagsen, men også i det hele taget --- meget gerne må indeholde i sig en beskrivelse af, hvordan det resulterende prædikat skal fortolkes (eller rettere forsøges at fortolkes), hvis inputtet er en tekst. Så ja, lad os bare sige det i stedet. (15:00)

(15:57, 18.02.23) Ah, jeg kan godt nøjes DescribedEntities, som jeg har tænkt mig, og så kan de helt basale typebestemmende prædikater, eller rettere relationer, som det jo bliver nu, bare få en tom liste som første input-liste.\,. .\,.\,Og, så kan det nemlig bare være standard, at applikationen klargør en `description'-attribut som den eneste attribut, når første liste er den tomme liste, og nr.\ tre (og sidste (for de ikkebeskrivende attributter bliver jo ikke et faktisk felt i DecribedEntity-typen, men bliver i stedet bare sat via eksterne relationer)) input-liste bliver så altså denne tekstbeskrivelse. .\,.\,Hm, så er det så bare lige at finde ud af, hvilken type description'-attributten (som i: attributnavnet) skal have.\,.\,? .\,.\,Hm, det må jo bare være (small-)tekst-typen, og så skal den grundlæggende fortolkning (som er antaget allerede fra start af, inden man fylder entiteter ind i databasen) altså bare være, at tekster i denne liste opfattes som attributnavne (på samme måde som fortolkningen af felter og feltnavne i OOP). .\,.\,Hm, og så kan man jo sådan set beholde denne fortolkning ret langt.\,. hvilket måske giver meget god mening.\,. .\,.\,Tja, og dog, for man må jo også gerne gøre det nemt for parseren at.\,. Ah vent, men man kunne jo også definere en god `x.hasAttribute(y)'-relation fra starten af, hvor y kan være et tekstinput.\,. For måske er det alligevel dobbeltkonfekt at specificere domænet, når dette allerede bliver specificeret i første inputliste (i DescribedEntity-typen).\,. .\,.\,Ah, men man kunne jo bare se attributter som noget, der i princippet, selvom de jo kan omfortolkes som relationer, er noget helt andet en relationer, i.e.\ har en anden type.\,. .\,.\,Hm, men for at alt dette skal gå op, så skal der jo næsten være en relationsfunktion (altså en prædikat-funktion-funktion), der kunne hedde noget i retning af `hasAttribute,' og som så tager attributnavn først og bagefter værdi, inden det så returnere et prædikat som endeligt kan tages på et subjekt.\,. .\,.\,Hm, og en måde at indføre dette på, kunne jo så eventuelt bare være, at.\,. hm nej, men måske at give Predicate to undertyper, hvilket så kan være.\,. Hm, okay der er to muligheder angående denne tanke: Man kan enten sige, at relations-inputtet i Predicate-typen godt kan være en tekst, hvor.\,. ah ja (tja), hvor teksten skrives som en relation, og hvor `has' derfor altid sættes foran automatisk, når applikationen skal parse en attribut og lave den om til en relation/et prædikat. Men jeg vil faktisk langt hellere gøre det sådan, at tekst-relationer altid bare skrives som attributter, og at `has' altså aldrig gemmes i databasen, men at `has' i stedet bare kan sættes foran i applikationen, når denne skal vise en liste over relationer, hvor disse tekstdefinerede relationer også kommer med.\,. eller endnu bedre: man kunne sørge for at alle tekstdefinerede relationer printes efter fulgt af et ` ='! For umiddelbart, som jeg lige kan se det, så vil dette virke overalt (både når hele prædikatet (eller hele udsagnet for den sags skyld!) printes, og også bare når relationen vises for sig)! .\,.\,Fedt!! (16:34)

(17:23) Ah, og vi kan forresten passende blande nr.\ 1 og nr.\ 2 liste sammen til én, nemlig således at hvert tekstinput i denne liste så bare opfattes som et attributnavn. Og den anden type input i denne liste, som man så typisk gerne vil se (medmindre vi skal gøre det til en klar restriktion), er så input af prædikat-typen. .\,.\,Hm, jeg tror nu nok, jeg vil undlade at gøre det til en fast ting, at resten af inputtet skal være prædikater, og måske skal dette ingen gang være en standard. Man kunne således også forestille sig, at applikationen (samt brugernetværket) også fint kan tolke kategori- og adjektiv-inputtyper, hvorved applikationen så selv automatisk finder hhv.\ relationerne `belongsTo(category)' og `is(adjective)' frem og uploader de relevante prædikater om den nye entitet dannet ud fra disse. Så ja, lad os sige, at input-databasetyperne også sagtens kan være DescribedEntities af vilkårlige custom-typer og -kategorier. (17:32, 18.02.23) .\,.\,Hm, og skal liste nr.\ 2 så bare give input kun til attributterne, eller hvad gør vi her.\,.\,? .\,.\,Hm, i princippet kunne listen indeholde input til både attributterne og DescribedEntity-relationerne.\,. .\,.\,Ja, lad mig bare sige det sådan, og så er det altså op til brugernetværket samt applikationslaget at sørge for, at nr.\ 2 liste fortolkes på denne måde, og at parseren i applikation altid kan genkende relationsentiteter (beskrevne), således at den automatisk kan danne de rette prædikater hørende til et nyt upload. Ok! 

(19:05) Hm, det kan også være, at man bare skal lægge kraftigt op til, at brugerne kan gøre brug af at definere simple relationer ved at skrive et attributnavn efterfulgt af `='.\,. .\,.\,Hm, jo lad mig faktisk gøre sådan, for det er jo ikke alle, der er vant til attributter, og man kan jo også sige, at der vel må være en god grund til, at vi har det med at bruge verber i daglig tale. Fint. Så jeg TTexts skal altså i reglen fortolkes som verber, medmindre de slutter med `=,' hvorved de så skal tolkes som første del af en attribut-erklæring --- og hvor man altså altid udelader det indledende `has,' der ellers ville gøre det til verbum i stedet (hvis man nemlig så også erstattede `=' med `er lig')!\,. Ok. (19:13, 18.02.23) \ldots (Hov, det er vist bedre at bruge VARCHAR i stedet til små tekster.\,.)

(22:24) Predicates kan selvfølgelig også bestå af et (beskrevet) prædikat samt den tomme liste som input. 

(19.02.23, 8:53) Det hele (i overført betydning) forsimples en del, hvis vi i stedet kræver, at attributter også skrives med punktum foran, og ikke bare med `=' bagefter, for så kan alle tekst-(/varchar-)relationer nemlig tolkes som verber, bare hvor man så har en konvention om at `$.<$attribute$>$=' tolkes som `has $<$attribute$>$ equal to.' 

.\,.\,Nå ja, og lad mig også pointere, at man nok bare vil bruge `.type=' for prædikater og relationer, og så lade `.type=term' være default (underforstået hvis ikke andet er sagt). Og så vil de typiske term-entiteter, som uploades, have en nr.\ 1-liste (en ``categorizing list'') bestående først af en række prædikater (med databasetypen Predicate! (ikke DescribedTerm)) efterfulgt af en række ``beskriv hvad kendetegner dette (denne) term specifikt (inden for den kategori du lige har valgt via prædikaterne)''-relationer. 

.\,.\,Hm, skulle man egentligt dele denne ``categorizing list'' op i to lister?.\,. Hm, hvorfor ikke.\,.\,? (9:07) .\,.\,En ``categorizing list'' og en ``specifying list''.\,. .\,.\,Hm, og man kan jo egentligt ligeså godt sørger for at dele det op, så DescribedTerm dermed får tre hovedfelter (eller ``hovedkolonner'' hvis man tænker på det som en tabel i stedet for en type). Ja, det må være bedst sådan. (9:13) .\,.\,Ah, og dog, for man vil jo tit gerne bruge dem sammen. Hm, jamen så må nr.\ 1 input jo bare være en L2List (længde-to-liste).\,:) .\,.\,Hm, men hvordan finder jeg et fornuftigt tabel-kolonnenavn til ``categorizing predicates and relations for specification''??.\,. .\,.\,He, ``catepreds and specirels''.\,.\,x) .\,.\,Hm, det er faktisk lige før det virker, hvis jeg putter underscores mellem hver forkortelse også, for fonetikken (og rytmen i det) gør vist faktisk, at det er til at huske.\,. he.\,. Men lad mig lige tænke.\,.\,:) (9:24) .\,.\,Hm, hvad med bare ``CPs and SRs?''.\,. (9:26) .\,.\,Ah, jeg tror, jeg vil kalde kolonnen `cpred\_and\_srel\_lists.' (9:28) .\,.\,Ah, eller jeg kunne endda bare kalde det `cpreds\_and\_srels.'

(11:04) Hm, eneste problem med min attribut-sytaks er, at den ikke er så naturlig, når der kan være mere end én værdi (hvad der oftest kan).\,. .\,.\,Ah, vent! Lad mig da bare bruge kolon til sidst (i stedet for `='), når man regner med, at der typisk/ofte vil være flere end én værdi! (11:09)

(18:01) Ah, jeg kom lige på en idé, som jeg nu hurtigt derefter kan se, faktisk løser et Russell-paradoks, som jeg faktisk ikke rigtigt har tænkt på indtil nu, nemlig at man ikke kan have et isPredicate(), der siger, at det selv er et prædikat. Og løsningen (som jeg altså kom på inden jeg tænkte på, at det løser det paradoks, og at idéen --- eller en anden idé der løser samme paradoks --- derfor er nødvendig) er at se Predicates, hvor første input, nemlig relations-/prædikat-inputtet (som jeg i øvrigt bare kalder relation i databasen), er en tekststreng (varchar), som.\,. ja, eller rettere at se første input i disse tilfælde som ``anonyme prædikater/relationer'' i den forstand, at man ikke direkte kan tage nogen prædikater eller relationer på dem. Dette er nærmere bestemt fordi, de aldrig får et ID i databasen --- eller dvs.\ de har et ID til den pågældende tekststreng (varchar), men denne tekststreng bør ikke i sig selv tolkes som et prædikat eller en relation; kun som en datastreng af chars. Ja, denne datastreng vil kunne forbindes med en semantisk fortolkning, men ID'et referere altså til de \emph{u}-fortolkede dataobjekt. Det er kun, når man putter dette data ind som første input i Predicate-typen, at strengen bliver fortolket (som et prædikat eller en relation i stedet for en karakterstreng). Og dermed kan disse fortolkede prædikater eller relationer altså siges at være anonyme, fordi de ikke får noget ID i databasen, der referere semantisk til dem. 

Men hertil skal det så siges, at man jo godt kan indføre en relation, der siger `has (useful) relation (or predicate) interpretation' --- eller tilsvarende: `is (useful) relation (or predicate) lexical item.' Og på den måde kan brugerne godt finde en måde alligevel at lave.\,. tja, jeg skulle lige til at sige ``lave en fællesmængde af alle prædikater inklusiv de anonyme, der bruges i databasen,'' men mon ikke vi så vi alligevel bliver nødt til at glemme håbet om så at få selve `is (useful) relation (or predicate) lexical item' med i denne mængde, det går jeg ud fra (for ellers får man sikkert Russells paradoks). Men ja, dette var nu alligevel også bare en sidenote, for det er også helt fint, at der er et lille antal anonyme prædikater/relationer, især hvis man bare bruger dem til at komme i gang med semantikken, og altså ikke bruger dem aktivt i den efterfølgende brug af systemet. 

Så lad mig defor sigte efter, at finde på nogle gode grundlæggende anonyme prædikater og relationer, der kun er beregnet til at skabe at udgangspunkt for resten. Bemærk i øvrigt, at dette nok gør standarden omkring `$.<$attribute$>$='-syntaksen overflødig i det helt grundlæggende plan, men derfor kan man godt stadig gøre brug af denne standard i et nedre lag i applikationslaget alligevel, nemlig fordi jeg regner med, at forfatter til (beskrevne) prædikater og relationer gerne skal føje en `.identifierSuggestion' til sådanne, i hvert fald til den de regner med skal bruges meget i det nederste lag af applikationen (altså nederste lag af, hvad jeg kalder ``applikationslaget'' (se ovenfor for mere om, hvad jeg mener med dette)).\,. Dette er dog bare, hvad jeg lige umiddelbart tænker; det kan også være, at `.identifierSuggestion' slet ikke bliver nødvendigt, hvem ved?\,. (18:27, 19.02.23)

\ldots (18:49) Hm, hvad med at have `isPredicate,' `isRelation,' `isCategory,' og `isTerm'-/`isObject'/`isInstance'/\ldots som de (eneste) grundlæggende (``anonyme'') prædikater, og så have `.lexicalItem=' som den (eneste) grundlæggende relation? .\,.\,Hm, eller i stedet for `.lexicalItem=' kunne vi også bare have `.definedBy=', hvilket både er mere elegant og lettere forståeligt/genkendeligt, og samtidigt er det også mere generelt, fordi man så oplagt kan sige, at værdien/sætningsobjektet både enten kan være en ``lexical item'' eller en ``description'' (altså en lidt længere tekstbeskrivelse).\,. Hm.\,. .\,.\,Ja, og lad mig så bare opfordre til at.\,. hm, vent, hvad med at have begge relationer alligevel (altså have både `.lexicalItem=' og `.description=')?.\,. .\,.\,Hm nej, måske ikke, for måske vil man jo gerne netop have, at `.description=' \emph{ikke} bliver en ``anonym'' relation. .\,.\,Hm, nu hælder jeg faktisk næsten lidt tilbage til bare at have `.definedBy=', som så kan gøre double duty så at sige, for måske gør det alligevel ikke noget, hvis `.definedBy=' er en anonym relation.\,. .\,.\,Ah, jeg er i tvivl, så lad mig lige tænke over det, og lad mig også tænke over, om der er en måde helt at undgå anonyme relationer på.\,. Hov, forresten, prædikater bliver jo aldrig helt anonyme, for man kan bare bruge den resulterende Predicate-entitet som nyt prædikat-input (lige præcis i disse fire tilfælde og ikke andre.\,.).\,. 
\ldots Ah, jeg tror det kan løses, hvis bare jeg lige indfører en ny databasetype Relation (ligesom Predicate).\,. Hm, men spørgsmålet er bare, om det er det værd.\,. (19:24) .\,.\,For jeg kunne vel også bare indføre `.definingLexicalItem=' som den (eneste måske) grundlæggende relation.\,. .\,.\,Ah, der \emph{er} en stor fordel ved at indføre en Relation-type, for det kan nemlig lige præcis bruges til at tillade relationer defineret alene ud fra lexical items, men uden at dette så kommer til at koste brugerne, fordi de så ikke får noget relations-ID af sådanne definitioner. .\,.\,Hm, og så kunne man måske godt endda sige, at Relations-typen specifikt er for at danne relationer ud fra lexical items.\,. Hm.\,. .\,.\,Hm, hvad med at jeg i stedet bare opretter en ny type, der hedder LexicalItems, og så løser alle problemerne (måske) herved?!\,.\,. (19:35) .\,.\,Nej, for jeg vil nok gerne kunne skelne typen med det samme, men hvad i stedet med at jeg indførte typen VerbalClause, som altså netop er Relation-typen, hvor input kun kan være en ``lexical item''-streng? .\,.\,Og så skal min `$.<$attribute$>$(= $|$ :)'-syntaks bare være underforstået, når det kommer til, hvad man betegner med en `verbal clause.' (19:42) .\,.\,Hm, eller hvad med at lave en Relation-type, hvor input kan være to forskellige ting (ligesom for min nuværende Predicate-type), og hvor Predicate så også.\,. Nej vent, den kan jeg beholde, som den er, men til gengæld kunne jeg måske prøve at lægge op til en konvention om aldrig at bruge beskrevne til andet end med det samme at fylde ind i.\,. Hm nej, det duer måske ikke.\,. .\,.\,Ah, jo! Man kunne måske sige, at nyoprettede.\,. Hm, måske ikke.\,. .\,.\,Hm, nu har jeg muligvis lyst til at gå tilbage til `isPredicate,' `isRelation,' `isCategory,' `isObject,' og `.definingLexicalItem=' som de eneste grundlæggende/``anonyme'' prædikater og den eneste grundlæggende/``anonyme'' relation hhv. (19:55) .\,.\,Ja, og så må brugerne altså bare indføre attributter via DecribedTerms, hvilket jo egentligt også er meget fornuftigt, for så kan attributterne forklares, plus man kan tilføje andre varianter og former (bl.a.\ ved at omformulerer dem til normale lexical items) af dem, enten med det samme eller efterfølgende. (19:59, 19.02.23)

(20:20) Ah nej, nu tror jeg, jeg ved (nogenlunde), hvad jeg gør i stedet. Jeg indfører følgende grundlæggende typer: Relation, Category og Object (udover Predicate, som jeg allerede har). Og ligesom at Predicate ``selv ved'' om dens ``undertype'' er en `relation med input,' `e omfortolket tekst' eller en `prædikat defineret af sig selv givet som et DecribedTerm' (hvor sidstnævnte nu bare skal erstattes med undertypen `beskrevet prædikat' og så skal DescribedTerm-typen slettes), uden at det ændrer databasetypen af Predicate-instansen, så skal tilsvarende altså bare gælde for de andre tre grund-(ikke-data-)typer (Relation, Category, Object). Jeg tænker så faktisk at indføre endnu en type kaldet LexicalItem, som altså er en.\,. nå nej, vent, dette behøves nok ikke. Nej, never mind; man inputter bare textstrenge i disse tilfælde, og så er omfortolkningen (altså ``derefereringen'') jo bare indforstået her. .\,.\,Ah, og hvis man nu alligevel skal bruge mindst to input-BIGINTs til alle disse fire typer, nemlig fordi beskrevne entiteter (som der nu er fire typer af, nemlig i form af én undertype til hver af de fire ikke-data-typer) jo alligevel skal have to lister, jamen så kunne man måske bare sige, at hvis nr.\ 2 input ikke er den tomme liste for en beskrevet undertype, så er nr.\ 2 input simpelthen bare en (valgfri) ``description''.\,.\,!\,:) .\,.\,Fedt!!\,:) .\,.\,Hov nej, ikke for en beskrevet undertype! (for der vil de to inputs jo være de to lister (med ``cpreds'' og ``srels'')) men i stedet altså for den.\,. ja, hvad skal vi egentligt kalde den?\,.\,. Hm, lad mig for nu kalde den for den `leksikalt beskrevne undertype,' men jeg ændrer nok disse kaldenavne. .\,.\,Hm, ja, nej, lad mig egentligt hellere bare kalde denne undertype (som der er fire udgaver af for hver ikke-data-type) for den `simple undertype,' simpelthen. (20:38)

(20.02.23, 14:17) Jeg har overvejet nogle ting i dag omkring kategorier (også i går aftes) og ``koncepter'' (bare i dag), og nu er jeg så lige kommet på en idé, der muligvis kan løse de ting, jeg gerne vil løse, på en elegant måde (set fra det grundlæggende (database-)lag). Idéen er at starte med at give de ikke-simple entiteter en liste af relationer efterfulgt af en liste af lister, hvor hver liste så i denne liste liste så skal inputtes som relationsobjekt i den relevante relation fra den første liste (og hvor den nyoprettede entitet så bliver relationssubjektet). Hm, og så kunne man i øvrigt stadigvæk dele det op vertikalt i kategoriserende felt-input og specificerende felt-input.\,. .\,.\,Nå nej, det behøver jeg nok ikke, når nu jeg forestiller mig, at brugerne skal gøre stort brug af kategorier (hvad de skal!\,.\,.), for så bør en specifik (under-)kategori gerne indeholde al den relevante information, som jeg før nu her ellers har tænkt mig, at ``cpreds''-listen skulle indeholde. .\,.\,Ah, men vil det så sige, at en kategori (Category) også gerne selv skal indeholde information om den ønskede srel-liste?\,.\,. 
\ldots Hm, det ville være ret smart, hvis man kunne gøre det sådan, men problemet bliver jo muligvis, at det så bliver svært at ændre dette.\,. .\,.\,Hm, medmindre man måske tilføjede en grundlæggende relation til kategorier a la ``.OptionalField:''.\,. .\,.\,Hm, men alternativt kunne man så i stedet have ``.Field:'' (hvor felt-relationerne så rates ud fra vigtighed), altså i stedet for at gøre dette til en indre, fast ting i hver kategori.\,. Hm, ja, mon ikke det bliver svaret, og så er det bare spørgsmålet, om man ikke så kan gøre de ikke-simple entiteters input mere simpelt.\,.\,? 

.\,.\,Lad os se, måske kan man så erstatte cpred-listen med kategorier.\,. tja, lad mig bare tage én ting ad gangen. Så de ikke-simple entiteter kan have en liste af kategorier for det første, hvor relationen ``belongs to''/``.Category:'' er underforstået.\,. Herefter skal der så komme en liste med.\,. hm, ja, det bliver jo så en liste af prædikater, men disse prædikater dannes så automatisk af applikationen (i ``applikationslaget'') ud fra brugerens input til diverse felter, hvilket så kan deles op i beskrivende felter og datafelter (og som hver især tildeles en `vigtighed' via brugerratings (som brugere giver i forbindelse med den relevante kategori)). Hvis entiteten tildeles mere end én kategori, så loades alle relevante felter bare fra alle kategorierne (og ordnes stadig efter `vigtighed,' men måske opdelt i grupper af kategori alligevel). Bemærk i øvrigt, at et ``felt'' defineres af en relation, så felter kan nemt gå igen på tværs af kategorier. Nå ja, og en stor pointe ved at bruge `kategorier' er, at de hver især kender deres egne overkategorier, og dermed kan (og skal!) de også loade alle felter fra overkategorien.\,. Hm, men måske skal man så også kunne fjerne felter fra en overkategori igen ved at nedstemme dem.\. nej.\,.\,! For ressourcer vist i en inderkategori skal også kunne vises i en overkategori, så alle felter fra en over-/forælder-kategori skal arves til underkategorierne!\,. Ok, så langt, så godt. Nu kommer jeg så til, hvad der ellers kunne være af nyttige relationer udover ``.Category:'', som man kunne benytte, når man opretter nye ikke-simple entiteter.\,. (15:18)

.\,.\,(15:22) Hm, jeg tror faktisk allerede, jeg har en rigtig god idé om, hvad den muligvis sidste relation kunne være udover ``.Category:''/``belongs to''. Og nu har jeg i øvrigt også lige fundet ud af, at jeg hellere bør kalde relationen for ``belongs to'' end ``.Category:,'' og det kommer jeg nemlig til om to sekunder. Jeg tror den muligvis sidste relation skal være ``is related to''. Og fælles for ``belongs to'' of ``is related to'' er, at de er beregnet til (i hvert fald som en af deres primære opgaver) at udgøre en barne-liste-/barne-kolonne-mulighed i relationsobjektet, som i disse to tilfælde enten er en kategori (som entiteten tilhører) eller en term --- og jeg tror nemlig, at jeg vil gå tilbage til at kalde det Terms --- (som entiteten er relateret til). Dette er så i modsætning til alle ``felterne,'' hvilke er beregnet til at angive ting, der er interessante at få vist, når man er på (har selekteret) entiteten. (Og for lige at præcisere, så er altså i modsætning til det andet, for ``belongs to'' og ``is related to'' handler nemlig om at føje ting til henholdsvis kategorien eller termen (nemlig under særlige underfaner, som henholdsvis kunne hedde `Subcategories' og .\,.\,`$<$type$>$s related to this $<$type of this entity$>$''), når brugeren har selekteret denne kategori/dette term.\,.).\,. Hov, der kunne nu måske godt være en ``is related to'' for hver ikke-data-type. Og måske skulle jeg så droppe den konvention, som jeg skulle til at foreslå, hvad angår ``.Category:'' vs.\ ``belongs to'', hvilket nemlig var at bruge førstnævnte syntaks udelukkende for felter, for det virker til at den også kan blive gavnlig for relationer. (For så kan man nemlig passende opdele ``is related to'' i: ``.RelatedTerm:'', ``.RelatedPredicate:''.\,. hm.\,.) 

Okay, virker umiddelbart som nogle gode standarder, men jeg tror lige, jeg må tænke lidt over de her ``Concepts'' (altså muligvis en `koncept'-type), som jeg har tænkt over i dag\ldots\ (15:45) .\,.\,Ah, men er hele pointen ikke bare, at man så nu bare kan indføre Koncepter, som en overkategori af Termer, og for nyoprettede prædikater og relationer, kan man så føje sådanne koncepter til som relationsobjekter i relationen, ``.RelatedTerm:'' (som så i virkeligheden næsten ligeså godt kunne hedde ``.RelatedConcept:'' i stedet.\,.).\,.(?) (15:51) .\,.\,Tjo, tja.\,. Hm, måske skulle man bare sige, at de to første inputs er en liste af kategorier og en liste med (specificerende) prædikater, men at vi derefter så har et tredje (optionelt) input .\,.(som muligvis kan deles op i to), som består af en liste af først en relationsliste (hvor man så kan have ``.Related[...]:''-agtige relationer), og derefter en liste af inputlister, hvor hver af disse input lister så gives til den relevante relation. Hm, det lyder umiddelbart lidt kompliceret, men det kunne måske give god mening sådan.\,. (15:56, 20.02.23) 

.\,.\,Og lige for at præcisere: Jo, så `koncepter' bliver bare en underkategori af Terms. Ah, jeg tror faktisk, at jeg virkeligt er nået til et fornuftigt punkt her.\,:) 

\ldots Ah, på når lige, at det måske ville give mere mening bare at implementere dette tredje input (inkl.\ funktionaliteten omkring det) udelukkende i applikationslaget.\,. (16:15) .\,.\,Hm, man kunne også gøre det, at man rigtig nok implementerer det i applikationslaget, men at man så bare også giver mulighed for, at brugeren kan vælge at inkludere de resulterende prædikater dannet ud fra dette ``tredje input'' i specifikationsprædikat-listen. Ja, ok, så fordi der jo er den mulighed, så er der ingen grund til ikke at gøre det sådan. Så lad os sige, at ``tredje input'' bliver implementeret i applikationslaget, og at ikke-simple entiteter så i databaselaget derfor bare kommer til at have to input-felter, nemlig en kategori-liste og en specifikationsprædikat-liste.\,:) (16:21, 20.02.23)

\ldots (17:01) Ah, nu ved jeg det. Endnu bedre: Der skal bare være ét felt for de undertyper, jeg førhen har kaldt DescribedEntities (og som jeg til tider i dag har kaldt de ikke-simple undertyper), nemlig et felt bestående rent af prædikater. Og så implementeres resten simpelthen i applikationslages. De første prædikater i denne liste vil så typisk bare være (et fåtal af (ofte bare én!)) ``belongs to $<$category$>$''-/``.Category:$<$category$>$''-prædikater. Og nu hvor jeg nemlig tænker, at underkategorier skal kende deres egne overkategorier, så er det nemlig ofte tilstrækkeligt kun at give én kategori. Og dermed behøver jeg altså ikke længere at tænke i at separere den ``kategoriserende del'' fra den ``specificerende del'' af inputtet, for den ``kategoriserende del'' vil nu typisk kunne klares med meget få (ofte bare ét) prædikater. Nice, nice.\,:) (17:09, 20.02.23)

(18:34) Okay, jeg tror så faktisk også, at jeg går tilbage til at gøre det utypet i det grundlæggende lag igen, når det kommer til ikke-data-entiteter --- og selv endda for prædi-kater (så jeg fjerne Predicates-typen igen) --- således at ikke-data-entiteter udelukkende gives typer på semantisk vis. Jeg tror så, jeg vil lave tre ikke-data-entitets-undertyper: Den ``simple'' som beskrives ud fra et `lexical item' og en `description' (valgfri), ``prædikat-beskrevne entiteter'' som altså beskrives ud fra én prædikatliste, og som den tredje undertype ``sammensatte entiteter,'' som jeg så egentligt kun har i sinde at bruge lige netop til at danne prædikater ud fra en eksisterende relation og et relationsobjekt. .\,.\,Hm, skal jeg så prøve at sørge for, at der kan blive en tabel eller et view med alle entiteter på én gang.\,. eller måske bare alle ikke-liste-entiteter.\,.\,? .\,.\,Hm, hvis vi tager alle ikke-liste-entiteterne, nemlig Users, Statements (ikke SemanticInputs), de tre typer ``ikke-data-(ikke-bruger-eller-udsagn)-entiteterne,'' samt resten af ikke-liste-datatyperne, så har de jo alle samme højst to inputs.\,. Og hvis tekst- og binær-typerne bare får en reference til en underlæggende datatype --- som man måske så ikke kan se i interfacet med applikationslaget (når man ser fra applikationslaget) --- så kunne dette altså nok godt lade sig gøre.\,. Hm.\,. (18:54) .\,.\,Hm, og hvis alle bare er i samme tabel, nemlig en tabel (altså en databaserelation) over alle entiteter (og lister og semantiske inputs regnes altså så ikke for entiteter .\,.\,hm, jeg kunne også kalde dem units i øvrigt.\,.), så sparer vi vist også noget plads, for så behøver hver entitet(/``enhed'') nemlig kun at holde én TINYINT, nemlig den der beskriver entitetens egen (entitets)type, i stedet for at skulle holde TINYINTs for alle input-tabelkolonner. Ja, jeg tror faktisk, at det bliver det her, jeg gør.\,. men jeg kan så lige se på, om SQL har en måde at forene søjler på (det har det sikkert), og i så fald kan jeg jo godt lave.\,. Hm, nej, jeg tænkte at lave alle tabellerne for sig også, og så oprette den samlede entitetstabel som et view, men så går det ikke, hvis hver underliggende tabel kan have kollisioner imellem ID'erne.\,. .\,.\,Lad mig lige skifte paragraf i øvrigt.\,. (19:04)

.\,.\,Hm, en mulig løsning, hvis man gerne vil have de separate tabeller kunne dog være, at sørger for, at alle entiteter af samme type har den samme unikke række af mest betydende bits.\,. Hm.\,. .\,.\,Hm, det ville måske gøre det bedre i forhold til, hvis man kommer i risiko for at mangle long-adresser, også muligvis hvad angår muligheden for opskalering, hvis man sørger for at dele typerne op, så lad mig lige tænke lidt over det.\,. .\,.\,Hm, atten milliarder milliarder.\,. .\,.\,Ja, så vi kommer ikke til at mangle long-addresser.\,. .\,.\,Okay, jamen så lad mig sige.\,. Tja, hm.\,. .\,.\,Jo. Jeg har lige tjekket, at man godt kan forene (med alias og union) tabeller i SQL, og ja, jeg har lyst til at beholde en tabel for hver entitetstype og så bare forene dem til én samlet i et (såkaldt) view. Og jeg vil så sørge for at deres ID'er ikke kolliderer simpelthen bare ved at starte fra hver deres mest betydende byte (gerne med så mange 0'er på de mindst betydende bits i denne byte som muligt, hvorfor ikke?\,.). Dermed kan ID'erne overføres direkte as is til det samlede view, og dermed for vi altså heller ikke behov for nogen TINYINT-typeflag overhovedet på denne måde. Fint (fedt)!\,.\,.\,:) (19:28)

(21:23) (Nu hvor det grundlæggende er utypet, så bliver Russull-paradokset vist heller ikke noget problem overhovedet, \emph{hvis} altså det overhovedet ville være det i den typede udgave, det er jeg ikke helt sikker på alligevel. Men det er også ligemeget.)

(21.02.23, 10:18) Ej, jeg fik så mange gode idéer i går aftes. Jeg vil lige skrive et par af dem her, og så vil jeg gå ned og skrive resten i forlængelse af den næste sektion. Lad mig nævne her, at lister, ligesom tekster, også bør være med som (førsteklassesborger-)entiteter. Dermed skal der også bare være én listetype, der så bare holder en længe og en underlæggende liste (som ikke er i en tabel som kan ses i interfacet med applikationen). Og så skal brugerne i stedet bare kunne bede serveren om at get'e alle eller en andel af alle elementerne i den liste (som så sendes til applikationen), og så kan applikationen videre finde d af, hvad dem vil med disse. 

Angående om brugere og semantiske inputs skal regnes for entiteter: Tja, måske ikke i starten (første version/betaversionen), men jeg bør alligevel sørge for at deres ID'er ikke kolliderer med resten, hvis nu de på et tidspunkt skal gøres til entiteter. Og hvis de på det tidspunkt holder for meget data i sig (i deres ``tabelrækker''), så kan man jo bare gøre noget tilsvarende, hvor man lader dem holde en reference til resten af deres data (enten i form af en reference til en privat tabel eller i form af en reference til en liste-entitet). 

Men en af de klart største idéer, jeg fik i går aftes, var omkring, at jeg skal væk fra det med at sende SQL-kommandoer fra applikation til serveren, for jeg skal i stedet implementere, hvad der svarer lidt til det QL, jeg havde tænkt på, men hvor queries'ne simpelthen specificeres i HTML-attributterne! Så skal applikationen læse disse attributter, som eksempelvis kunne være nogle a la: querySubjekt=$<$entity ID$>$, queryRelation=$<$entity ID$>$, queryObject="get", askUsers=$<$``user group'' arithmetric expression$>$, numberOfElementsToGet= $<$number$>$, maxDateForInput=$<$date$>$, filters=$<$list of references to filters to use --- possibly in the shape of HTML div IDs where filter data (predicate IDs and parameter values) --- can be found$>$, allowedHRefs=$<$list of references to allowed hrefs --- also possibly in the shape of div IDs$>$.\,. Applikation skal så læse alt dette, men \emph{ikke} sende det direkte til serveren! I stedet skal det bare sende mere simple quries, hvor de kun lige er de første tre attributes her i denne liste, der bliver brugt plus lige en enkelt bruger --- eller brugergruppe, hvis databasen er begyndt at indeholde sådanne (for det emne skal jeg nemlig også lige genoverveje). Applikationen sender så bare flere af disse queries af sted til serveren, hvor den måske bare spørger om 100 eller deromkring elementer ad gangen, hvad ved jeg (på stående fod)?\,. Og så sætter applikationen selv de lister, den får (med tilhørende ratings fra spurgte bruger/brugergruppe), sammen til den endelige liste, som så skal blive til den liste af entiteter, som brugeren skal se i sidste ende. Herefter kan den så begynde (via AJAX) at bede serveren om at få serveret indhold omkring disse entiteter, hvilket jo så typisk vil ske ved at query'e hver enkelt element i listen efter nogle relationsobjekter. Og dette kan så også forgå på sammen måde, for applikationen starter jo så bare med at generere den HTML, der skal være omkring indholdet i hvert element, og de forskellige divs i denne HTML kan jo så også bare få qeury-attributter sat, sådan at applikation efterfølgende kan læse disse (i rækkefølge én ad gangen i listen) og så (via AJAX) query'e serveren for indhold til hver enkelt indholds-div i dem.\,!\,:) 

Bemærk derfor, at brugere der ombygger applikationen for sig selv og andre brugere, de behøver derfor kun at dele HTML og CSS med hinanden. Jeg kan altså derfor udelukke al JavaScript (mener jeg), når det kommer til applikationsudvidelser delt mellem brugere internt igennem sem-netværket. :) 

Nå, jeg har nogle flere ting fra i går aftes, jeg gerne vil sige, men da de relaterer sig meget til applikationslaget specifikt, så lad mig gå ned i næste sektion (som i skrivende stund kun har to paragrafer) og skrive idéerne der. Og hvis jeg finder på flere ændringer til det grundlæggende lag, så vil jeg nok bare oprette en ny sektion at skrive det i den (for jeg kan mærke, at der er for mange afhængigheder i det på tværs af lagene, så jeg ender nok bare med at skrive alle nye idéer i kronologisk rækkefølge alligevel.\,.). Ok.\,:) (11:09, 21.02.23)

(13:21) Nå, nu kommer jeg alligevel tilbage til denne sektion og tilføjer følgende: Ved at sørge for at compound predicates får deres eget most significant byte i deres ID'er, så ved man altid, når man har et prædikat i hånden, om det er et (sammensat) relationsprædikat eller ej. Og derfor kan man godt omdanne SemanticInputs, hvis man vil, så at der igen bliver en prædikat--relationskolonne (hvor prædikaterne så \emph{ikke} må være sammensatte prædikater), og endnu en kolonne med eventuelt (nullable) input, hvis prædikat--relationsentiteten i førstnævnte kolonne er en relation. Og når en bruger vil rate et sammensat prædikat, jamen så gives der bare én rating, nemlig til det samentiske input med relationen i. .\,.\,Hm, og måske bliver det faktisk nemmere alt i alt at implementere gennemsnittet via en bot-bruger. Og så kan control serveren bare løbende bede databasen om at opdatere ratingværdien (samt dato) for dette semantiske input. .\,.\,Hm, og selvom dette egentligt hører til i næste sektion, hvis vi snakker om betaversionen, så lad mig da bare sige, at hver bruger bare har én rating pr.\ prædikat, og at man altså ikke gemmer gamle ratings. For jeg regner jo alligevel ikke med at implementere den der ``maxDateForInput=$<$date$>$''-mulighed i betaversionen. Og det forøger også kun anonymiteten, at gamle rating (og tidspunkter) ikke bliver gemt. Og ja, lad mig så nemlig også bare undlade at gemme datoer (eller dato-tider for den sags skyld) for semantiske inputs i betaversionen. (13:34)

.\,.\,Ah, og så skal nøglen til semantiske inputs faktisk bare være bruger, predikat/realtion og (nullable) relationsobjekt (altså alle sammen ID'er), for hermed bliver dette jo unikt for hvert semantisk input! (13:42) (Og hvis man bruge automatisk voksende tal som ID'er, så vil disse ID'er jo kunne afsløre tidspunket alligevel, hvis de alle sammen er synlige oppe i applikationslaget.) .\,.\,Og fordi jeg er ret overbevist om, at SemanticInputs aldrig skal være med som førsteklassesborger-entiteter --- om så de bliver synlige for applikationen eller ej --- så er der altså ikke nogen risiko ved at bryde mønstret med at bruge BIGINTs som ID'er. *(Hov, jeg skulle selvfølgelig have sagt `relations\emph{subjekt}' i stedet for `objekt,' det er klart. I øvrigt tænker jeg, at denne sammensatte nøgle så nok skal ordnes efter subjekt først, så bruger, og så relation/prædikat-entitet. (18:13)) 





\section{Mål for betaversionen}

(15:35, 16.02.23) Okay, helt kort vil jeg bare lige skrive lidt om, at jeg nu forestiller mig, at der i en undermenu af fold-ud(men muligvis konstant ude, hvis vinduet er stort nok)-menuen skal være følgende ``over-kategorier,'' som man kan trykke på og få vist en liste til højre for. Der skal være ``populære (så altså ordnet efter popularitet) term-kategorier,'' ``populære prædikat-kategorier,'' ``populære relations-kategorier'' og ``populære prædikater'' (ikke prædikat-kategorier men simpelthen bare prædikater straight up).\,. Det kan være, jeg finder på / kommer i tanke om flere.\,. I listevisningerne for alle disse skal der selvfølgelig altså være en popularitetsrating, så man kan up- eller down-rate entiteten på den pågældende liste. For alle kategorier skal der så også være en knap til at få en ny kolonne med underkategorier og en knap til at få en kolonne med entiteter inden for den kategori (som også bare ordnes efter popularitet --- eller faktisk rettere efter usefulness --- som en standard ting).\,. .\,.\,Hm, jeg vil stadigvæk have det sådan, at man også skal kunne klikke på en vilkårlig entitet og tilføje den til sit ``arbejdsbord.'' Og nu tænker jeg nemlig så (og dette er en af de ting, jeg specielt gerne ville nævne), at dette arbejdsbord simpelthen bare skal være en XML/HTML struktur, som brugeren er fri til at redigere (og hvor en ny redigering så kan flushes til den private database). Og i al sin enkelthed skal denne XML/HTML-struktur så bare indeholde en række variabel-definitioner, hvor brugeren giver variabelnavne til alverdens entitets-ID'er --- og hvor strukturen altså i første omgang ikke er betydende for andet end brugeren selv, idet denne så skal kunne implodere og eksplodere tags i editoren. Men strukturen må gerne følge en standard, der så gør at applikationen automatisk kan indsætte nye variabeldefinitioner i denne struktur (og på en passede plads), når brugeren klikker `gem til arbejdsbord' på en entitet vist i en liste. 

.\,.\,Hm ja, og lad mig ikke sige så meget mere i denne omgang, for nu fik jeg nævnt alle de ting, jeg gerne ville skrive om. Når jeg så bygger på min prototype, så kan jeg tilføje flere ting omkring, hvad jeg gerne vil sigte mod i starten. (15:56)


(11:47, 21.02.23) Okay, det kan være, at jeg egentligt fik sagt det meste (og det vigtigste) ovenfor i forrige sektion. Jeg har også en lille idé om, at ``fold-ud-menuen fra venstre'' måske bare skal være en kolonne-/søjletype i stedet i applikationen, som altså så kan foldes ud fra alle andre søjler. For så kan man også nemt folde denne søjle ud i overlayet, når man besøger andre hjemmesider (med visse genkendelige URL'er). Det overlay forestiller jeg mig jo skal kunne foldes ud fra højre i form af en søjle, og hvis brugeren så bare kan folde, hvad jeg før så som ``fold-ud-menuen,'' ud til venstre for denne søjle, så kunne overlayet jo komme rigtig godt og nemt fra start herved. Og så kan man jo også bare folde andre søjletyper ud ad libitum fra den indledende søjle i overlayet. .\,.\,Ah, og hvis man så designer enkeltressource-søjlen, så den selv kan genkende, om den.\,. Tja, ellers hvis bare man laver en speciel søjle til overlayet (som jo selvfølelig skal kende URL'en for hjemmesiden), .\,. Ja.\,. Jeg har faktisk ikke mere at sige om det, for ja, man laver bare overlayet som en speciel søjletype til formålet, som så kender til den nuværende URL, og som så bare er specielt beregnet til at fungere på andre hjemmesider.\,. Ah, men vent. En første udgave af overlayet kunne jo bare være at bruge den normale enkeltressource-søjle! Dette er ikke den optimale løsning, men så er man til gengæld nemt fra start, og brugerne vil så derfra have incitamentet til selv at lave/forbedre den indledende overlay-søjle. Fedt nok, og hermed vil jeg altså nok bare nøjes med at bruge den normale enkeltentitetssøjle, som benyttes på hjemmesiden, som den indledende søjle i overlayet. :) .\,.\,Hov nej, man vil jo sikkert også gerne have en ratingsøjle, der tager udgangspunkt i en specifik ressource (og hvor titlen for entiteten så kan vises i toppen af søjlen). Så det er selvfølgelig bare \emph{den} søjletype, som jeg skal gøre til den indledende søjle i overlayet. Og så kan brugerne så også trykke sig fra den søjle og hen til den normale enkeltentitetssøjle, hvis de vil det, så ja, dette vil være et rigtigt godt udgangspunkt i overlayet. (12:05)

.\,.\,Lad mig lige prøve at finde frem til noget omkring optimering af database-queries.\,. 
\ldots Hm, har lige læst en smule om clustered indexes, og vil også læse lidt mere, men jeg tror allerede jeg kan svare på noget, som jeg også tænkte på i går aftes, nemlig om ikke bare jeg skulle nøjes med altid at lave relationsobjektet være det, som skal get'es i en query i betaversionen (altså sådan at queryObject="get" altid er underforstået). Det vil nok sige, og så bliver det bare applikationens opgave at sørge for, at ``belongs to''- og ``is related to''-relationerne altid uploades både forlæns og.\,. Hm, men hvad så med ratings?\,. hvad med om man i stedet lavede en slags ``virtuel \ldots''.\,. tja, eller også kunne det også bare være applikations opgave også at sørge for, at ratings af prædikater med de relationer i sig altid bliver givet identisk to steder.\,. Hm, det må jeg jo lige tænke over. Men lad mig lige læse videre.\,. (12:39)

\ldots\ (17:56) Okay, jeg har læst lidt, og blevet en smule klogere. Det korte af det lange er bare, at jeg på et tidspunkt nok skal oprette en partitioning af SemanticInput-indexet --- med flere partitions særligt for DescribedEntities.\,. Hm, måske kan jeg endda faktisk lave det specifikt for Term-entities, selvom jeg nu ikke længere har denne type forskel, for selvom alle entiteter (altså hvad jeg lidt ser som ``semantiske entiteter'') har den samme type i princippet, så kan jeg jo godt give dem forskellige mest betydende bytes, således at man i praksis kommer til at kunne kende forskel på deres under typer (og f.eks.\ i forbindelse med en partitionisering).\,. .\,.\,Men ja, og det er rigtig godt (og fornuftigt), at jeg nu gør databaseimplementationen skjult i (interfacet med) applikationslaget (for jeg har nemlig også i sinde at insert også bare skal beskrives i et JSON-format, eller noget i den stil). For det gør, at jeg også har mulighed for selv at eksperimentere med andre databasetyper, hvis jeg nu f.eks.\ finder ud af, at hierarkiske databaser i virkeligheden er bedre egnet til formålet (hvad måske ikke lyder helt tosset.\,.). 

.\,.\,Nå, men noget andet jeg lige skal overveje, som jeg kom i tanke om, imens jeg skrev forrige paragraf her, er at jeg lige skal genoverveje.\,. Hov nej, never mind.\,. Ja, eller ikke never mind, for måske har jeg en tilføjelse, men det kan være, at det bliver en lille en.\,. (18:08) .\,.\,Okay, jeg har lige lavet en tilføjelse til forrige sektion. (18:13) Og tanken om at ordne den sammensatte nøgle efter subjekt først, så bruger, og så relation/prædikat-entitet, er en jeg fik tidligere i dag i øvrigt. Og som jeg forestiller mig applikationen nu, så tror jeg virkeligt langt de fleste queries kommer til at tage udgangspunkt i ét subjekt ad gangen, hvortil man så for et fåtal af forskellige brugere/bots spørger efter nogle prædikater og relationer (og muligvis nogle forskellige for hver bruger), og hvor man så for hver prædikat bare henter en rating og for hver relation henter én eller flere af de elementer, der er rates højest af pågældende bruger/bot. Så dermed tror jeg altså, at langt de fleste queries fra brugerne i almindelighed vil blive super effektive at eksekvere (hvis vi altså ordner indexet på lige præcis denne måde)!\,:) (18:21)

.\,.\,Nå ja, og så skal det endda siges, at jeg i første version af sem-netværket/hjemmesiden nok bare vil (starte med at) have det sådan, at brugerne altid bare ``spørger'' avg-botten om gennemsnittet og antallet af ratings. Og så kan jeg altid udvide derfra. (For eksempel kunne en af de første tilføjelser være at brugerne også kan query'e deres egne ratings, hvilket man så kan forestille sig typisk vil blive brugt således at brugerens egen rating trumfer avg-bot-ratingen.) :) (18:25) 

\ldots Hov, det kan forresten også godt være, at det kan give mening ikke at have rela-tion/prædikat-entiteten med i det her composite clustered index, hvis man altså overhovedet kan vælge det, når nu denne tabelkolonne \emph{er} med i den primære nøgle.\,. Hm.\,. 

\ldots Ah, nu kom jeg lige på, gad vide om ikke, der kunne være en måde at sørger for, at hver subjekt--bruger--prædilation( fik jeg lige lyst til at kalde det)-række får én reference.\,. Tja eller rettere: Hver subjekt--bruger--prædikat-række får en rating værdi som den eneste ikke-nøgle-kolonne, og hver subjekt--bruger--relations-række for så i stedet.\,. hm, hvad med at de får, et fåtal, måske bare én eller to, entitets-ID'er, som så skal være det/dem, brugeren har ratet højest for pågældende relation, og derefter kan i sidste ende så være en liste med andre entitet--rating-par (ja, for man skal forresten også have ratingen in-line/on-page i rækken for hver relationsobjekt man har in-line/on-page i rækken.\,.).\,. (19:02) .\,.\,Ah, eller man kunne også slutte med to ting: først en VARBINARY, som inkluderer et antal entitets-ID--ratingværdi-talpar mellem 0 og et lille tal såsom.\,. hov, nej, det skal måske ikke være et lille tal.\,. Men ja, dette kunne man gøre, og så eventuelt slutte af med en nullable BLOB eller større VARBINARY, som man så ved bliver gemt off-page fra tabellen.\,. Hm, nu kommer så et oplagt spørgsmål i forlængelse af dette, for det kunne jo så også være, at man i stedet skal dele SemanticInputs op i tre tabeller, nemlig én med prædikater og.\,. Tja.\,. .\,.\,Hm, tanken var at dele det op i.\,. Ah, jo! Og så kunne man lave et samlet indexed view over alle tre tabeller!! (19:13) .\,.\,Tja, og dog; det gør det vel egenligt ikke meget anderledes fra, end hvis man laver én indexed tabel.\,. Hm, men jeg hælder nu altså meget til det der med den der VARBINAY til, hvad vi kunne kalde `.:'-relationerne (altså de relation, hvor man forventer meget.\,.).\,. Ah, men vent, bliver det ikke nærmest kun den omvendte ``belongs to''-relation, og den/de omvendte ``is related to''-relationer, der kommer til at få mange relationsobjekter pr.\ bruger/bot, som jeg tænker mig at betaversionen skal fungere.\,.\,? .\,.\,Hm, jo, men det ændrer faktisk muligvis ikke på, at det med den der nullable VARBINARY som en kollone i SemanticInputs måske kunne være ret effektiv. .\,.\,Hm, tjo ja, men måske skal man bare have to tabeller (dog ikke tre). For hvis man putter `.:'-relationerne, altså nærmere bestemt dem med mange relationsobjekter pr.\ bruger/bot, i sin egen tabel, så kan man tilgå denne, når man skal navigere videre fra den entitet/ressource, man har selekteret, hvor prædikat-og-`.='-relationerne -- og også relationer, hvor man bare forventer et fåtal af relationsobjekter pr.\ bruger.\,. måske.\,. --- så meget mere bruges i sammenhæng med, at entiteten/ressourcen enten skal placeres et sted på en entitets/ressource-liste (i en applikationssøjle), og at datafelter specifikt relateret til ressourcen skal hentes/get'es lige efter, at entiteten er blevet placeret.\,. Hm, men hvis jeg regner med, at disse to ting skal foregå i to separeret i tid efter hinanden, jamen så \emph{er} det måske en helt fin idé at dele det op i tre databasetabeller.\,.\,:) (19:31) Hm, lad mig lige tænke over det hele.\,. 

.\,.\,Hm tja, men hvem siger, at man ikke kunne have lyst til at prefetche felt-dataen, det lyder da som en meget fornuftig idé egentligt. Eller rettere, man prefetcher jo nemlig bare long-/BIGINT-adresserne på dataen, så ja, hvorfor ikke prefetche dette som standard?\,. Og så kan det jo godt være, at nogen af entiteterne bliver filtreret fra alligevel i listen, men derfor kan det jo stadig være smart, at sende den data med dem alligevel (da det jo bare drejer sig om et fåtal longs for hver ressource). Hm, jamen så kunne man måske passende dele SemanticInputs op i maximum to tabeller, sådan at prædikater og datafelt-relationer er i den samme tabel. (19:38) .\,. .\,.\,Hm, og da jeg ikke kan tro, at det vil give meget mening at prefetche elementer fra f.eks.\ underkategorier, kategorielementer eller relaterede entiteter, så vil det nu alligevel give fin mening at separere mange-objekt-relationerne over i sin egen tabel. .\,.\,Hm, men man kan nu stadig godt lave et view over alle tre tabeller, og dette kan jo så være det view, som brugerne ser (oppe fra applikationslaget af). 

.\,.\,Og ja, lige for at gentage, så er det gode jo, at applikationslaget alligevel ikke kan se, hvordan.\,. Hm, tja, medmindre at applikationslaget dog lige skal vide.\,. ja.\,. Det kan være at queries så også lige skal holde information om, hvordan man gerne vil prefetche data til ressourcerne, når man spørger efter en liste af ressourcer. Men det kan jeg jo bare sige, at sådan skal det være; brugerne skal også definere, hvordan ``felt-dataen'' hentes for hver ressource, i samme qeury som også beder om listen. .\,.\,Hov vent, men prefetching giver jo kun virkelig mening, hvis man spørger den samme bruger/bot om datafelterne, som man også spørger om listen.\,. Hm, og det kan jeg jo ikke regne med, i hvert fald ikke, hvis jeg gerne vil have det sådan.\,. ja, nej, det giver ikke mening. Det giver kun rigtigt mening at adskille det hele i tre omgange af queries (hvor den indledende query også deles op efter bruger.\,.).\,. Hov, måske er jeg faktisk helt på vildspor her. Lad mig summe over det hele, og så vende tilbage, når jeg har noget fornuftigt at sige.\,. .\,.\,Hm, men jeg kan lige sige: Det giver rigtignok slet ikke mening at tænke i at prefetche lange lister. Og dermed kan vi altså roligt sætte mange-objekt-relationer over i deres egen tabel, hvis det er.\,. .\,.\,Hm, og prædikater og få-objekt-relationer må meget gerne være i samme tabel, så så langt, så godt.\,. (20:00) 

.\,.\,Hm, og man vil nok i øvrigt også gerne have opdelte bots, så de hver varetager noget meget specifikt, og derfor vil man sikkert typisk gerne bede om alle de relationer fra en bot, som den har ratet, når først man har valgt overhovedet at bruge den.\,. 

.\,.\,Ah, okay, man skal regne med at prefetche feltdata-entitets-ID'er for alle ressourcer i sammen omgang som, at man henter prædikat-ratingværdier om ressourcerne, og dette gælder så uanset om man henter feltdata og diverse prædikater fra samme bruger, eller om man måske både henter forskelligt feltdata fra forskellige brugere(/botter) og også henter forskellige prædikat-ratinger fra forskellige bruger. Man prefetcher altså bare så meget som muligt her (men dog ikke mange-objekt-relations-data), når først man henter prædikat-data fra entiteten alligevel. .\,.\,Tja, eller måske skal brugerne i applikationslaget også kunne vælge at slå denne feltdata-prefetching fra i visse tilfælde, hvis man regner med at skulle vægte virkeligt mange ressourcer og skære dem ned til ganske få (og derfor gerne vil have hver hentning af prædikat-data til den enkelte ressource til at gå så hurtigt som overhovedet muligt). Men ja, ellers er en god sigtesnor altså, at felt-data gerne skal prefethes sammen med prædikat-dataen, når applikationen er i færd med at danne en ny liste ud fra en brugerdefineret ordning--filtrering. Og det er meget rart for mig at kunne have dette i baghovedet.\,. (20:23)

\ldots (20:37) Ah, og forresten, nu hvor jeg regner med at fylde mange-objekt-relationerne over i sin egen tabel, så giver det ikke mening det med VARBINARY'en. Jeg kan i stedet bare have én tabelrække pr.\ objekt, hvilket er meget dejligt at tænke på. 

(22.02.23, 10:18) Som jeg også tænkte på i går aftes: jeg føler ikke, at der er nogen grund nu til at putte mange-objekt-relationerne over i sin egen tabel, så. Måske især ikke.\,. ah, især ikke fordi man jo.\,. nej.\,. .\,.\,Nå, det kan man tænke over på sigt, hvordan man eventuelt kan dele det op igen for at styrke performancen, men i starten kan jeg bare have det hele i samme tabel. .\,.\,Ah, men jeg kunne måske i det mindste sørge for at give de grundlæggende mange-objekt-relationer, som jeg regner med, skal bruges meget, nogle særlige leading bytes, hvorfor ikke?\,.\,:) 

(11:51) Hm, måske giver det faktisk en smule bedre mening at have brugeren først i SemanticInput-nøglen.\,. Jeg er i øvrigt begyndt at kalde SemanticInputs for Statements bare, selvom det første er en smule mere korrekt. Men nu hvor jeg ikke har en Statement-tabel, så synes jeg alligevel det giver mening at omdøbe SemanticInputs til Statements. Og så er det bare underforstået.\,. Tja, måske ændrer jeg det faktisk tilbage, men lad mig nu se.\,.

.\,.\,Ah nej, det giver rigtignok mest mening at have subjektet først i nøglen, og især hvis man måske sørger for løbende at vedligeholde indexet, så ordnen af bruger--bots'ne forøges at holdes således, at bots der oftes bruges sidder tæt sammen i ordnen, og især hvis deres brug også er korreleret.\,:) (11:59)

.\,.\,Hm, jeg tror jeg vil kalde det for StatementInputs for nu.\,:) (12:01)

(15:46) Hm, jeg kan ikke have object=NULL i StatementInputs, hvis object skal være en del af nøglen. Nu har jeg så lavet det om så 0 er reserveret som ID til at signalerer, hvad der svarer lidt til NULL. Men problemet er så lige, at jeg ikke sparer den plads. Og nu kom jeg så til at tænke på, at det næsten er en smule synd at bruge SQL, når nu jeg bruger så mange konstante felter/kolonner så langt hen ad vejen.\,. Hm.\,. .\,.\,Hm, ja, jeg må jo lige læse om andre databaser også. .\,.\,Men lad mig nu bare lige færdiggøre SQL-implementationen først, og så også bare bruge den i starten, indtil jeg får taget mig sammen til at prøve at implementere den semantiske database i en anden type (underliggende) database.

(16:32) Ah, jeg er lige kommet i tanke om, at mit system med at bruge den mest betydende byte ikke duer, når vi skal til at inkludere data-termer såsom datetimes og longs. Så nu vil jeg i stedet lave et konstant type-flag i hver tabel, som teknisk set bliver en del af term-ID'et, hvis jeg kan.\,. \ldots\ Ja, for jeg venter bare med at indføre typeflagene til Term-viewet, hvor de så bliver virtuelle kolonner. (18:02) .\,.\,Og det bliver i øvrigt et ikke-indexed view, så formålet er med andre ord altså bare at bruge dette view i compiletime.\,. .\,.\,Hm, hvorfor jeg jo egentligt ikke behøver at lave unions på kolonnerne.\,.\,:) (18:06)

\ldots Hm, nu overvejer jeg at droppe at have dataentiteter som førsteklassesborger-termer, og så samtidigt bare sige, at det kun er object i StatementInputs, der behøver et type-flag (og dermed altså gøre, at dataentiteter kun kan indgå som relationsobjekter i udsagn).\,. (18:36)  .\,.\,Tja nej, jeg tror bare, jeg beholder det sådan her for nu (hvor alle termer bare har et typeflag, og hvor datatermer er ``førsteklassesborgere'').\,. (18:46)

\ldots\ Hm, det giver egentligt ikke rigtigt mening det jeg har gjort med at kræve at den første byte er 0x00 for ikke-data-typer, så det fjerner sikkert igen (må jeg lige gøre i morgen). Og så kan jeg lige se på, om ikke jeg også skal putte AUTO\_INCREMENT tilbage på ID'erne, det ville jo nok ikke være helt dumt.\,. (23:06)

(23.02.23) Hm, jeg kunne nok spare en masse listebygningsværk, hvis jeg i stedet for beskrivende/specificerende felter i Termerne bare har en forfatter-siger-bot.\,. Og jeg regner alligevel med at have den bot, så hvorfor ikke.\,.\,? (10:09)

\ldots Hm, så skal jeg så til at lave nogle relationer for hvert af de grundlæggende felter, men der kan jeg jo også bare bruge mine `has lex item'- og `has desciption'-relationer. Desuden vil jeg nok tilføje en relation a la  `has abbreviated lex item' som en af de grundlæggende, så der bliver tre.\,. (10:24) .\,.\,Og jeg regner forresten stadig med at beholde type-flaget, og så kan jeg dermed også overveje, om jeg gider at slæbe rundt med en masse `.Type='-relationer også, eller om det bare skal være underforstået.\,. Tja, jeg kunne vel godt have dem med, men.\,. Tja, og dog.\,. 

(10:42) Jeg overvejer at lave ratingværdien om til en var-binær i stedet.\,. \ldots (10:53) Ja, lad det være sådan. Men det skal så stadig være sådan, at hvis man højre-shifter den ned til en int (eller en long), så skal man stadig aflæse midtpunkts-/gennemsnitsværdien, i hvert fald hvad brugernes ratings angår. 

Hm, jeg tror faktisk jeg vil beholde en SimpleTerms-tabel, men så omdøbe den til FundamentalTerms.\,. *(Har nu døbt den tilbage.\,. *Hm, men jeg skifter nu nok tilbage igen.\,.) .\,.\,Hm, jeg overvejede lige kort at skifte tilbage til at kalde det Entities, men man skal faktisk i stedet bare se prædikater og relationer mere som henholdsvis mængde og mængdelære-relationer, hvis man ser på det matematisk *(/formel-logisk). Og så er det først i udsagn-inputsne.\,. som jeg næsten kunne omdøbe tilbage til `semantiske inputs'.\,. at prædikat-mængderne og relations-mængderne bliver vakt til live og bliver fortolket som faktisk prædikater og relationer. .\,.\,Nå, men pointen omkring at have en FundamentalTerms-tabel er så, at denne så kan være ret kort, og at brugerne fra applikationslaget så bare kan hente den hele på én gang, nemlig på en måde, der adskiller sig fra, hvordan brugerne henter ting på normal vis (nemlig via opslag i SemanticInputs-tabellen). 

.\,.\,(11:28) Ah, på den anden side, hvad angår Term vs.\ Entities, så får vi jo nu et ret begrænset antal typer, så.\,. Hov nej, never mind! For prædikater og relationer får jo ikke sin egen type alligevel, så nu handler typerne egentligt bare om at skelne.\,. Nå ja, vent, typerne bliver helt de samme, som de lige var; jeg ændrer ikke i dem.\,. Spørgsmålet er, om jeg skulle blande ``simple'' og ``standard'' terms sammen til én type, men det tror jeg faktisk heller ikke alligevel. 

\ldots\ Hm, angående ratingværdien: det kunne også være, at man skulle dele det op i først en int (eller long), der beskriver ratingen, og så have var-binær-strengen bagefter.\,. (16:05) .\,.\,Ja, lad mig helt klart sige det.\,. 

\ldots Hm, jeg bør måske også beholde RelationalPredicates-tabellen også.\,. (16:27)

%Jeg skrev på et tidspunkt "id <= 0x0011111111111111," men det skulle jo self. have været "id <= 0x00FFF..." i stedet.

(24.02.23, 10:09) Jeg vil faktisk gå tilbage til kun at have en BIGINT som id til hver entitet, og så vil jeg lade serveren og databasen om.\,. Hm vent, eller skulle jeg ikke bare sætte start-værdien til noget forskelligt for.\,. tja, men hvem siger, at jeg får tabeller for hver type.\,. .\,.\,Hm, lad mig egentligt også lige læse lidt mere om indexes.\,. \ldots Ah, ``B-træer,'' og hvor man giver plads imellem inserts på pages'ne, indtil der er fyldt op: Lyder ret nice.\,. (10:22)


(15:52, 25.02.23) Hm, jeg kan forsten lige nævne, at jeg nu tænker at inkludere en `created\_at'/`updated\_at'-dato i SemanticInputs, som så altså bare \emph{ikke} inkluderer tiden (men kun datoen). Og nu kom jeg så lige til at tænke på, at man eventuelt kunne gøre denne dato til den sidste del af nøglen (den primære), for på den måde kunne man jo netop åbne op for, at brugere og bots kan få deres gamle ratings gemt (hvilket nemlig kan være gavnligt, hvis nu man eksempelvis mister tillid til en brugergruppe, men gerne stadig vil benytte dens gamle vurderinger). 

(18:32) Jeg tror heller, jeg vil lægge op til en ``.$<$abbr lex item$>$:''-syntaks i stedet for ``.$<$abbr lex item$>$='', for jeg regner lidt med, at MySQL FULLTEXT search også ser `:' som et whitespace, ligesom den vist gør for `.'. 
.\,.\,Tja, på den anden side, så kan man jo også søge på starten af ord, så måske er det faktisk ligefrem at foretrække at bruge `=', hvis den ser `=' som en del af ordet. Ja, så lad mig da bare skifte tilbage til `=', for det kan vel i så fald ikke skade.\,. (18:39)

(19:22) Hvis en bruger føjer noget til en kategori (i.e.\ rater noget med den som subjekt), som brugeren ikke selv har ratet som en underkategori af nogen kategori, så bør applikationen helt klart spørge brugeren, om ikke de vil rate kategorien som en underkategori af noget (sådan at brugeren kan få gavn af kategori-systemet, bl.a.\ til at få vist forslag til prædikater fra forælderkategorierne og mere).\,:) 

(19:48) Tror i øvrigt bare, jeg bruger local storage til ``arbejdsbordet.'' 

(20:03) Man kan selv definere sine egne full-text stopwords, så det er jo dejligt. Jeg tror i øvrigt muligvis jeg vil gå væk fra at udskifte `has' med `.'.\,. Det overvejer jeg i hvert fald.\,. Og så tænker jeg nemlig også at indlede lex items med en parentes med subjekt-typen i (for relationer og for prædikater), og ende dem med en parentes med objekt-typen, hvis vi snakker en relation.

(20:15) Jeg tænker forresten bare, at der skal være en separat søge-søjle (i applikationen). Og når man så vælger en term fra søgningen, så tilføjer man jo bare denne til arbejdsbordet. .\,.,Alle lister, der figurerer rundtomkring i diverse søjler (.\,.\,ja, bortset fra f.eks.\ søge-søjlens søgeresultats-liste.\,.), skal så have en `tilføj term' knap, hvor man kan tilføje en term fra sit arbejdsbord.

Brugere skal også kunne gemme nye inserts/uploads, de arbejder på (bare i local storage). Dette kan bl.a.\ bruges til, hvis de lige vil bruge noget tid på at finde flere termer, som den nye term skal relateres til. (20:31) I øvrigt kan det også være, at de skal kunne åbne en allerede uploadet term igen for så at lave ændringer og nye tilføjelser i den (i hvert fald på sigt.\,.). 

(20:43) Hm, jeg tror så, jeg vil droppe ``full lexical item,'' og så bliver ``abbreviated lexical item'' jo bare konsekvent til ``lexical item.'' 

(21:58) Hm, det kan være, at jeg også skal lave en `prædikater relevant for denne kategori er også relevant for:'-relation, hvor det så er denne, der gør at kategorier kan arve prædikatforslag fra andre kategorier, og hvor denne relation så pr.\ standard opvurderes, når brugeren opvurderer `.subcategory='-relationen (men hvor denne anden relation så gerne skal vises under, så brugeren slev kan indstille vurderingen væk fra standard-opvurderings-værdien (som måske i øvrigt bare er at give relationen selvsamme rating, som `.subcategory='-relationen fik.\,.)).\,. 

(22:42) Der kan også være et (mere konstant) ``arbejdsbord'' vandret i toppen med brugere/bots/brugergrupper (som (sidstnævnte) altså også er implementeret via bots), hvor brugeren kan skifte mellem, hvilken bruger/bot bliver spurgt i alle efterfølgende queries (indtil brugeren skifter igen). I øvrigt tænkte jeg også lige på, at man måske kunne lave et særligt `(brugerkategori) bør få oprettet en brugergruppe-bot til sig''-prædikat, hvor serveren så kan sætte (og løbende justere) en tærskel for, hvor mange brugere skal have opratet dette prædikat, før at den så opretter en brugergruppe-bot til at kopiere alle brugerne i denne brugerkategori (vægtet over en vis tærskel --- og af en given brugergruppe, som skal specificeres i prædikatet.\,. (så prædikater bliver altså herved teknisk set en relation.\,.)), selvfølgelig ved at den først tager et vægtet gennemsnit for brugergruppen (vægtet ud fra en forudbestemt vægt, som altså også indgår i prædikatet) og så giver stemmer til alle relevante.\,. hm, og domænet for brugergruppen kan også være specificeret på forhånd, måske.\,. alle relevante termer indenfor et vist domæne (muligvis) i form af dette gennemsnit --- og hvor opt\_data så kan indeholde antal stemmer i alt.\,. Det var lidt rodet, og jeg må overveje emnet mere i morgen, men ja, rart lige at få det nævnt.\,. (22:53)

(26.02.23, 9:03) Jeg kom i tanke om, at man jo kunne implementere mine ``simple brugergrupper,'' som jeg vit før har kaldt dem, simpelthen ved at pege på en kategori, eller rettere et prædikat (som ikke nødvendigvis behøver at være dannet af ``tilhører kategori $x$''), og en tidligere brugergruppe til et bestemt tidspunkt. Dette giver så i første omgang en ny brugermængde med en særlig vægtning, altså en brugergruppe. Men man kan så videre gøre denne brugergruppe mere dynamisk ved faktisk at definere brugergruppen, som de brugere medlemmerne af denne proto-brugergruppe stemmer ind i den endelige brugergruppe. Alle medlemmer af protobrugergruppen kan så fra start automatisk have ratet som selv op (med et prædikat, der siger: ``tilhører den endelige brugergruppe''). Men hvis de så begynder at give andre brugere positive ratings derfra, jamen så gør en del af deres andel i den endelige brugergruppe nu til de brugere, de har opratet (selvfølgelig vægtet ift., hvor højt de har ratet sig selv (som typisk vil være den maksimale rating, 1), og hvor de samlede vægte som en bruger deler ud af altid automatisk normeres så de tilsammen summer op til, hvad den givne brugers egen vægtning var i protobrugergruppen). (9:14)

Nu overvejer jeg så også lige, om ikke jeg skal sætte ``rat\_val'' (rating value) ned til bare en char som standard.\,.\,? .\,.\,Og her er disse simple brugergrupper jo så et godt eksempel på, at man dog også har brug for muligheden til at kunne bruge flere bytes til at kommunikere sin data (altså f.eks.\ når man vil uddele af sin brugergruppevægt til andre brugere).\,. .\,.\,Jo, fint, det gør jeg, for jeg behøver jo forresten ikke at finde på standarder til, hvordan man kan bruge denne (``optional data''-)varbinary. For den kommer nok ikke rigtigt til at blive brugt før.\,. Nå nej, avg-botten skal jo også bruge den.\,. .\,.\,Ah, men så kan den indledende standard (hvor man nok gerne vil gøre efterfølgende standarder bagudkompatible med denne) bare være, at hvis der kun er én byte i var-binær-strengen, jamen så bør den simpelthen bare tolkes som nr.\ 2 byte i en SMALLINT-rating (sådan at der altså kommer flere (binære) decimaler imellem -1 og 1). (9:22) 

(26.02.23, 21:55) I ``start-indstillingerne''/filter-indstillingerne skal brugerne bare vælge både et prædikat og en (bruger/bot/)brugergruppe sammen som et par for hver vægtning/filter. 

(27.02.23, 15:31) Hm, det er godt nok ikke så effektivt (pladsmæssigt), hvis jeg saniterer tekstinputtet, før det kommer ind i databasen i stedet for efter.\,. .\,.\,Hm, og på en måde er det ene vel lige så sikkert, som det andet, for jeg skal alligevel bare implementere saniteringen i ét lag (medmindre jeg vil verificere i et andet, men det tror jeg ikke), og i så fald handler det jo bare om, at man sikrer sig, at man gør det (korrekt) over det hele i det lag.\,. .\,.\,Så ja, lad mig sanitere under udtrækningen fra databasen.\,. .\,.\,Hm, men er det så control-laget, eller.\,. Ja, det må vel være i control-laget, for dette skal jo gerne sende læseklare HTML-elementer til browseren.\,. 
.\,.\,Ja, ok. Jeg tror på, at dette er en fornuftig nok måde at gøre det på.\,.  

(18:18) Hm, mon der findes en god måde at undgå forfatter-/skaber-botten på, hvor det så i stedet kommer an på.\,. Hm, brugeren første upvote?\,.\,. Hm, måske skal jeg bruge forfatter-botten alligevel.\,. 

.\,.\,Hm, men så kræver det jo, at jeg også har en basal relation, der siger noget i retning af: ``denne bruger valgte dette prædikat om dette subjekt,'' og så skal man jo til at bruge lister med det system, jeg har (og det vil jo ikke være super fedt, vel?\,.).\,. (18:22) .\,.\,Hov, nå nej, det er jo bare at lade forfatter-botten kopiere de første bruger-inputs, hvad snakker jeg om.\,. (18:24) Ja, så det er vel stadig det jeg gør.\,. .\,.\,Lad mig forresten kalde den ``creation bot'' i stedet.\,. (18:28)

(28.02.23, 11:32) Ah, jeg skal jo selvfølgelig også have en tabel over RelationalPredicates (alligevel).\,.

(11:46) Ah, jeg kom lige til at tænke lidt igen på mine ``simple brugergrupper.'' For det første, skal brugergrupperne jo gerne være en slags bots --- måske gerne af sin egen undertype --- og så skal skaberbrugerne til brugergruppen (altså dem fra hvad jeg kaldte ``protobrugergruppen'' i forgårs) jo bare rate en relation som siger: `(bruger) hører til (brugergruppe)'.  Så nu tænker jeg altså, at hver ny brugergruppe, som måske altså har en særlig undertype af botsne, så skal defineres ud fra en tidligere brugergruppe samt en slutdato --- som dog kan sættes med tilbagevirkende kraft, så det altså ikke er en deadline, men en dato, der altid bliver sat på en dato, der ligger senere end den. Når slutdatoen så er sat, så dannes en ny --- konstant! (og måske skulle jeg dele det op i konstante og dynamiske brugergrupper, come to think of it.\,.) --- brugergruppe ud fra skaberbrugergruppen med dens eksisterende vægtning og altså ud fra, hvordan disse brugere har up-ratet `(bruger) hører til (brugergruppe)'+`ny brugergruppe'-prædikatet for andre brugere. (11:58) .\,.\,Så lad mig også lave en tabel til disse konstante brugergrupper.\,. Nå ja, og så er det altså meningen, at en tidligere brugergruppe ligesom ansøger om, at oprette en ny konstant brugergruppe, hvor de er forfatterne. Først allokeres den nye brugergruppe altså så af serveren, og hvis den nye brugergruppe så godkendes med en given slutdato (som ligger før godkendelsesdatoen), så kan brugergruppen få sat et signal flag i sin tilhørende tabel, som siger at brugergruppen er live, hvilket vil sige at serveren nu aktivt varetager, at kopiere ratinger (med passende vægte på) fra brugerne i brugergruppen (med live-flaget) og inputte dem med brugergruppe-botten som ophavsbruger (altså user\_id i SemanticInputs). 

Nå, inden jeg tænker over, hvordan ``dynamiske brugergrupper'' skal implementeres, så lad mig lige nævne, at jeg nu måske tænker, at begrænse Texts til en begrænset TEXT(n)-datatype. Og så kan jeg lade 0xC0 være længere tekster, som så kan indføres senere, når siden går fra at være mest af alt et web-indeks til at være en side, hvor selve indholdet er gemt (så man henter det direkte fra siden). *[Nej, jeg beholder bare TEXT-typen (altså den maksimale TEXT(n)) som den eneste i starten, for så kan alle eventuelle begrænsninger bare ske i et øvre lag, ved at hver bruger bare får en begrænsning på de bytes, vedkomne kan uploade (pr.\ tidsrum).] Og så kan det være, at jeg vil lade 0xD0 være diff-tekster/sammensatte tekster, men det kan jeg jo bare finde ud af på sigt. 

Nå: dynamiske brugergrupper.\,. (12:19) .\,.\,Hm, de kan få sin egen bot-undertype, selvfølgelig, og kunne måske bare være, hvor man ikke sætter nogen slutdato for den nye brugergruppe? .\,.\,Ja, og i øvrigt kan man jo godt have en dynamisk brugergruppe som skabere til en konstant brugergruppe, for så er det jo bare underforstået, at det er vægtene ved udgangen af slutdatoen i skaberbrugergruppen, der skal gælde, når det kommer til at beregne vægtene i den nye konstante. Ok! Nemt! (12:22)

Det er jo underforstået, at ``Bots'' refererer til Native Bots, så måske jeg skulle kalde dem det i stedet. Og så er det i øvrigt også oplagt at tænke på, om ikke tredjeparter også skal have mulighed for at lave bots, f.eks.\ til at varetage brugergrupper. Og hertil må man jo bare sige: jo, det kan sagtens blive en ting på sigt. Så tænker jeg, at dette så bliver en undertype til User-typen, og hvor tredjeparter så ansøger om at få en sådan speciel brugerprofil, hvor der så naturligvis kan høre særlige privilegier til, sådan at tredjepartsbots måske kan få lov at indsætte et større volumen af data pr.\ tid i form af de ratings, de indsender. 

Super. Så nu har jeg en god plan for brugergrupperne!\,:) (12:27)

(13:07) Ah, og ``avg-botten'' bliver jo bare den første brugergruppe (som så er dynamisk).\,.

(14:02) Hov, jeg tror nu, at jeg vil gå tilbage til, at det kun er standard-termerne, som bruger det system med den tabel, der pt.\ hedder NextIDPointers.\,. 
%
%%.\,.\,Hm, nu overvejer jeg egentligt, om man ikke bare skal sige.\,. .\,.\,Hm ja, måske skulle man faktisk.\,. .\,.\,Tja, nej.\,.
%
\ldots Nah, på den anden side, det fungerer også fint sådan (med NextIDPointers som den er). (14:25)

(18:47) Hm, jeg tror jeg vil gå tilbage til en ``.$<$noun describing the Object$>$:''-syntaks, men så vil jeg sige, at navneordet gerne må være i flertalsform, når vi snakker en én-til-mange-relation (i stedet for en én-til-én-relation, hvor navneordet så til gengæld bør være i entalsform). Og punktummet står så bare i stedet for `has as one of its' (hvor $<$pluralized noun$>$ så følger efter), når vi snakker én-til-mange-relationerne (i stedet for at stå i stedet for `has a/an'). \ldots\ Og jeg tror jeg vil sige, at navneord skal capitalize'es, både for faktiske navne ord og for relationer, der følger denne forkortede syntaks. (20:19)

(21:24) Ah, jeg kom lige på en god idé. Jeg vil også lave en ReversedSemanticInputs-tabel, hvor obj\_id og subj\_id så er byttet om i primærnøglen (og dermed i dets clustered index). Og så skal man kunne oprette reversions af existerende relationer, således at alle deres inputs bliver kopieret over i ReversedSemanticInputs, bare med ombyttes obj\_id og subj\_id, selvfølgelig. Jeg kan lige tænke lidt mere over, hvad man skal gøre for at (søge om at) oprette disse.\,. ``to-vejs''-relationer, men i første omgang kan jeg da lige sige, at jeg forestiller mig, at det skal benyttes for bl.a.\ ``.Lexical item:''-relationen, og for ``(Category).Elements:''-relationen. .\,.\,(Hm, lad mig forresten lige kopiere min nuværende beskrivelse af ``.Lexical item:'' ind som en (ikke-renderet) kommentar under denne paragraf.\,.) (21:32) 

%Kopieret:
	%This relation states about its subject and its object, the latter of which should be a text string that is part of an English sentence with a meaning attached to it (i.e. a lexical item), that the following is true: The object (a string) forms a lexical item that can be seen as defining the subject.
	%
	%For instance, if the subject can be referenced by a noun, then the object could be a string forming that noun. And if the subject is a relation that can be referenced by a verb, then the object could be a string forming that verb.
	%
	%A special example of the latter case is if the subject is this very relation descibed by this description. In that case, the object could be the string: 'can be referenced by the lexical item given by'.
	%
	%However, a shortened version of this lexical item might also do, and in fact even prefered in some cases, especially for relations such as this. This is why ".Lexical item:" has been chosen for the original lexical item of this relation. We thus propose the following standard for shortening lexical items of relations. 
	%
	%If possible, lexical items of realations should formulated according the syntax: ".<capitalized noun describing the object>:". If it is expected that users will generally be interested in querying for several fitting objects for a given subject, the noun should be pluralized. In that case, the '.' can be seen as standing in the place of 'has as one of its'. But if, on the other hand, it is expected that users will only be interested in querying for the best fitting object for a given subject (as is the case for this relation), the noun should simply be in its singular form. And in this case, the '.' can be seen as standing in the place of simply 'has' (or 'has a/an').
	%
	%Furthermore, parentheses might also be included at the beginning or at the end (or both) of the lexical item, such that the contents of these parentheses denote the intended type of respectively the subject and the object. For example, a relation that states that its subject is a subcategory of the object, both categories, the lexical item of that relation might be formulated as "(Category).Subcategories:(Category)". And as another example, a relation that states that its object is of the category referenced by the subject, the lexical item might be formulated as "(Category).Elements:". (Note that since the subject could be any category here, it does not make sense to include a type specification for the object). This latter example especially highlights the point of being able to specify the type this way, since it helps give meaning to what we mean by 'Elements' in this case. If the lexical item had been simply ".Elements:" on the other hand, it could reference a bunch of other relations as well, such as "(Molecule).Elements:" and so on.
%


(21:55) Hm, lad mig give to-vejs-relationerne en bestemt typekode, sådan at systemet bare automatisk gør sådan, at hvis et sem-input med en to-vejs-relation bliver indsat, så skal det omvendte input også indsættes i ReversedSemanticInputs. Og så skal jeg i øvrigt også have en fundamental relation der siger: ``.Lexical item of the inverse''. 


(01.03.23, 11:25) Jeg skrev om ude i kommentarerne under den næste sektion, at jeg ville bruge en speciel relation for at springe en kategori over, så at sige, nemlig for kategorier over relaterede prædikater til en kategori. Men hvis vi f.eks.\ tænker på kommentarer til videoer eller (SoME-)posts osv., så vil man jo nok også gerne kunne kategorisere disse i visse tilfælde (f.eks.\ hvis der er meget diskussion under et post). Så nu tror jeg faktisk, jeg vil tilbage til den løsning, jeg tænkte på lige inden den idé, hvilket var simpelthen at begynde at bruge funktioner igen, og så lave særlige funktioner til at bygge afledte kategorier. Disse afledte kategorier kan så fungere lidt ligesom `relevante relationer' for en kategori.\,. og ja, faktisk tror jeg så måske, at man vil erstatte rigtig mange én-til-mange-relationer med afledte kategorier i stedet.\,. .\,.\,Men ja, lad mig lige få sagt færdigt, at man så up-rater de afledte kategorier for kategorien over de termer, som de afledte kategorier afledes af. 

.\,.\,Hm, spørgsmålet er jo så nu: Skal alle én-til-mange-relationer så bare erstattes med kategorier.\,. ja, selvfølgelig på nær i hvert fald, ``.Elements'' og ``.Subcategories''.\,. .\,.\,Hm, måske er dette faktisk ikke en helt dum idé. .\,.\,Så når man up-rater relationer for (termerne i) en kategori, så vil det (i den tidlige version) handle om én-til-én-relationer (hvor objektet dog jo kan være en liste), og ellers up-rater man afledte (afledede?) kategorier i stedet, når altså vi snakker om at tilføje de knapper til termerne (som de vises, når man har klikket på dem i en liste), der folder nye lister ud (og som altså ikke bare folder data om termen ud i samme applikationssøjle). .\,.\,Lyder altså ret fornuftigt, hvis jeg selv skal sige det.\,.\,! (11:43)

\ldots I øvrigt kunne man jo også gøre det på sigt sådan, at når elementer vises til en kategori, så vises også en række af de mest populære underkategorier i toppen, sådan at man har muligheden for at trykke på disse og så ændre kategorien til en underkategori for samme søjle (medmindre man mellem- eller ctrl-klikker, eller klikker på en højre- eller venstre-pil inden for feltet). Bare lige en lille bemærkning, der var værd at nævne.\,. (11:58)


\ldots\ (14:07) Nu har jeg tænkt lidt over, hvordan det så kommer til at spille sammen med det her med ``ReversedSemanticInputs,'' og jeg er kommet frem til, at det jo faktisk går rigtig godt sammen, for så er det jo nok bare de to fundamentale kategori-relationer, der skal være to-vejs, samt relationer der refererer til (fulltext-searchable) strings, såsom `.Lexical item:' og `.Keyword string:'. For alle andre to-vejs-relationer skal jo nu som regel implementeres via `(Category).Elements:'. 

Så har jeg så også lige tænkt over, at man jo nok næsten burde samle NativeBots og UserGroups til bare UserGroups. Og så har jeg endda gjort mig nogle tanker om, at man kunne erstatte rat\_val og opt\_data med først en TINYINT NOT NULL og så en nullable SMALLINT (i.e.\ en short). Og så kan de to ting nemlig fortolkes som noget forskelligt, alt efter om user\_id er ID'et på en faktisk bruger eller en brugergruppe. (14:15) .\,. Hvis det er en faktisk bruger, så kan TINYINT'en signalere den faktiske rating. .\,.\,Hm, og måske skulle shorten (SMALLINT'en) bare altid være NULL, hvorved man jo også kunne dele SemanticInputs op i to og så lave view til brug for alle queries.\,. (14:25) .\,.\,Hm, lyder ikke dumt. Og for brugergrupper tænker jeg så, at det er shorten (.\,.\,ja, og hvis man laver et view behøver man jo forresten heller ikke at blande kolonnenavnene sammen for de to, så shorten kan godt hedde rat\_val.\,. tja, nej, men måske rat\_avg.\,.), der repræsenterer ratingværdien. Og så skal TINYINT'en til gengæld repræsentere det mindste tal $-128\leq n \leq 127$, hvor der gælder, at $2^n > x$, hvor $x$ her betegner en vægtet sum over antallet, der har afgivet en stemme for udsagnet (vægtet med brugergruppens vægte; de samme vægte som rat\_avg udregnes med). (14:31)

(14:34) Nå ja, jeg skulle jo også skrive, at forkortelserne af lexical items for relationer nu ikke behøver flertalsendelser. For nu opretter man jo kategorier i stedet.\,. Nå ja, og det er forresten noget, som jeg skal tænke noget mere over, for det er jo så ikke sikkert, at man skal bruge, hvad jeg nu kalder ``DerivedTerms,'' alligevel (til andet end prædikater).\,. .\,.\,For nu tænker jeg jo faktisk, at man tilføjer én-til-mange-relationer til termerne i en kategori, kald den $c$, ved at up-rate den specifikke én-til-mange-kategori for $c$ ud fra en (fundamental) relation a la: ``.RelevantCategoriesForElements:''. (14:41) Og så skal navnet på denne kategori jo hellere skrives af brugerne selv (i stedet for at parses fra et lex-item). Så ja, jeg tror altså ikke alligevel, der bliver behov for DerivedTerms (i hvert fald ikke i tidlige versioner; hvem ved, hvad der bliver behov for i fremtiden?\,.).\,. (14:43) .\,.\,Så det kan altså være, at jeg går tilbage til at kalde den RelationalPredicates i stedet.\,. Tja, eller også beholder jeg det bare, som det er nu, for det skader måske ikke, at holde muligheden for funktioner åbne, også selvom jeg nu har svært ved at se, hvad de skulle gavne (andet alså end til at lave prædikater med), men jeg kan jo lige tænke lidt over det.\,. (14:45) .\,.\,Hm, måske kunne lige netop en funktion til at reversere en relation være brugbar.\,.\,? (14:49) .\,.\,Tja, og dog, for det er nok bedre bare at lave en speciel tabel over.\,. Hm.\,. .\,.\,Hm, alternativt kunne man lave en tabel med alle de fundamentale relationer (som så inkluderer alle én-til-mange- og alle to-vejs-relationer, som jeg tænker det nu), og så kan der måske bare være et flag i denne tabel, der afgør, om de er to-vejs eller ej.\,. (14:56) .\,.\,Og fordi de så bliver fundamentale, så kan jeg måske endda bare nøjes med at give deres lexical items og descriptions som kolonneværdier i stedet for, at de skal bootstrappe deres egen semantik, for det bliver jo nemlig nok virkeligt sjældent, at brugerne vil query'e efter disse fundamentale relationer. Og når de gør, hvorfor så ikke bare gøre det på en separat introduktionsside, i stedet for at query'e efter dem i selve det semantiske træ?\,. (14:59) .\,.\,Hm, og bare fordi de ikke bootstrapper sig selv, men at deres semantik er beskrevet i deres tabelkolonner, jamen så kan man jo stadig godt bruge dem på sig selv og hinanden. 

.\,.\,Okay, og måske putter jeg også de grundlæggende kategorier ind i samme tabel (og så skal omtalte flag bare kunne vælge imellem flere typer end bare relationstyperne), og så kan jeg jo kalde den tabel for FundamentalTerms. Cool.\,.\,:) (15:06)

\ldots\ (17:10) Skråt to-vejs-relationerne! For de bliver nok alligevel ikke særligt brugbare i praksis. I stedet må brugerne altså bare manuelt up-rate relationen i begge dens udgaver (som hver især er skabt separat), eller også må man implementere en sådan automatik i applikationslaget. Jeg kom også ret hurtigt i tanke om, efter at jeg skrev forrige paragraf (og gik mig endnu en tur i det her totalt lækre vejr, det har været), at jeg jo ville få brug for DerivedTerms netop til at lave derived categories af. Men nu har jeg sidenhen faktisk tænkt noget lidt andet. Men lad mig starte med at sige, at jeg faktisk også tror, at der ikke bliver nok behov for derived/relational predicates. For det vil alligevel nok næsten altid være ift.\ en `belongs to: (Category)'-relation, at man ville bruge det, og her kunne man jo eventuelt i stedet bare gøre sådan, at brugere kan lave intersections mellem flere kategorier.\,. tja, eller.\,.(?) Det vil jeg faktisk lige tænke noget mere over.\,. Men ellers kan jeg sige, at nu hvor så mange semantiske inputs kommer til at handle om at up-rate termer som elementer af kategorier, så vil jeg adskille disse semantiske inputs for sig i sine egne tabeller. I første omgang har vi så en sem-input-tabel, hvor udsagnsdelen så bare består af en kategori (i stedet for subj+rel) og et element-term (i stedet for obj). Og her kommer så hvorfor, at man måske alligevel ikke behøver DerivedTerms, for så kunne en anden tilsvarende tabel bestå af kategori-funktions-input (i stedet for subj), en kategori-funktion (i stedet for rel) og så et element-term (i stedet for obj). (17:22) .\,.\,Hm, men måske får man så alligevel brug for DerivedTerms, for mon ikke man alligevel også får brug for, at.\,. tja, og dog.\,. Ville have sagt: ``brug for at kunne tage fat i den afledte kategori som et selvstændigt term,'' men hvorfor egentligt?\,.\,. (17:24)

.\,.\,Jeg skal i øvrigt også nævne, at jeg nu forestiller mig `.Subcategories:' også som en afledt kategori. 

.\,.\,Hm, i bund og grund er det vel kun, hvis man har brug for `belongs to'-prædikater til afledte kategorier, at man har brug for at kunne behandle dem som selvstændige termer.\,. .\,.\,Hm ja, og i så fald, så skulle man vel hellere bare have en DerivedPredicate-type.\,. (17:31) .\,.\,Ja, jamen så er det vel bare det, jeg gør. Så prædikater kan altså nu afledes (monadisk) af kategorier, og særligt også af afledte kategorier, hvilket jo så nok bliver den eneste måde, at ``ophøje'' en afledt kategori til et *(en) term, så at sige.\,. (17:34)

.\,.\,Og fordi jeg ikke tror, at.\,. .\,.\,Hm, overvejer, om DerivedPredicates så skal deles op i to tabeller.\,. men hvorfor ikke, kan man sige.\,. Ok.\,. 

.\,.\,Hov, men ift.\ derived prediates.\,. ah, så skal man så bare sørge for, at disse bliver sat automatisk.\,. eller?\,.\,. (For det bliver jo alligevel en del arbejde.\,.) Hm.\,. (17:40) .\,.\,Hm, men er det mon så bedre, at man i stedet for derived predicates så bare gør sådan, at man kan tage intersections af kategorier (og så i stedet også sørger for, at derived categories bliver oprettet som termer.\,.).\,. (17:42) 

.\,.\,Hm, men er det så ikke lige før, at alle prædikater bare skal være kategorier også.\,.\,? .\,.\,Hm, det ville ændre det en del, for så skal man ikke længere hente en masse termer til en liste, hvor man så samtidigt skal hente prædikat-værdier for dem; man skal i stedet bare hente termer fra lister.\,. Hm, men dette er jo ikke nødvendigvis mere effektivt.\,. .\,.\,Hm, men man kunne jo eventuelt så gøre `belongs to:'/`.Elements:' til en to-vejs relation (nemlig ved at man med andre ord bare sørger for at have to eksemplarer af hver kategori-input-tabel).\,. (17:49) 

.\,.\,Hm, og hvis man gør det sådan, at prædikater bliver kategorier, så kan man bare sørger for, at hver kategori for et præfiks, der fortæller, om titlen er et navneord (i flertal) eller et prædikat --- eller et adjektiv (så man sparer `is' i titlen(/tagget)).\,. (17:55) .\,.\,Hm, rent praktisk kunne dette give god mening, men jeg kan på den anden side ikke særligt godt lide, at prædikater kaldes ``kategorier''.\,. Hm.\,. .\,.\,Nå, jeg må jo lige tænke lidt over det hele.\,. (17:57, 01.03.23)

.\,.\,Hm, ville det give mening, hvis prædikater ligesom altid bare hørte til en kategori.\,.\,?\,.\,. (18:02) .\,.\,Hm, måske overtænker jeg det en smule nu.\,. 

(02.02.23, 14:17) Fik tænkt lidte videre i går aftes og fik et par idéer, og så har jeg tænkt en del videre i dag og fået en del flere gode idéer. Nu tror jeg, jeg er ved at have den. Jeg har tænkt mig, at det grundlæggende lag, altså databasen, skal laves ret meget om. Nu skal semantiske inputs bestå af en tabel med (prædikat\_id, rat\_val (short), og obj\_id) som primærnøgle (og vist nok som det eneste i den tabel). Og så skal hvert prædikat bygges i en tabel med (user\_id, subj\_id, relations/kategori-funktions-ID) som primærnøgle, og hvor selve prædikat-ID'et så altså er den eneste ikke-nøgle.\,. Nå ja, eller det vil sige, man kunne jo godt have.\,. .\,.\,Hm, måske skulle man bare have to kopier af denne tabel: den ene hvor (user\_id, subj\_id, relations/kategori-funktions-ID) er primærnøgle, og den anden hvor pred\_id er primærnøgle.\,. Fint.\,. (14:26) .\,.\,Pointen med at kalde det kategori-funktioer er så, at en bruger kan til hver kategori vælge en liste over kategori-funktioner, som skal danne de knapper, der forekommer, når et element vises (i en liste eller for sig selv). Når man så trykker på disse knapper, så får man altså en liste af alle objekter --- eller rettere så mange man vil have, måske fra højest til lavest rating, der hører til det givne prædikat\_id, der jo så aflæses i (user\_id, subj\_id, kategori-funktions-ID), hvor subj\_id jo så er det givne element, og hvor kategori-funktionen selvfølgelig er den valgte. (14:32) .\,.\,En funktion kan dog godt vide, at den selv er ``en én-til-én-relation,'' hvorved brugeren som regel kun vil få serveret det højest ratede objekt på listen, medmindre brugeren specifikt beder om den anden mulighed. Disse funktioner er også altid typede, idet de som minimum i hvert fald altid angiver objekttypen. Og denne type angives i form af en kategori. Dette bliver særligt relevant, når jeg om lidt når til, at brugere også for hver kategori kan up-rate `skabeloner' til denne, som så kommer til indirekte at bestemme, hvordan element- og element-liste-visningerne skal være for den kategori. Og ja, hvis en kategori-funktion så erklærer, at objekterne er af kategori $x$, så vil denne afledte kategori altså også arve samme `skabelon,' som kategori $x$ har. 

En skabelon er så også en funktion (ja, jeg er pludselig gået all-in på funktioner, sjovt nok), der tager en kategori som input, og som så indeholder en masse information, som applikationen skal læse og bruge til at indstille visningspræferencerne (altså i form af HTML og CSS). Særligt skal denne information også definere en række kategori-funktioner, som skal bruges til diverse ``knapper'' i HTML-skabelonerne. Tillige bør der så være --- og ja, man kan sikkert gøre det på mange måder, men nu foreslår jeg lige det her --- være en højereordnesfunktion, der tager en af disse knap-kategori-funktioner og spytter en ny kategori ud, nemlig en kategori over ``generelt relevante funktioner'' for knap-kategori-funktionernes kategorier.\,. Okay, det bliver helt klart en smule indviklet nu, men vi skal nok finde hoved og hale i det.\,. Men ja, pointen er så, at når brugeren trykker på en knap, så allerede uden at nogen brugere har givet input, så vil der allerede fra start være nogle forslag i toppen af kategori-listen (når brugeren har trykket på den givne knap), som den afledte kategori altså arver helt oppe, ikke fra dens forælderterm, men fra forældertermens egen kategori (altså den kategori som forældertermet er et element af). Og herfra kan brugeren så selv vælge at tilføje nye termer til denne liste, som så kan vises side om side med disse start-foreslag --- og brugeren kan endda også nedvurdere termerne, som er en del af startforslagene, hvis de har lyst. (14:47)

Nå, den mest tunge øvelse for databasen er jo generelt, når den skal hente en masse termer og sortere dem. Så det er også dette arbejde, jeg har forsøgt at optimere med disse nye tanker. Nu handler det jo i høj grad om (efter man lige har fået det relevante prædikat-ID), bare at pege på et prædikat-ID, og så få et antal elementer fra toppen eller fra bunden af den tilhørende liste (som nu er ordnet efter rating!). Hvis man så skal lægge yderligere vægtninger/filtre over, så vl jeg \emph{ikke} længere have det sådan, at der så skal laves seeks *(search, rettere; vi snakker altså søgningen i logaritmisk tid) på hvet enkle term. Nu skal sådanne søge-/filterindstiller dannes ud fra sammensætninger af kategorier! Så man beder altså bare databasen om et antal lister af termer fra forskellige prædikat-ID'er til at starte med. (Man behøver ikke at bede om den fulde liste hver gang, og det er jo altid dejligt, hvis hver liste er så begrænset, at databasen kn skal læse listen fra en eller måske to pages.) Databasen serverer så også alle de tilhørende rating-værdier, nu kan applikationen så tage den mindste liste, og ordne termerne efter ID. Så kan den for alle de andre lister gøre det, at den går igennem listen og laver seeks på den mindste liste (den ordnet efter ID), og så smider termen væk, hvis den ikke er på listen. Hvis den dog er, jamen så gemmes ratingen fra den givne liste sammen med de andre gemte ratinger for det element. Til sidst får man så en fællesmængde af alle lister, hvor der for hver term på listen står alle de relevante rating ud for termen. Til sidst kan man så lave den aritmetik man synes for at kombinere disse ratings til en samlet rating, g så kan man ordne listen efter denne (måske uden at smide de grundlæggende ratings væk i hukommelsen (hvis nu brugeren vil ændre vægtningen f.eks.)). (15:01) 

Bum. Så det er altså sådan, jeg tror, det skal komme til at fungere nu.\,:) (15:01)

(03.03.23, 11:23) Mit forslag fra i går var ikke så godt. Det er rigtigt nok, at skabelonerne skal definere nogle kategori-funktioner/relationer, so bruges til at give startforslag til visse afledte kategorier af termerne, som skabelonen handler om at definere HTML og CSS for, men disse relationer skal bare være relationer a la: ``.Relevant predicate suggestions:' og ``.Relevant comment subcategories:''. 

Bemærk i øvrigt, at selvom det altså giver god mening at kalde dem kategori- --- eller prædikat- --- funktioner, nu hvor de tages på et subjekt og en bruger og spytter et pred\_id (som også kan tolkes som et ``kategori-ID'') ud, så kan vi altså også sagtens stadig se dem som relationer, ligesom vi har gjort hidtil. Men ja, fordi man så gerne skal formulere disse relationer hver især som et navne ord (i flertal eller i ental alt efter relationstypen (altså én-til-én eller én-til-mange)), så giver det jo også dermed fin mening også at omtale dem som prædikat-/kategori-funktioner. 

Nå, en vigtig pointe er så for det første, at pred\_id ikke bliver et selvstændigt term. Disse prædikater bruges kun til at definere selve listerne af elementer, som vises i applikationen. Hm, måske skulle jeg dermed faktisk begynde at kalde dem sets (mængder) i stedet.\,. .\,.\,Ja, lad mig det. For både `kategorier' og `prædikater' bliver jo nemlig også hver især en type, eller rettere en kategori (for typer er mere grundlæggende --- såsom `sets'/`mængder'), af termer. (11:36) En anden vigtig pointe er så, at prædikat-termer jo dermed nu ikke direkte fører til applikationslisterne, dem vi altså nu kalder `mængder,' men i stedet kræver dette så en `fulfills'-/`.Fulfilling terms:'-relation. Prædikat-mængden dannes jo nemlig ved at sammensætte (user\_id, subj\_id, set function ID), hvor subj\_id så er prædikat-termen, og hvor ``set function ID'' så er `.Fulfilling terms:'-relationen. (11:41)

En tredje, ny, pointe er også, at ingen af de to tabeller faktisk skal reverses! For nu vægter/filtrerer jeg jo lister via ``intersections,'' hvis vi kan kalde det det. Og når det kommer til keywords (og altså FULLTEXT-searchable Strings), så vil jeg hellere bare indføre en relation a la: `is a relevant keyword (/lexical item) for:'. Som en af hovedkategorierne i applikationen vil jeg så have en pseudo-kategori, som altså er et søgefelt på keywords i databasen. Når man så har fundet og valgt et ønsket keyword, så kan man så se, hvilke termer er relateret til dette via (some user, keyword/lexical item, `.Related (semantic) terms:' .\,. / `.Related Terms:')-mængden. (11:50) .\,. / `.Related s-terms:'.\,. .\,.\,Anyway, så derfor behøver vi altså ikke nogen tilbagegang i det semantiske træ --- i hvert fald ikke som en del af det helt grundlæggende. I applikationslaget kan man så stadigvæk gøre sådanne, at visse ratings automatisk bliver carbon-copied og givet til en tilsvarende reversed relation også, men ja, dette er i så fald altså udelukkende oppe i applikationslaget. (11:53)

(12:24) Nå ja, og jeg overvejer at gøre rat\_val til en TINYINT igen.\,. .\,.\,(12:31) Ah, måske kunne man godt få brug for en ekstra tinyint for de normale brugere også, for dette kunne jo bruges til at.\,. Nå ja, til enten at give usikkerhedsbredden på ratingen, som jeg har tænkt før, eller måske bare at give en selvdefineret vægt imellem 0 og 1, sådan at brugeren selv kan sætte sin effektive brugergruppevægt ned for den specifikke rating.\,. Hm, interessant at overveje, hvad der giver mest mening af de to muligheder, det må jeg lige gøre.\,. (12:34)

.\,.\,Men ja, for brugergrupper kan den første byte så være ratingen (fra -127/127 til 127/127), og så kan den næste byte udgøre en vægtet sum for, hvor mange har afgivet stemme til ratingen.\,. hm, og måske kunne man endda også bruge nogle bits fr nr.\ 2 byte og sætte dem over i forlængelse af den første (for yderligere præcision).\,. Tja, og dog.\,. (12:37) .\,.\,Nej, en skala med en opløsning på 127 til begge sider er rigeligt. Og så kan stemmeantals-vægten jo hermed blive den eneste kolonne, som ikke indgår i nøglen. 

Jeg er forresten ikke sikker på, at jeg får brug for.\,. hm datoer.\,. jo, måske.\,. (12:40)

Hm, stemmeantals-vægten kunne faktisk sagtens være en del af primærnøglen alligevel, og altså nemlig komme lige efter ratingværdien.\,. (12:45) .\,.\,Jeg kunne kalde det for en signifikans-indikator, hvilket jo så både kan bruges, om vi taler brugergruppe- eller bruger-versionen af, hvad værdien betegner. 

.\,.\,Hm, jeg tror, at det vil være meget nemmere generelt for folk at forholde sig til tanken om en stemmevægt frem for en afvigelsesbredde, så lad mig bare sige, at det er det, vi gør! (12:50) Og så spiller det egentligt også meget godt sammen, for så kan man bruge ``rating weight'' for både brugergruppe- og bruger-versionen, og så behøver jeg ikke at dele SemanticInputs op i to tabeller. .\,.\,Tja, selvom det burde man nu næsten alligevel, om ikke andet så bare for på en nem måde at sikre sig, at der bliver to filer.\,. nå nej, dette betyder jo ikke helt så meget alligevel. Nå, det er også lige meget nu; det kan jeg altid lave om på, hvis det er.\,. 

(Hvis jeg inkluderer datoen, så skal den selvfølgelig ikke være en kolonne i SemanticInputs, har jeg indset nu (pga.\ effektiviteten).\,.)

(04.03.23, 10:01) Jeg kom i tanke om i går aftes, at fordi alle semantiske inputs jo alligevel tager udgangspunkt i brugere og brugergrupper, så kan hver bruger(gruppe) jo egentligt godt selv have deres egen fortolkning af en relation, uden at det gør noget, så derfor kan man godt udelade beskrivelserne som en del af det grundlæggende lag. Jeg skal selvfølgelig beskrive de grundlæggende Termer i databasen, men brugerne behøver i princippet ikke at holde sig til de beskrivelser.

Så tænkte jeg også noget andet, og det var, at `skabelonerne' jo også kan indeholde et valg om en bruger for hver relation/kategori-funktion (der så sammen med det selekterede term selv giver en `mængde'). Så kan en brugergruppe naturligvis bare pege på sig selv ret ofte, hvilket også måske vil være lidt mere effektivt (for når man skifter bruger, så skifter man helt sikkert også til en anden disk page.\,.), men de kan altså også pege på andre, hvilket kan være rigtig praktisk, tror jeg på. (10:08) 

.\,.\,Nå ja, og nu overvejer jeg altså, at lave en tabel for alle relationer som en del af det grundlæggende, således at relationer defineres unikt ud fra objekt-navneord, subjektkategori, objektkategori og et er-én-til-én-flag. Og det er det; ingen beskrivelse. Og så kan hver gruppe dermed i princippet vælge deres egen fortolkninger, der hvor der kan være tvetydigheder --- eller bare gradbøjninger af (og altså rettere sagt mange versioner af), hvad relationen helt præcist indebærer. (10:13)

(10:22) Hm, og så kunne jeg også lave en tabel over kategorier, som så faktisk ikke skal have meget andet i deres grunddefinition en en titel, og så overvejer jeg endda lidt nu, om ikke man så skulle gøre obj\_noun og kategori-titlen til FULLTEXT-searchable kolonner for sig selv?\,:) Det tror jeg, jeg vil gøre.\,. 

\ldots Hm, men hvis det ofte er enkelte ord, så er full-text nok lidt overkill, når man bare kan bruge et non-clustered index.\,. \ldots (Ja, det er det jo selvfølgelig. Jeg ser lige, hvad jeg gør helt præcist.\,.)

\ldots (11:20) Hm, skulle man mon indføre en grundlæggende prædikat-type, som så kan blive en slags kategori-til-(under)kategori-funktioner.\,.\,? .\,.\,Ah, nå nej/ja, det svarer jo bare til `relevante prædikater,' så det får jeg allerede.\,. .\,.\,Tja, og dog, for det kan måske være meget smart at kunne.\,. Ah, men jeg skal jo finde en måde at brugerne skal kunne instantiere intersections (fællesmængder) på, så det skal jeg få inkluderet.\,. (11:26)

(12:23) Hm, måske er det i virkeligheden nemmere bare at bruge decimaltal, når det kommer til at dele de forskellige typer ind i forskellige auto\_increment-startpunkter.\,. 

(12:39) Jeg skal have fundet ud af, hvad jeg gør med ``standard terms, set ID pointers, creators and dates''\ldots 


(05.03.23, 9:43) Jeg fik en masse gode idéer i går. Lad mig starte med at nævne, at jeg nu forestiller mig, at alle standard-termerne (som man måske kunne kalde s- eller r-termer (for hhv.\ semantic, standard og resource, regular *(mest for ressource-term, dog))) samt kategorier skal defineres alene ud fra en kort titel samt en pointer (et ID, i.e.) til en henholdsvis en kategori eller en overkategori, om vi snakker et r-/s-term eller en kategori.\,. hm, r-term giver faktisk mest mening, for kategorier er jo også semantiske.\,. Ja, og så kunne s-termer i øvrigt betegne alle ikke-data- og ikke-konstruerede termer.\,:) 

Nå, det helt store nye er så, at med disse ændringer (og hvor hver bruger i princippet selv kan vælge deres egen beskrivelser (selvom hver titel--kategori-pointer-kombination udgør en unik r-term eller kategori (med ét ID))), så giver det pludselig vildt god mening, at fortolke hele det semantiske træ som et slags filsystem (med filsti-agtige stier).\,! Nu vil jeg derfor prøve at beskrive syntaksen for disse ``filstier''.\,. hm, lad mig bare kalde dem paths.\,. eller s-paths.\,. hm.\,. Nå, lad mig beskrive syntaksen for disse stier. (9:54)

Vi starter med at vælge en bruger (i starten af stien). Hm, det gør jo forresten også, at hver bruger skal have.\,. Nå nej, man kan jo godt bruge et bruger-ID, hvis ikke brugeren har et unikt alias i systemet.\,. Nå, og så kommer en række kategorier og underkategorier, separeret med `$>$.' .\,.\,Hov, måske skal der faktisk være to udgaver af `$>$,' lad mig lige tænke mig om en gang\ldots 

\ldots (10:47) Okay, jeg har tænkt mig lidt om, og nu har jeg en faktisk mere simpel syntaks, der også faktisk minder mere om gængse filstier. Lad mig faktisk bare starte med at prøve at definere syntaksen.

Vi har:

%$Path := UserIdent\ \texttt{/}\ Set\ |\ UserIdent\ \texttt{/}\ Term$
%
%$UserIdent := ident$
%
%$Set := Set'\ |\ Set'\ \texttt{\&\&}\ Set$ 
%
%$Set' := (Set)\ |\ Set''\ |\ Set''\ \texttt{||}\ Set'$ 
%
%$Set'' := Term\ \texttt{.}\ Relation\ \texttt{/}\ |\ ident\ \texttt{/}$ 
%
%$Relation := ident$
%
%$Term := Term'\ |\ Category\ \texttt{/}\ Term'$
%
%%$Term' := $ ..(11:18)...
%
%%(11:34) Hm, jeg skal lige overveje nogle ting... ...(11:44) Okay, lad mig prøve igen..

$Path := UserIdent\ \texttt{//}\ Set\ \texttt{/}\ |\ UserIdent\ \texttt{/}\ Term$

$UserIdent := ident$

$Set := Set'\ |\ Set'\ \texttt{\&\&}\ Set$ 

$Set' := Set''\ |\ Set''\ \texttt{||}\ Set'$ 

$Set'' := (Set)\ |\ Term\ \texttt{.}\ Relation\ |\ ident$ 

$Relation := ident$

$Term := Category\ |\ Set''\ \texttt{/}\ ident$

%Hm, kunne det være sådan her..? (12:03) ..Ja, det fungerer vist, for man kan altid se, om stien slutter med en skråstreg, og hvis det gør, så skal det parses som et Set, og hvis ikke, så skal det parses som en Term.. (12:06) ..Og så tænker jeg, at Category skal indebære følgende syntaks:

$Category := Category\ \texttt{/}\ ident\ |\ ident$

\ 

Når jeg skriver $ident$ og ikke $id$, så er det for at præcisere, at det ikke behøver at være et BIGINT-id, men at det også sagtens (og som regel vil være) en streng-identifyer.\,. (12:13)

.\,.\,(12:17) Hov nej, det kan godt være, at vi lige skal gøre sådan, at $Category$ ikke kan komme efter.\,. .\,.\,efter.\,. Hm nej, måske fungerer det; jeg tror ikke $Category$ kan være andet end i starten med denne syntaks, vel.\,.\,? (12:20) .\,.\,Nej, så måske fungerer det altså, som den er.\,. (12:22)

.\,.\,Lad os sige, at det virker for nu. Og lad mig så sige, at jeg så tænker, at `Elements'- og `Subcategories'-relationerne henholdsvis må (og bør) forkortes med bare `e' og `s' i stierne. Dermed kunne vi f.eks.\ navigere til underkategorien rockmusik med stien: `userid//Media/-Music.s/Rock music'. Men hvis `Rock music' så er defineret med `Music' som sin overkategori (husk at hver kategori er unikt defineret ud fra overkategori plus titel), så kan applikationen altså også omdanne denne sti til den ækvivalente sti: `userid//Media/Music/Rock music'. Så en skråstreg i kategori-præfikset betyder altså det samme som `.s/', men hvor underkategorien så bare allerede har den givne kategori før `.s''et som sin definerende overkategori. Hvis derimod `Rock music' er defineret ud fra en anden kategori, jamen så må man bare beholde `.s/' i stien. Hvis man så vil se en liste (eller nærmere bestemt en `mængde') over elementerne i `Rock music,' så kunne stien så se sådan her ud: `userid//Media/Music/Rock music.e/'. (12:36)

Jeg forestiller mig også at brugere selv skal kunne definere forkortelser for relationer og andre ting, men det vil jeg nu nok undlade at implementere i betaversionen. 

Nå ja, og hvis i øvrigt at et element af en kategori har denne kategori som dens definerende kategori, så kan $ident$ (altså i `$Set''\ \texttt{/}\ ident$'-underproduktionen) bare være termens titel. Og tilsvarende gælder for kategorier, hvorfor at et kategori-præfiks fra `$Category$'-produktionen altid vil bestå af navne/titler frem for BIGINT-ID'er. (12:41)

Hvis ikke et element eller en underkategori har kategorien som sin definerende kategori.\,. ja, så skulle man måske faktisk indføre, at brugere kan lade kategorier ``med-adoptere'' andre kategoriers børn.\,. For eksempel kunne vi, hvis `Rock music' er defineret ud fra en anden kategori end `Music,' gøre sådan at `Music' bare vælger at (eller rettere at brugeren vælger at lade `Music') adoptere `Rock music' som sit barn også. .\,.\,Ja, og så vil man endda igen kunne erstatte `.s/' med `/', for det kræves så selvfølgelig bare, at en kategori ikke må adoptere flere børn med samme titel --- i hvert fald ikke uden at lave aliasser for dem. Og der kan man bare se, så får vi jo hermed også allerede en mulighed for, at brugere kan lave forkortelser (nemlig via aliasser, hvis man altså bare gør, at en kategori også kan ``adoptere'' og omdøbe sine egne børn). Nice nok. (12:46) 

.\,.\,Nå ja, jeg mangler forresten også lige nogle afgrænsnings-suffikser på $Set$sne\ldots (12:51)

.\,.\,

$Path := UserIdent\ \texttt{//}\ Set\ \texttt{/}\ |\ UserIdent\ \texttt{/}\ Term$

$UserIdent := ident$

$Set := Set'\ |\ Set'\ \texttt{\&\&}\ Set$ 

$Set' := Set''\ |\ Set''\ \texttt{||}\ Set'$ 

$Set'' := Set'''\ (\texttt{[}\ num\ \texttt{]})? $ 

$Set''' := (Set)\ |\ 
	Term\ \texttt{.}\ Relation\ (\texttt{(}\ Range\ \texttt{)})?\ |\ 
	ident\ (\texttt{(}\ Range\ \texttt{)})?
$ 

$Relation := ident$


$Range := \mathrm{TBD,\ but\ perhaps\ something\ like\!:}\ \ 
	num\ \texttt{;}\ (num)?\ |\ 
	\texttt{;}\ num
$

$Term := Category\ |\ Set\ \texttt{/}\ ident$

$Category := Category\ \texttt{/}\ ident\ |\ ident$

\ 

\noindent(Nu fik jeg også lige rettet $Set''$ til $Set$ for $Term$-produktionen.\,.)

.\,.\,Så er det så meningen at \texttt{\&\&} betyder en intersection (fællesmængde) af mængderne, og \texttt{||} betyder en union (foreningsmængde). Begge disse ting handler altså så at sætte flere mængder sammen (ved at man først ordner efter term-ID'et), og for begge ting beholdes alle ratings fra hver indgående mængde, således at det altså først er i applikationslaget, at den endelige aritmetik og listesortering foregår (og hvor brugerne nemlig så kan ændre sorteringen for listen, uden at skulle query'e serveren igen). Forskellen er så bare lige, at for \texttt{\&\&} fjernes alle de termer, der ikke indgår i begge mængder på hver side af operatoren, inden at listen/mængden serveres til browseren, og altså til applikationen, der kører i den. (13:21) 

.\,.\,Åh, og jeg skal også lge forklare, at jeg med $(\texttt{[}\ num\ \texttt{]})?$ for $Set''$ altså tænker, at $num$ her skal repræsentere et maksimumantal på, hvor mange termer, man gerne vil have serveret fra mængden (hvis størrelsen overstiger dette $num$).\,. Hm, jeg skal forresten også have tænkt over, hvordan man vender rangen om (og altså negerer relationen), men det må jeg bare lige have mente at finde ud af på et tidspunkt.\,. (13:25)

.\,.\,Hm, man kunne måske bare angive dette via $Range$en. Lad mig i øvrigt lige erstatte $num$ i $Range$ med $float$ og $num$ i $\texttt{[}\ num\ \texttt{]}$ med $int$, sådan at det bliver:

\ 

$Path := UserIdent\ \texttt{//}\ Set\ \texttt{/}\ |\ UserIdent\ \texttt{/}\ Term$

$UserIdent := ident$

$Set := Set'\ |\ Set'\ \texttt{\&\&}\ Set$ 

$Set' := Set''\ |\ Set''\ \texttt{||}\ Set'$ 

$Set'' := Set'''\ (\texttt{[}\ int\ \texttt{]})? $ 

$Set''' := (Set)\ |\ 
	Term\ \texttt{.}\ Relation\ (\texttt{(}\ Range\ \texttt{)})?\ |\ 
	ident\ (\texttt{(}\ Range\ \texttt{)})?
$ 

$Relation := ident$


$Range := \mathrm{TBD,\ but\ perhaps\ something\ like\!:}\ \ 
	float\ \texttt{;}\ (float)?\ |\ 
	\texttt{;}\ float
$

$Term := Category\ |\ Set\ \texttt{/}\ ident$

$Category := Category\ \texttt{/}\ ident\ |\ ident$

\ 

Her betegner $float$sne i $Range$en jo så selvfølgelig min og maks på, hvilke nogle ratingværdier, man gerne vil query'e efter. (13:34)

.\,.\,Hov, det var forkert at rette $Set''$ til $Set$ i $Term$. Lad mig lige tænke over, om det skal rettes tilbage til $Set''$, eller hvad.\,. .\,.\,Hm, måske skulle rette det tilbage, og så også bare rette $Set$ til $Set''$ i $Path$.\,.\,? (13:40) .\,.\,Ja, lad mig bare gøre dette for nu. Så får vi:

\ 

$Path := UserIdent\ \texttt{//}\ Set''\ \texttt{/}\ |\ UserIdent\ \texttt{/}\ Term$

$UserIdent := ident$

$Set := Set'\ |\ Set'\ \texttt{\&\&}\ Set$ 

$Set' := Set''\ |\ Set''\ \texttt{||}\ Set'$ 

$Set'' := Set'''\ (\texttt{[}\ int\ \texttt{]})? $ 

$Set''' := (Set)\ |\ 
	Term\ \texttt{.}\ Relation\ (\texttt{(}\ Range\ \texttt{)})?\ |\ 
	ident\ (\texttt{(}\ Range\ \texttt{)})?
$ 

$Relation := ident$


$Range := float\ \texttt{;}\ (float)?\ |\ \texttt{;}\ float
$

$Term := Category\ |\ Set''\ \texttt{/}\ ident$

$Category := Category\ \texttt{/}\ ident\ |\ ident$

\ 

Nå, det kan være, at jeg lige vil gå mig en lille tur, men jeg har altså til gode at snakke om, hvordan brugere skal kunne up-rate relationer og skabeloner --- og endda andre brugere/brugergrupper, som man vil kopiere næsten fuldstændig, på nær lige, at ens egne ratings kommer og overskriver deres --- og om hvordan prædikater nu bare skal implementeres via relationer, men det må jeg alt sammen skrive om, når jeg kommer tilbage (.\,.\,dog ikke sikkert, at jeg når at skrive det hele i dag, men det må jeg se.\,.)\ldots (13:47)







\section{Hvad jeg gerne vil sigte efter med det basale applikationsdesign}

*[(25.02.23)] (11:50) Jeg har tænkt lidt over, hvordan udgangspunktet skal være for applikationsbrugerfladen, eller rettere hvad man gerne bør sigte imod (for betaversionen behøver ikke at inkludere det hele). Her i formiddages fik jeg også lige nogle gode nye idéer, som jeg vil fortælle om lige efter denne sektionsintro. Jeg regner så med at prøve at gå igennem mine seneste tanker omkring emnet, og så vil jeg nok lade sektionen (denne) stå åben efterfølgende, så jeg kan vende tilbage med flere idéer, til den grundlæggende opbygning af applikationen (eller i hvert fald udgangspunktet for den). Jeg vil så også.\,. Hm, enten vil jeg starte en ny betaversion-sektion, eller også vil jeg bare føje til den forrige, men uanset hvad, så vil jeg i hvert fald gå videre til, når jeg har skrevet om ting til denne sektion, gå over til så at skrive om, hvilke nogle hjørner jeg så kan skære i starten. For den første version af hjemmesiden behøver altså ikke at inkludere alle de detaljer, jeg beskriver her, og derfor vil jeg altså have en separat sektion, hvor jeg så skriver om, hvilke nogle ting i applikationsbrugerfladen, jeg \emph{ikke} vil implementere til at starte med. (11:58)

Og nu vil jeg altså lægge ud med at beskrive de idéer, jeg har fået her i formiddags, og så vil jeg i øvrigt også snakke om vigtigheden i at bruge ``kategorier.'' .\,.\,Hm, på den anden side så har jeg vist ikke snakket så meget om kategorier overhovedet, så lad mig egentligt tage det mere fra grunden i stedet, og så snakke om kategorier først.

Det kan virke lidt underligt, at introducere ``kategorier'' som noget rigtigt grundlæg-gende; næsten ligeså grundlæggende som `prædikater' og `relationer.' (Dog ikke helt længere, for `kategorier' bliver ikke længere en del af det grundlæggende (database-)lag, men det bliver i stedet bare noget virkeligt grundlæggende i applikationslaget.) Hvorfor ikke snakke om `mængder' eller `klasser;' begreber som er meget mere ``matematiske'' så at sige?\,. Jo, fordi begrebet om `kategorier' har en helt særligt fordel. Vi kan se kategorier som en slags lav-niveau repræsentation af mængder (hvis vi altså tager udgangspunkt i \emph{standardmodellen} for mængdelære), bare hvor kategorier dog godt kan indeholde sig selv. For vi kan nemlig se dem som ``kasser'' med skilte på, hvor vi så kan putte referencer til andre ting --- eller til den givne kasse selv --- ned i disse kasser. Nå, men at de kan indeholde sig selv, og at man derfor kan have en ``kategori af kategorier,'' som kan indeholde sig selv, er nu ikke forcen ved kategorier. Den store fordel kommer, når vi begynder at benytte begrebet om `underkategorier.' For hvis jeg siger, at $x$ er en god underkategori til $y$, så er det allerede en rimelig naturlig fortolkning af den sætning, at jeg mener at $x$ er gavnlig at se (tidligt) i en liste, hvis man som bruger beder om at se $y$'s underkategorier. Men hvis jeg derimod f.eks.\ sagde, at $x$ er en god \emph{undermængde} af $y$, jamen så ville folk i almindelighed rynke på panden og sige: ``jamen, alle korrekte undermængder af $y$ må da være lige gode, ikke?'' Selvfølgelig kan man prøve lave en specifik relation, der siger lige præcis siger: ``$x$ er gavnlig at se (tidligt) i en liste, hvis man som bruger beder om at se $y$'s underkategorier.'' Men pointen er så bare, at man får utroligt meget forærende (i forhold til hurtig intuitiv forståelse), hvis man så også bare kalder det `kategorier' og `underkategorier' i stedet; så er der langt kortere for brugerne til at forstå, hvad pointen med underkategorierne er! (12:13) %..Føler mig effektiv på tasterne i dag..

Så kategorier skal altså være en helt central ting i applikationen, forestiller jeg mig --- i hvert fald når folk vil lave semantiske søgninger, og ikke bare vil søge på keywords (hvor jeg i øvrigt nu tænker at benytte et full-text index på String-typen til gavn for dette (i stedet for at brugere manuelt skal bedømme relevante keywords --- det kan de også, men med et full-text index er vi meget hurtigere i gang fra start)). Og ja, man kan i princippet så starte med `kategorien over kategorier' som den mest grundlæggende ting (.\,.\,hvor man så må regne med, at den selvsamme kategori ikke bliver ratet højt som gavnlig underkategori, btw). Herfra kan man så søge efter underkategorier ved et følge træet ned herfra (imod hvad man søger efter) ved at følge kanter, der repræsenterer en grundlæggende `.subcategory='-relation. Nå man så er kommet til en underkategori, der virker lovende, så kan man så vælge at få vist termer, der hører til denne underkategori (i stedet for at bede om yderligere underkategorier). Disse termer kan så herfra ordnes og filtreres ud fra prædikater. Og så kan man altså forhåbentligt finde den eller de ressourcer, man er interesseret i.

Dette beskriver nok den mest almindelige semantiske (\emph{manuelle}) søgning, man kan forestille sig. Men der er også andre usecases, hvor brugerne har brug for nogle andre relations-kanter at følge. Lad mig lige tænke over, hvilken én jeg vil skrive om først, og så vende tilbage.\,. (12:26)

%I øvrigt, hvad angår navn, jeg kan egentligt ret godt lige SemNet, men det er nu også bare næsten lidt for.. 00'er-agtigt.. *Det er et okay navn. Jeg har også i tankerne: SNet, S-Net, s.net, sem.net, sema.net..

%..Hm, en af mine idéer (den vigtigste) her fra i formiddags er, at man nok kan implementere bruger-dataen simpelthen via kategorier og almindelige ratings omkring disse. Nu overvejer jeg, så om kan gøre noget tilsvarende for filtre/prædikatvægtninger, eller hvad man nu lige skal gøre der.. (12:55) ..Jeg er i øvrigt kommet frem til, at filtre--vægtninger nok skal åbnes som en barne-søjle, der så kommunikerer direkte til forældersøjlen (og nok kun denne), når brugeren laver opdateringer i filter--vægtnings-præferencerne, men det skal jeg nok komme ind på.. ..Hm, jeg tænker jo forresten, at filter--vægtnings-prædikaterne bare kan være den selvsamme liste, som vises for `relevante prædikater' til termen.. ..Hm ja, og så er det bare spørgsmålet, om, og i så fald hvordan, indstillingerne til disse prædikater skal gemmes.. ..Hm, og hvad med grundfiltrene..?.. 

%...Hm, brugere skal nok bare være entiteter fra starten, og så bør brugerne bare advares mod at lave offentlige profiler med en spcifikt identitet angivet, medmindre man er klar på at blive vurderet af andre. Jeg skal i øvrigt også lige finde ud af, hvordan brugere sletter.. ah, men hvis hver dataentitet bare gemmer uploadende bruger, så kan forfatter-botten jo bare slette felt-vurderinger om uploadet, hvis pågældende bruger ønsker det.. Ja, det må være fint nok.. 
%Lad mig i øvrigt lige sige, at min anden idé fra i formiddags handler om, at der både skal være en ".related predicate=" (er gået væk igen fra at bruge ':') -relation \emph{og} en ".subcategories of related predicates="-relation for hver term (og særligt hver kategori-term). På den måde kan en kategori altså i praksis bruges som sig selv og som den afledte kategori af relaterede prædikater (til den kategori) på én gang, uden at man først skal navigere fra førstnævnte til sidstnævnte kategori for at nå frem til "subcategories of related predicates," når det er det, man ønsker. Med andre ord bliver den afledte "related predicates"-kategori altså nu en slags "anonym kategori," der ikke behøver at oprettes, men som bare automatisk følger med hver kategori (og andre typer termer), nemlig ved at man konstruere omtalte relationer, som så at sige springer det led over, at man ellers først skulle navigere til denne afledte kategori (som så nu er "anonym"/underforstået i stedet). ..Men dette skal jeg altsammen også skrive om i den renderede tekst. Nu vil jeg dog først tage en gåtur (i det virkeligt fine vejr *(he, nå, det var faktisk ikke særligt meget sol at komme efter, og det var endda også lidt koldt og blæsende --- så endda nogle (meget) små snefnug til sidst på turen)) og tænke over filtrene/vægtningerne... (13:46)
%... (14:35) Okay, jeg tror jeg ved, hvordan det skal være med filtrene og grundfinltrene. Det bliver simpelthen også, at brugerne rater filtre op under en grundfilter-kategori. Og så kan applikationen bare vide, at hvis de rater over en vis (væsentligt større end 0) tærskel, så skal applikationen initiere dem fra start af. Og hvis de er lige under den tærskel, så skal de bare vises, når brugeren går ind i, hvad der så kommer til at svare til grundfilter-indstillingerne, men som altså nu også bare er nogle termer ordnet i kategorier og underkategorier via (i dette tilfælde specifikt brugerens egne) ratings. Og så skal der også bare være en anden form for kategori, som handler om både at sætte filtre og vægtninger, men hvor det så er meningen, at de samme prædikater som benyttes her også vises, når brugeren indstiller et filtrene--vægtningerne for en specifik kategori/term. Så brugeren kan altså bryde disse indstillinger midlertidigt --- og hvis brugeren vil, kan denne jo også bare gemme ændringerne som en ny start-indstilling.. Ja, lad mig kalde det "grundindstillinger" og "startindstillinger," disse to forskellige ting. Og så er forskellen altså, at "grundindstillinger" derimod ikke vises, når brugeren skal lave en specifik indstilling for en term/kategori, men i stedet skal brugeren altså helt ud og ændre i sine grundindstillinger, nemlig i en del af brugerens samlede semantiske træ, der ligger mere yderligt, hvis brugeren vil ændre disse. Nå, nu skrev jeg godt nok, at man skulle have specielle "kategorier" med hhv. gundinstillinger og startindstillinger, men idet jeg skrev det, kom jeg til at tænke på, at det jo nok hellere skal implementeres via specielle relationer, som tager kategorier som subjekt. For på den måde kan brugeren lave forskellige grund- og start-indstillinger for hver kategori (hvor underkategorier skal arve overkategoriens indstillinger), og det var nemlig en del af mine tanker omkring det. Så ja, det må være sådan i stedet. Og hermed bliver disse indstillinger altså også bare en del af det normale semantiske træ (som udspringer af 'kategorier af kategorier'), ligesom at 'relevante prædikater' også bliver det samme. Så når brugeren vil ændre på, hvilke grundindstillinger, hvilke startindstillinger og hvilke relevante prædikater skal vises for en given kategori og alle dens underkategorier, så gør de det altså bare ved at rate dertil egnede relationer (med pågældende ønsker som relationsobjekter i disse) med kategorien som subjekt. Og hvis brugeren så vil ændre i sine indstillinger, eller hvis denne eksemepelvis vil søge i prædikater, som brugeren har brugt før, jamen så kan de bare vælge den "brugergruppe," der kun består af dem selv, når de vil query'e det semantiske træ. I øvrigt kan brugeren nemlig også oprate de kategorier, der indgår i alt det her, sådan at brugeren for denne visning (der kun viser termer, som brugeren selv har ratet) kun ser alle de relevante kategorier, og altså ikke en lang liste som også inkluderer alle mulige kategorier, som brugeren ikke har gemt nogen indstillinger for. (14:57)
%*Nå ja, jeg glemte lige at nævne, hvad jeg kom til at tænke på sidst imens jeg skrev dette, nemlig at der dog stadig gerne må være et "arbejdsbord" i applikationen, som jeg har tænkt mig, men hvor dette arbejdsbord så bare er helt ustruktureret, således at det bare er de nyeste tilføjelser, der bliver vist først, og hvor appkilaktionen måske heller ikke nødvendigvis gemmer ting i denne liste imellem sessioner (ikke som standard i hvert fald), men at hvert arbejdsbord altså bare glemmes, når en session lukkes. (15:13)

(14:57) Jeg har nogle gode noter ude i kommentarerne over denne paragraf (og efter den forrige renderede paragraf). Jeg har dog også i sinde at gentage de ting her i den renderede tekst i denne sektion. Først tilføjer jeg dog lige nogle få flere kommentar-noter lige under denne paragraf (og før den næste renderede paragraf). 

%..(15:00) Hm, jeg vil bare i hvert fald for det første lige nævne, at dataentiteter selvfølgelig bare "slettes" ved at dataen i dem nulles. Nå ja, og så vil jeg også lige nævne, at hvis nu man gerne vil lave en forælderkontrolleret applikation over dette system, jamen så må man næsten lave en slags browser, der kun kan starte på denne sem-net-hjemmeside, og hvor man så \emph{ikke} kan ændre i grundfiltrene (i hvert fald ikke i visse af dem). Og samtidigt bør man så have nogle specifikke whitelistede href-domæner, som er de eneste brugeren må følge, også selv når brugeren har navigeret over til de hjemmesider (så børnene ikke kan navigere videre til forbudte domæner fra de domæner heller). (15:04)

\ldots (15:19) Hm, nu hvor jeg har skrevet så meget ude i kommentarerne (dog i et ikke særligt detaljeret sprog, så jeg skal helt klart skrive det igen her i den renderede tekst på et tidspunkt), så lad mig bare lige nævne, hvad der var min idé nummer to her fra i formiddags, og så kan jeg lige sige nogle flere ting om den også. Jeg forstiller mig, at alle termer, og særligt kategorier, skal have to relationer, som man kan gøre brug af (og som altså nok især er gavnlige for kategorier), nemlig `.relevant prædikat=' (er nemlig gået væk fra at bruge `:') og `.underkategori af relevante prædikater='. På en måde ville disse lister egentligt være mere naturlige at vise som børn af en kategori, som kunne hedde: `kategori over relevante prædikater til kategori $x$,' hvor $x$ så ville være den kategori, man startede på. Men ved brug af de to omtalte relationer kan vi altså springe dette mellemled over, således at brugerne altså ikke behøver at oprette denne afledte kategori for hver af de mere normale kategorier. Nå, men imens jeg skrev dette, kom jeg så til at tænke på, at dette faktisk ikke relaterer sig så direkte til den ting, som jeg gerne ville nævne, alligevel (og som jeg ikke har nævnt ude i kommentarerne heller). For den ting handler i stedet om en tredje relation, som bare kunne hedde `.relevant kategori='. Tanken er så, at hvis man eksempelvis vil se en liste over kendte hunde, jamen så kunne man eksempelvis starte med at navigere hen til en zoologisk kategori, og så finde termen `hund.' Men fordi man ikke er interesseret i de generelle koncept `hund' (og generelle informationer om hunde), så kunne man så måske være heldig her at finde en ``relevant kategori'' af `kendte hunde' (og hvis ikke, kunne man jo så selv tilføje denne). En alternativ rute ville jo være fra starten af at vælge en overkategori af specifikke dyr, men det vil jo være rigtigt godt, hvis der er mange gode veje i det semantiske træ til, hvad man leder efter. Så dermed kunne denne relation altså også blive gavnlig. Bemærk i øvrigt også, at denne relation også kan bruges på kategori-termer, nemlig som en måde at finde relaterede kategorier til en given kategori (f.eks.\ hvis nu man står på kategorien `hunde' i stedet i vores eksempel), som altså ikke hverken er under- eller overkategorier til kategorien, men som er relateret mere ``søskendeagtigt'' eller mere ``horisontalt'' så at sige, hvis vi forstiller os træet som groende nedad (selvom jeg nu tænker det meget som groende mod højre i hovedet.\,.). (15:38)

%..Lad mig også lige hurtigt nævne herude i kommentarerne, at jeg virkeligt synes godt om, at brugerne nu får meget større encitament til at benytte kategorierne (og putte ting i kategorier), fordi dette nu jo hjælper deres egen brugermuligheder direkte. Og dermed så bliver der altså en endnu mere forstærket sammenhæng mellem, hvad jeg ser som systemets ben i form af `semantisk strukturede ressourcer' og så til `tag-rating'-benet, som (i.e. sidstnævnte) jo nok er det ben, hvor meget af brugerinteressen ligesom skal/vil udspringe af i starten. Og det er nemlig rigtig dejligt, hvis brugerne så også hurtigt kommer i gang med at få glæde af det andet ben i idéen, nemlig benet omkring den semantiske træstrktur af ressourcerne. I øvrigt kan jeg nævne, at jeg også ser et trejde "ben" på næsten lige fod med de to første, og det er benet, der handler om "brugerdrevne algoritmer --- bygget på anonym og ikke mindst fuldstændig gennemsigtig (og frivilig) indsamling af data." Jeg ved godt, at der er flere elementer i det ben, men ja, når man samler disse dele af idéen (altså dem jeg nævnte her inden for gåseøjnene), så synes jeg altså, at dette også udgør et vigtigt ben i den samlede idé, som kan ses på ret meget lige fod med de to første. (15:47)




\chapter{Hopes for the future}

\section{Some hopes for the future in terms of what my ideas can hopefully help bring about}
\label{Some_hopes_in_terms_of_my_ideas}

(16:35, 24.01.23) In terms of my SRC idea, my other economy-related ideas, and my ideas about happiness and local communities.\,. %Oh wait, I have some other stuff that I want to write about my web ideas.. ..Hm, jeg tager lige en kort pause og for samling på de og disse tanker.. ...Oh no, they are actually related to this section.. But.. Hm, let me just mention them in the Web ideas section first.. ..There..
\ldots I really hope that this can lead to a future where people generally are busy with activities/businesses that are much more efficient in adding to their own and other people's happiness and at the same time much more efficient in advancing our technological level. The way I see it, the two things goes quite a lot of hand in hand, cause in my opinion, the way in which we busy ourselves according to the current societal systems are just very wasteful. Most of these activities deals with bettering the lives of, well, consumers, but I believe that if you look at the calculation in terms of how much the activity of each person actually benefit or total happiness, this activity is generally very inefficient. The big trouble is that our society is geared towards an unspoken, unelected ``philosophy'' that consumption brings happiness, when in reality there are much, much, much, much more important things to consider, especially in generally wealthy societies. I thus believe that if we really think about it and start planning our lives and societies better (in a decentralized way, btw), we can achieve much more happiness as people for a fraction of the effort. And this means that we can generally spend much more effort into activities that advance our technological level as well, so its really a win-win; if we optimize our activities in terms of bringing more happiness to people, we can then also spend more energy on activities that advances us as a civilization.

Okay, so that was some very broad strokes in terms of describing what my ideas related to these topics might be able to help achieve, namely without giving any reason for why I believe they can help achieve this. In terms of my economy-related ideas that aims towards less capitalism, I then believe that these ideas can basically help us get out of said unspoken, unelected ``philosophy;'' help us get away from that direction as a society. 

And then there's the idea, which I haven't written about in a long time, about being able to ``pay workers/contributors backwards'' (what I have often called ``bagudbelønning'' in my Danish notes). I think this could bring about a lot of good in the future, but probably in terms of the web more so than anywhere else. I have just written somewhere above that I hope that the scientific community will generally join and take big part in the semantic web at some point in the future. I then also really hope that this will bring scientist and all other people much closer together, with amateurs also being able to take quite a big part in science and knowledge sharing.\,. which they already do a lot, come to think of it. And I hope that a good community around giving donations to helpful contributors, both amateurs as well as professionals (to thus add to their total income), can do a lot of good for the web. Maybe this ``backwards payment'' could even be a big part of getting scientist to join the semantic web in a big way.\,.

And in terms of my happiness ideas, well that goes pretty much without saying: If these ideas can be efficient in bringing happiness to people, this can then save a lot of wasteful and inefficient work/business/activity at bringing consumers happiness, and this saved activity can then be used on other things instead. 

In terms of the ``planning'' of how to change direction as a society, finding what problems to solve, and in terms of finding out what can more efficiently bring people happiness, I think that the semantic (and user-driven!) web can really help with all these things, potentially. One of the reasons for this is of course that I believe that we will be able to discuss matters much better on the semantic web, both in terms of the quality of discussion (because they can be better structured and because more people can be engaged in a single discussion), and also in terms of the quantity of active discussions that we as a civilization will be able to handle at once. But apart from this more trivial point, I also think the future (user-driven) web really can help people find together with other people with similar interests, and can be used much better to find ideas for activities --- and also ideas to structure one's life. Ugly sentence (and I've had a lot of those today), but I hope it makes sense (at least if one has read my previous notes.\,.). Thus, I think that the ideas regarding ``user groups'' and ``user-driven ML'' will make people able to much better find things that interest them, and to be able to much better find people to be friends with. And as I have written about in my earlier notes, I hope that we will get to a point in the future where it will be normal for people to move together in small or larger communities with others that share similar interests, a similar demeanor, a similar approach to life, and so on, and that people will thus end up living much more in communities with exactly people they want to be around, instead of just living more or less with a random sample of society around them, and then having to look for friends other places. 

Alright, this summarizes the some points of what I hope my ideas can help achieve. I know this section, what I have just written, isn't super well-written and easy to understand (without understanding the ideas mentioned already), but I just had to write these thoughts down, at least for my own sake. So here we are.\,.\,:) (17:58)


(15:38, 26.01.23) Copied from above: ``And just to make clear, there is also another great point, which might not be so easy to ``sell'' since it is hard to argue that things will go according to how I imagine them, but which is really the big underlying reason why I'm so interested in all this. The point is that I believe that this technology can get us to a point where all of science can also be structured in a great semantically linked graph such that is becomes easy to look at all point and counterpoints to a given question, and to look at all existing solutions to a problem (and see arguments for their benefits and drawbacks). The same can also be said for open source programming: I believe we can get to a point where all programming solutions (modular) can be ordered in a great semantically linked graph. I believe that my ``Web 2.1'' ideas here, as we can call them, potentially might be able to bring about such a future, and I really think that this will mean so much for our scientific (and societal) advancement.\,.\,! %(Let me by the way mention here in the comments that I have thought about this today and reconsidered if I still really believe that my Web 2.1 ideas can lead to this, and luckily I have sort of arrived at the point where I think I will double down on that belief. For the way I see it, having a semantic graph over web content can very well become very popular, and this might very well further lead to the scientific --- and open source programming --- community/ties also making use of this technology to structure all scientific knowledge and discussion (each individual scientist (or programmer or amateur) taking part partly of selfish reasons to make their work reach a larger audience). And once such a well-structured graph becomes a reality, I believe this will... Hm, let me actually write this in the rendered text instead.. )
Let me by the way mention that I have thought about this today and reconsidered if I still really believe that my Web 2.1 ideas can lead to this, and luckily I have sort of arrived at the point where I think I will double down on that belief. For the way I see it, having a semantic graph over web content can very well become very popular, and this might very well further lead to the scientific --- and open source programming --- community/ties also making use of this technology to structure all scientific knowledge and discussion (each individual scientist (or programmer or amateur) taking part partly of selfish reasons to make their work reach a larger audience). And once such a well-structured graph becomes a reality, I believe this will greatly increase people's --- scientists/programmers as well as all other people --- ability to look up specific knowledge and to engage in discussions and innovation/solution-finding processes. I thus see that this technology can maybe sort of create a giant online collective intelligence --- not an artificial intelligence, but metaphorically speaking still a big collective brain. These are large words, but I really do think that such technology will give us intellectual powers as a civilization that is many times greater than what we have now. Anyway, I hope so.''


(12:13, 27.01.23) Hm, I think that AI and semantic web technology can potentially both be really instrumental in the development of each other: I believe that the development of A.I.\ can be greatly accelerated by having an open ``predictive model,'' as I have called it (or we could it a predictive knowledge/statement graph.\,.), with a lot of active users, and I also really think that AI could help the the development of such graphs a lot, namely since AIs could help generating a lot of these graphs automatically. I really see the potential of a great ``symbiosis'' in this regard.\,. But let me point out, that AIs will not be able to give us such predictive knowledge/statement graphs on their own, since a big part of these are open and free way for each user to implement various algorithms for distributing trust. Furthermore, while future AIs might get the ability to keep an internal ontology over the (conceptual) world, such an ontology might be very unreadable to humans, unless said internal ontology developed ``in symbiosis'' with a human-readable semantically structured knowledge/statement graph. (12:24)



















\chapter{Existence theory}


\section{Empathy utilitarianism}

(19.01.23) Jeg tænkte i går (omkring kl.\ et, var det) for sjov på, at man kunne kalde min etiske lovsætning, som jeg har beskrevet i de udkommenterede noter i Chap.\ \ref{notes_from_2022}, for `empatilitarisme.' Og så kom jeg så efterfølgende til at overveje seriøse bud på et navn, og så kom jeg jo hurtigt på, at man kunne kalde det `empatisme.' Umiddelbart et ret flot og passende navn. Nå, men lidt efter fandt jeg så også på, at et oplagt navn jo ellers vil være `empatiutilitarisme.' Jeg har i øvrigt ikke søgt på, om det allerede eksisterer, det kan også godt være. Men hvis ikke denne etik er kendt allerede, så håber jeg altså på, at jeg kan (være med til at) udbrede den. Og så kunne `empatiutilitarisme' (`empathy utilitarianism' på engelsk) altså være et ret passende navn. (12:39)



(26.01.23, 17:53) Princippet om, at ``alt hvad der kan eksistere, eksisterer,'' er vistnok (allerede eksisterende og) kendt under navnet `the principle of plentitude'.\,.

Det virker i øvrigt på den PBS space video (kendte ikke kanalen før), som jeg lige faldt over (hvor jeg lige har hørt om the principle of plentitude), at MUH gør nogle flere antagelser i sin konventionelle udgave, end den egentligt behøver. Men det kan selvfølgelig også bare være kritikernes overfortolkning af det (det virker som en standard ting i filosofi: Kritikere kan altid bare overfortolke et udsagn eller en teori, og kan dermed så nemt finde en måde at erklære sig dybt uenig med det/den.\,.), det ved jeg jo ikke. Men hvis ikke det bare er en overfortolkning, så kan min, mere generelle, udgave af hypotesen altså helt sikkert være gavnlig. Og selv hvis det bare er en overfortolkning, så er jeg stadig ret overbevist om, at jeg kan hjælpe diskussionen på vej en hel del. (Umiddelbart tror jeg også, at de fleste mennesker, selv fagfolk, har en ret specifik forestilling om, hvad matematik er, hvilket jo så gør det let at overfortolke hypotesen, når man så navngiver den `MUH'.\,.) (27.01.23, 12:02) .\,.\,Det skal faktisk også nævnes, at selv hvis den konventionelle udgave har færre antagelser, end at nævnte video antyder, så er det dog stadig helt sikkert, at min teori er meget mere generel end den konventionelle MUH/CUH, for det virker helt klart til, at denne om ikke andet antager hypotesen om, at der ikke er nogen global tid, og (samtidigt) at den regnemæssige kompleksitet af et univers ikke har noget som helst at sige. (Dette er en fornuftig nok hypotese, men man behøver den ikke; man kan sagtens arbejde med en mere generel mængde af muligheder.)

%Hm, lad mig lige endeligt søge på, hvad der er af grene inden for utilitarisme..
(12:47) For at vende tilbage til `empatiutilitarisme,' så har jeg lige søgt på utilitarisme, og det virker til at den eksisterende idé om `preference utilitarianism' på en måde er ret tæt på mine idéer. Dog synes jeg min version med `empatiutilitarisme' er meget mere elegant, og man behøver ikke at tilføje alle de caveats, som præferenceutilitarismen gør. Og tilmed følger der også en god forklaring med til ``empatiutilitarismen,'' hvilket der ikke rigtigt gør for præferenceutilitarismen, ser det ud til. Og hertil skal det siges, at jeg ikke engang synes det er nødvendigt at antage, at vi selv for all intends and purposes kommer til at leve alle mulige liv igen og igen, før at empatiutilitarismen er begrundet; jeg synes også en etisk grundsætning om at man bør leve som om, at man skal leve alle mulige andre liv, giver ogd mening i sig selv, nemlig fordi den bare er ækvivalent med at sige: ``Sæt ikke din egen oplevelse af lykke og smerte --- og andre følelser --- foran andres (når du skal beslutte, hvad er etisk godt og etisk dårligt i princippet).'' 

I øvrigt så er min udgave af utilitarismen (``empatiutilitarisme'') også meget præcis, når det kommer til, hvilke levende væsener, man bør (og ikke bør) begrænse det til, (nemlig fordi man bør antage, at man skal leve deres liv også (så vidt man tror på, at væsnerne kan have en bevidst oplevelse, og så vidt man tror på, at de kan føle diverse følelser)), og hvordan man skal forholde sig til spørgsmålet om, hvad det betyder at noget tilfældigvis fik et vist udfald frem for et andet. Og min teori behøver heller ikke at snakke om, at nogen personer ikke forstår, hvad der er godt for dem, osv., for ``empatiutilitarismen'' fodrer ikke, at individer, der overvejer, hvad der er etisk godt og dårligt, kan blive enige om det --- ja, faktisk så antager min teori ingen gang at der findes noget ultimativt svar på det!\,. Den siger bare, at hvad person, der stiller sig selv spørgsmålet om, hvad der er etisk godt eller dårligt, i princippet skal lede efter svaret ved at forestille sig, at vedkomne skal leve alle mulige liv (og særligt livene af de personer, der er berørt af vedkomnes handlinger (og hvor man jo gerne vil maksimere den samlede lykke (forventet af individet og dennes evne til at leve sig ind i disse andre menneskers sted) ud fra et statistisk synspunkt --- medmindre, i princippet, at man selv forestiller sig, at man i andre menneskers sko heller ikke ville have lyst til at maksimere lykken fra et statistisk synspunkt, men så er vi også virkeligt langt ude.\,.)). (13:10)



\chapter{Notes from 2022 (out-commented)} \label{notes_from_2022}




\begin{comment}

Disse noter er bare nogle korte ting, som jeg ikke har lyst til at skrive ind i mit nuværende "main-tex"-dokument (altså mit 2021-22-notesæt), og jeg gider heller ikke starte et nyt (2022-xx-)notesæt lige nu, bare for det.. Så dette dokument bliver altså et slags mellemled. (08.07.22, 12:19)



## Tanker fra i morges (08.07.22) omkring bl.a. børneopdragelse, men også meget mere

Jeg tænkte bare lidt på, at der sådan noget som børneopdragelse, og også sådan noget som hvordan man skruer en hverdag og et (sam-)liv sammen som et andet godt eksempel, at der kan jo være rigtigt mange forkellige parametre og stille på: rigtigt mange forskellige tilgange, man kunne eksperimentere med. Og min pointe, jeg har lyst til lige at notere, er, at med mine web 3.0-idéer så kan folk jo på globalt plan diskutere sådanne tilgange, og ikke mindst arbejde på at sætte omtalte parameterrum op --- og her kan man helt sikkert bruge ML som en stor hjælp. Så vi vil altså i fremtiden kunne få et meget bedre overblik over sådan et helt rum af forskellige tilgange. Dette kan man så diskutere omkring og analysere, og bl.a. prøve at gætte på, hvilke parametre, der kunne spille godt sammen, og hvad der kunne passe bedst til forskellige omstændigheder/forudsætninger. Så man vil altså i dette globale netværk meget bedre kunne opstille en masse forskellige muligheder, og derfra bruge dette til at komme med gæt og forudsigelser, som er værd at slå ned på og "undersøge." Og i de to tilfælde, i.e. børneopdragelse, samliv generelt, og også bare >>liv<< generelt, der betyder at "undersøge" jo så, at nogle mennesker og/eller nogle lokalsamfund prøver at teste nogle af disse hypoteser simpelthen ved at udleve dem (i en længere periode i det mindste). Og med sådan et globalt (videns)netværk, så vil man hurtigt kunne opnå det samme, og meget mere endda, end hvis man havde kreative teoretikere (eller hvad man skal kalde sådan en som mig) til selv at udtænke diverse tilgange, der kunne vise sig at bære frugt under diverse forudsætninger. Og en side-konklusion er så derfor også lidt, at selvom jeg tror, dette emne *(omkring børneopdragelse og sådan noget) lige præcis er et, hvor jeg kunne være god, og hvor jeg kunne lægge rigtigt meget arbejde potentielt set (i fremtiden), så vil dette altså være endnu en ting, hvor mine 3.0-web-idéer også bare (formentligt(7, 9, 13) og fohåbentligt!) vil komme og ændre billedet totalt (og i sådan en grad, at der vil være langt mindre behov for enkeltindivider, eller enkelte små grupper, til at designe sæt af gode tilgange fra bunden og op). (12:38)
%*(18.08.22, 13:39) Denne idé/tanke er jo meget en naturlig fortsættelse af mange af mine andre tanker. Det er jo lidt bare, at man kan skabe gode muligheder for diskussioner, og så vil befolkningen meget hurtigt og effektivt kunne udvikle en masse gode nye idéer, gode nok til at de er værd at afprøve. Denne del af det ligger senere end nogle af de andre forestillinger (f.eks. vil disse muligheder sikkert først komme rigtigt en del tid efter, at man får gode muligheder for debatter.. men ja, jeg tror helt sikkert at dette også vil blive et resultat af hele den udvikling på sigt). Og lad mig så også lige nævne en lille ting, som nok egentligt (også) burde stå i en "sektion" med et andet navn: Jeg vil bare gerne lige understrege, at ja, jeg tror virkeligt på, at vi med denne udvikling, som jeg forudsiger, vil blive gode til at diskutere ting godt. Og ja, faktisk tror jeg på, at vi i en ikke al for fjern (faktisk rimelig nær) fremtid også vil blive i stand til som befolkning(er) (globalt og lokalt), virkeligt at få diskuteret grundigt, hvordan f.eks. vore politik skal være (lokalt, men også mere globalt), og i det hele taget hvilke nogle retninger, vi skal bevæge os som samfund, og hvilke mål vi skal betræbe os --- og hvordan vi skal bære os ad med dette. Dette bliver dog ikke en ting vi opnår lige med det samme: Det ligger altså nok som en af de lidt fjernere muligheder. (Der er nemlig mange muligheder, som denne udvikling vil bringe, som vi hurtigt kan få gavn af, og så er der altså også nogen, som nok vil tage længere tid om at komme ordentligt skub i. Og ja, denne sidstnævnte ting er nok ikke en situation, man skal forvente vil opstå med det samme, men jeg tror altså som sagt, at der ikke vil gå mange mange år, før den beskrevne situation bliver en realitet.) (13:50)


## Fortsat omkring diskussioner og videndeling, som det fremtidige internet vil åbne op for

(05.09.22, 20:08) Jeg har sikkert nævnt dette hurtigt et sted i mine 2021--22-noter, men noget andet som virkeligt bare vil blive godt i fremtiden, er når vi kan få bygget en god ontologi / et godt kort over, hvilke personlige problemer og/eller klager og/eller ønsker folk har i samfundet. Det ville hjælpe samfund (altså vores nuværende store samfund, i.e. lande) gevaldigt, hvis forskellige befolkningsgrupper nemt kunne få langt større indblik i, hvordan de andre befolkningsgrupper har det, og hvilke problemer de slås med. Og så vil man jo i det hele taget også bare kunne overveje politiske beslutninger sammen meget mere effektivt, hvis man har tingene (altså ønsker/klager/problemer) kortlagt så godt på den måde. Selvfølgelig kan man komme ud for, at folk smørre tykt på med, hvor store deres problemer er i forhold til andres, men så skal man jo bare lige sørge for, at det hele først bliver diskuteret og analyseret endnu mere (hvor man bl.a. kan tage stikprøver især fra folk der ligger lidt på kanten mellem to befolkningsgrupper (og/eller på anden måde har en position, hvor de har indsigt i, hvad sandheden egentligt er, men ikke har en personlig bias for selv at lyve/smøre tykt på)), inden man begynder at behandle det som fakta, at så og så mange borgere har et så og så stort problem med det og det. Så ja, det kan vi altså også se meget frem til --- det er desværre nok en af de ting, der kommer til at ligge meget sent i hele udviklingen, desværre, men vi skal nok nå dertil på et tidspunkt som (global) civilisation. (20:19)



[...]




## Web 3.0-bevægelse og forretningsidé

(07.08.22, 20:51) Hvis jeg skulle starte en virksomhed for at komme i gang med at opnå de drømme, jeg har om dette emne, så ville jeg fokusere på at starte med at lancere en web 2.0-side, det opfylder kravende fra min "forretningsidé" (om at kunder skal blive til medejere, og at det hele skal gå på omgang osv. osv. (se noterne i main.tex fra i januars og/eller februar, eller hvornår jeg helt præcist skrev dem)), og så vil jeg også virkeligt prøve på hurtigt at få indført, at betalende brugere for stemmemagt over en rigtig stor del af.. ja, af hvad jeg vist har kaldt skaber-aktierne, men nærmere bestemt, så vil jeg sørge for, at disse starter med at udgøre en rigtig stor andel af de samlede kunde/skaber-aktier, og så vil/ville jeg altså sørge for ret hurtigt at få indført, at det er brugerne/kunderne, der har høj stemmemagt over, hvordan diverse skaber-bidrag belønnes (med de skaber-aktier, som virksomheden uanset hvad alligevel er kontraktbunden til at udstede til nogen). (20:59) ..Og ja, så vil jeg bestemt også sørge for, at det hele er open source (og jeg ville bestemt prøve at få eksisterende open source programmører med på bølgen (som "skabere")). ..Og ja, derfra må man sige, at jo hurtigere brugerne kan begynde at føle, at der er flere muligheder på siden, bl.a. ved at der kommer flere og flere (open source) algoritme-muligheder, jo bedre, for det er jo så der, man kan begynde at tiltrække brugere/kundere på baggrund af selve indholdet/rammerne(/mulighederne).. (..og altså ikke bare på baggrund af hele forretnings- og open source-idéen ved det; pga.\ nutidige muligheder for brugerne, og ikke bare på baggrund af fremtidige visioner.) (21:04)

(17:42, 19.09.22) En god måde at starte et web 2.0-til-3.0-firma (med min forretningsidé), kunne bare være at starte et firma og en kickstarter, og så bare love, at alle donationer hurtigst muligt vil blive omdannet til kunde-aktier, så snart papirarbejdet er gjort. Angående iværksætterenes og arbejdernes egen aktie-gevinst, så kunne man jo bare sige, at der lige i starten gælder, at.. Tja, eller man kunne faktisk sørge for hurtigst muligt at brugere kan uploade og stemme om vedtægter på en hjemmeside over, hvordan lønnen skal fordeles. Og så kan der bare være en fast klausul fra starten om, at en vis andel af al denne løn i denne indledende fase skal gå som løn til iværksætterne, og/eller at disse så også for nogle kunde-aktier genereret herved, svarende til en lille procentdel af denne løn. Måske kan man endda også vedtage, at lønmodtagerne i denne indledende fase også skal have nogle procentdele af deres løn i form af kundeaktier. Og i starten vil alt dette så bare baseres på løfter (men hvor iværksætterne muligvis alligevel kan retsforfølges, hvis de bryder disse løfter, fordi de så har handlet falskt og har fået betaling for en vare, som de så har valgt ikke at levere --- hvilket kun er godt, hvis de kan det, også for iværksætterne selv, fordi dette så vil få flere kunder til at stole på opstarten). Men hurtigst muligt skal man altså have udarbejdet kontrakter osv., så man kan gå ind i en ny fase, bl.a. hvor folks stemmeret omkring løn m.m. er mere konkret og detaljeret udarbejdet og sikret.. (17:53) 
%..Og hvad skal firmaet så starte med at lave? Jo, det skal såmen, udover at få styr på kontrakterne til fase 2, planlægge og give løn for programmeringsbidrag til en open source web 2.0-side (gerne én der både kan fungere som YouTube, Twitter og Reddit (m.m.) på én gang (og også gerne Wikipedia, men det kan godt komme lidt senere), men hvor man altså bare kan starte ét sted (f.eks. som en Reddit- eller en Youtube-agtig side)), og så må man så regne med, at tingene bare kan rulle derfra --- det tror \emph{jeg} i hvert fald helt bestemt på, at de kan. ..(For man bevarer jo selvfølgelig bare et system, hvor aktionærerne (og dermed kunderne!) kan stemme på vedtægter omkring lønfordelingen.) :) ..Og så kunne man jo oplagt have endnu en faseovergang efter lidt tid, hvor man også får de sidste ting på plads, bl.a. om hvordan fissioner af firmaet (og måske fussioner med andre, hvis det virker realistisk) skal kunne foregå, plus hvad jeg ellers må have glemt her fra mine noter (i januars/februars)..:) (18:02)
%..(18:07) Hm, og selvom det godt må være open source lige i starten, så kan det godt være, at man hurtigst muligt vil lave et system, så det er rimeligt åbent at se, hvem har gjort hvad, og hvor det måske ikke kræver særligt meget at få adgang til selve kildekoden også, men hvor kildekoden alligevel er eget af firmaet og ikke må tages/stjæles af andre. (18:09)

(21.09.22, 11:09) Jeg kan ikke huske, om jeg har skrevet om dette før, men jeg kom i tanke om i går aftes, at det jo er ret vigtigt, at normale kunder ikke ligestilles med f.eks. andre firmaer. Et firma/"underfirma" skal altså gøre det klart, om dets services er til private kunder eller til andre firmaer (for hver service i det mindste). Man må f.eks. ikke komme ud i en situation, hvor en instans bare kan købe og videresælge produkter, og så få de samme kunde-aktier for det, som de kunder, der køber til eget forbrug. Så derfor skal man altså generelt kun sælge produkter beregnet til eget forbrug eksklusivt til eget forbrug (hvilket i øvrigt sikkert også er meget normalt for firmaer allerede her i nutiden). (11:13)

(27.09.22, 17:47) Okay, jeg har tænkt en hel del mere over forretningsidéen i dag (og også lidt i går aftes), og nu kan jeg se at: Never mind den der forestilling om at lave en kickstarter eller lignende og så forvente, at firmaet så kan brede sig videre og videre derfra. Det er jo for nemt for alle andre firmaer bare at konverterer over, hvilket jo i bund og grund er godt, men det gør jo altså, at der slet ikke bliver noget (BitCoin-agtigt)venture-hype omkring idéen, sådan som jeg ellers kom til at tænke det nu her, hvor jeg er begyndt at tænke over denne idé igen. Så never mind alt det med (som jeg sikkert har nævnt under "Planer" nedenfor) at idéen kan blive den nye "helt store ting" i den forstand. 
Tvært imod vil det nok ikke kunne betale sig at investere helt vildt i normale firmear, der begynder at konvertere til forretningsidéen, medmindre man på en eller anden måde kan mærke, at de konkurrerende firmaer ikke vil have evnen eller viljen til at hoppe med på bølgen, og derfor altså vil blive udkonkurreret (formentligt, hvis man tror på idéen) af det firma, man så investerer i. Så medmindre der kun er nogle gangske få firmaer, der formår at brande sig godt på at være med på den nye bølge, så vil det nok mere bare være en situation, hvor flere og flere firmaer langsomt vil konvertere til de nye forretningsprincipper. 
Der er så også lige den undtagelse, at nogen brancher jo netop kunne få rigtig meget god synergi med denne idé, hvor kunderne/forbrugerne/brugerne kommer til at bestemme meget, og her tænker jeg jo så særligt lige præcis på min idé til en ny web-forretning/bevægelse. Så lige akkurat her vil der altså muligvis være gode investeringsmuligheder, men bid så mærke i, at dette så ikke vil skyldes.. hvad der svarer lidt en pyramide eller boble, hvor de første investorer altså kan tjene kassen på baggrund af, at de kom lidt før de andre. I stedet vil det simpelthen bare skyldes, som jo er normen omkring investeringer, at den nye forretningsløsning har potentiale til at tilfredstille kunderne meget mere --- ikke bare fordi disse også er investorer (og i og med at de så får en pengesum i vente), men altså lige præcis bare i forhold til det produkt de bliver leveret som kunder! Fordi der altså er mulighed for at sådanne hjemmesider m.m. kan komme til at levere et meget bedre produkt (altså bedre funktionalitet, bedre tilpasningsmuligheder, større udvalg og bedre kvalitet af indhold osv.), så vil det altså være værd at investere i, og kun ligesom af den grund.. Tja altså, medmindre selvfølgelig at man også regner med et vist hype omkring det, men det er jeg nu slet ikke sikker på, vil komme, hvis man netop ikke har nogen grund til at tro, at virksomheden vil brede sig til andre brancher derfra (fordi dem med aktiver i forvejen der også bare selv kan joine den nye bevæglese til hver en tid). (18:07)

(02.10.22, 16:52) Det kan faktisk godt være, at der kan lægge en stor investerings/forretningsmulighed i, hvis nogen kan finde på et rigtigt godt brand og en tilhørende rigtig god (offentlig) plan for, hvordan upstarts-firmaet skal være forbrugernes falgskib for at få bragt liv i den nye forretningsbølge: Hvis man kan overbevise en stor gruppe kunder til, at "det er her det sker," og at firmaet er hvad, man bør "investere" i som kunde, hvis man gerne vil sikre sig, at bevægelsen bliver til noget.. Så ja, dette kunne altså potentielt være en mulighed, især hvis man altså kan finde på en godt sted at starte (måske med en supermarkedkæde, eller en eller anden stor og alsidig handels/salgs-forretning), som virkeligt har mulighed for at brede sig meget ud, og som dermed kan vokse sig kæmpe stor, hvis bare alle kunder pludselig begynder at priotere handler med denne i høj grad.
Men ja, dette er nu ikke ligefrem noget jeg forudsiger, bliver en mulighed; jeg siger bare, at der måske kunne være et potentiale. Og ellers så tror jeg altså på, at man hellere skal tænke i firmaer/brancher, hvor firmaet vil have direkte gavn af (ift. det produkt, de ender med at levere!), hvis kunderne kommer til at bestemme mere, og hvis det også er sikret, at det bliver de ved med. 
Og i den forbindelse, så tror jeg altså faktisk på, at dette kunne være tilfældet for nærmest alle brancher, der handler med noget digitalt på en eller anden måde, enten med indhold, film, spil, læsestof, nyheder, bruger-til-bruger-indhold.. you name it.. Alle sådanne brancher, hvor det enten er sådan, at brugere selv i høj grad til at bidrage til værdien af det digitale, man nu end snakker om, og/eller hvis bare vi snakker kreative ting som kan konsumeres digitalt, hvor brugerne samlet set vil drage gavn af, hvis der kommer bedre forhold for skabere/kunstere, og også ikke mindst at alting bliver mere åbent (uden at folk behøver at bekymre sig om, hvis andre stjæler). For ift. sidstnævnte, så tror jeg jo på, at man, ved at kunderne styrer, kan nå en situation, hvor skabere/kunstere kan "bagud-belønnes" for deres arbejde. Og derfor kan alt sådan noget blive meget mere open source. Hvis vi så f.eks. tager spilindustrien (som et rigtigt godt eksempel), så er det ret nemt at se, at den samlede brugerskare kunne drage kæmpe fordel, hvis skabere ikke var nødsaget til at gøre alting så lukket. 
Ok. :) (17:11)

(06.10.22, 9:29) Lad mig lige præcisere noget i den tekst i 21--22-noterne, som jeg skrev d. 12/02-22: Jeg skriver noget med at "opkræve penge" fra aktionærerne. Her mener jeg selvfølgelig ikke, at man sender dem en regning, men altså at man bare nedjusterer det afkast, de har i vente. (Det fremgår sikkert et sted, men nu synes jeg lige, jeg ville kommentere og rette det her.) ...Hm, vi kunne da sagtens snakke 40 år i stedet (20 virker da ikke vildt langt..), appropos samme tekst.. *(Ah, det var for ikke at gøre udsigten for lang til en ægte kd.v., så tja.. ..Ah, men i princippet kan den jo blive "ægte kundedrevet" efter en ret kort periode alligevel, for det handler jo bare om, hvor stor en stemmemagt aktionærerne giver til sig selv i starten og i hvor lang en periode den stemmemagt varer.! Så der er faktisk ingen grund rigtigt til at sætte en kortere kundeaktie-periode.!:) (10:12) ..Nå nej, det passer så ikke helt alligevel, for hvis perioden er for lang, så kan der blive et demografisk (m.m.) skel imellem gamle og nye kunder. Så ja, hvilken periode man skal vælge fra starten er lidt et åbent spørgsmål, men man skal så huske, at denne dog stadig skal justeres (langsomt) løbende, således at den kun er en vis faktor større end, hvad anlagsaktiv-størrelsen som minimum kræver..) ..Og appropos samme tekst, bemærk så at det der med at have en instans, der vurderer firmaets samlede værdi til forskellige tidspunkter (ved at se lidt tilbage i tiden, så måske et år eller to efter), det skal ikke forstås som et væsentligt krav. Det er bare godt at have, bl.a. fordi det altså så gør det mere fair overfor aktionærer, hvis aktier udløber over en periode, hvor firmaet gjorde mange nye investeringer, og at de samlede mere direkte penge-omregnelige aktiver faldt i perioden, på trods af at værdien steg. (Men måske kan sådan en instans også bare se på aktiernes værdi i handler som en god kilde, man lad mig lige genopfriske, hvad jeg endte med at beslutte omkring aktiehandler..) 
...(11:04) Det var måske ikke så tydeligt, da jeg skrev om at opdele virksomheden, sådan at IP(/IM)-skaberne lidt fik deres egen "undervirksomhed".. tja.. Tjo, tja, giver det ikke lidt sig selv, selvom jeg ikke lige fik formuleret det tydeligt? Tanken er bare, at de så kan komme til at tilhøre og sælge deres bidrag til en "undervirksomhed," som så kan have andre "undervirksomheder" som kunder, der så bruger IM-bidragene til at implementere f.eks. en Web 2.x/3.0-side. Ja, det var nok rimeligt selvsagt, men nu har jeg også sagt det her. 
(11:21) Det kan i øvrigt godt være, at jeg her ovenfor på et tidspunkt har glemt lidt igen, at der skal være klare sætninger for, hvem der er de primære kunder (som skal have kundeaktier), og hvem man ellers bare handler med. Men ja, dog kan man jo sagtens starte med at have "donorer" eller "investorer," som altså kun giver rene pengebeløb.. med som kunder.. tja, men det kommer ikke rigtigt til at fungere. ..Nej, i stedet skal sådanne investorer jo bare købe aktier med deres "pengebidrag," hvilke jo så i høj grad naturligvis vil være "start-aktierne," eller hvad jeg nu har kaldt dem (dem til de indledende iværksættere og investorer). 

(11:42, 06.10.22) Jeg bliver nødt til lige at slå følgende fast, for jeg har jo snakket lidt om, her for nyligt, at der "ikke er den helt store investeringsdrøm." Men det passer ikke, eller rettere: sætningen skal i hvert i så fald bare forstås relativt til, hvis nu situationen var, at en enkelt kundedrevet virksomhed ville kunne udbrede sig til det meste af markedet. Jeg siger som sagt ikke, at der ikke er en vis sandsynlighed for, at ikke-så-web-baserede kd.v.'er kan udbrede sig rigtigt meget, men det er nok lidt for stor en drøm at forvente, at en sådan kan udbrede til stor mængde af markede, for som sagt kan andre firmaer jo altid bare følge trop.. Tjo tja.. Whatever, det giver ikke mening for mig at sidde her og prøve at forudsige den ene eller den anden vej på det punkt. Det jeg i stedet ville nævne var bare, at man jo (og det havde jeg måske kortvarigt glemt ovenfor, det ved jeg ikke..) skal huske, at de web-relaterede bracher jo også er \emph{kæmpe} store i sig selv. Så never mind, "at der ikke er en stor investeringsdrøm i det," for hvis jeg har ret, og at mine idéer omkring en stor web 2.0--3.0-virksomhed virkeligt vil kunne udkonkurrere gængse web-virksomheder, jamen så vil der jo potentielt set være en kæmpe investeringsdrøm i det, det er klart. Selvfølgelig er intet sikkert, hvorfor det er vigtigt at understrege 'potentielt' i den sætning. Men ja, følte bare, det var ret vigtigt lige at pointere. :) Det ville være lidt ærgerligt, hvis jeg unødvendigt kom til at ende på, at "der ikke er så stor en investeringsdrøm i idéen." Det kan der jo nemlig selvsagt meget vel gå hen og blive. :)
Lad mig også bare lige gentage, at hvis nu det var mig, der skulle starte sådan en "kundedrevet" web 2.0--3.0-virksomhed, så ville jeg altså virkeligt prøve at gøre virksomheden tiltrækkende for ""open source"-programmører" og andre skabere som muligt, nemlig ved meget hurtigt at prøve at implementere et "bagud-belønning"-system, rigtigt gerne hvor kunderne (og måske også gerne tidligere skabere/programmører) hurtigt for stemmemagt ift. bagud-belønningen også (og i øvrigt gerne hvor man også prøver at opstætte retningslinjer omkring, hvem fortjener hvad for hvad). Og her skal "open source" altså forstås meget i gåseøjne: Vi snakker nemlig slet ikke open source bidrag, for IP-rettighederne skal meget gerne gå til en fælles pulje som eges af virksomheden (eller endnu bedre: en mere uafhængig instans/"undervirksomhed" som virksomeheden så er kunde hos..). Men når jeg alligevel kalder dem ""open-soruce"-programmører," så er det altså bare for at pointere/hentyde til, at deres arbejde i høj grad så kommer til at minde om open source-arbejde, fordi tanken altså netop er, at bidragsyderne bare kan bidrage rimeligt frit og altså uden at være ansat og/eller have underskrevet en masse kontrakter, men hvor de så alligevel kan få løn for arbejdet via bagud-belønnings-systemet. Så ja, det ville jeg sandsynligvis nok prøve at sigte efter, hvis det var mig, der skulle starte sådan en ("kundedreven") virksomhed. (12:07) ..Ah, og vigtigt: Jeg ville også bestemt sørge for, at denne "bagud-belønning" også i høj grad (i starten især) ville komme i form af "IM-skaber-aktier," det er klart, for så kan man jo dermed belønne dem (hvis alt går godt) meget mere fra starten, også selvom man ikke har de store indtægter (fra kunder) endnu, og samtidigt så også gøre alle disse programmører/skabere mere investerede (også altså i overført betydning) i projektet. Det kan godt være, man lige skal se denne sidstnævnte ting efter i sømmene og regne efter på det hele først.. men ja, det ville jeg jo så gøre, hvis det var mig, der skulle være med til at opstarte en kd.v., for umiddelbart ser det ud til, at denne sidstnævnte ting også kunne gå hen og blive rigtigt smart at gøre. Nå. :) Følte lige for at gentage/understrege disse ting. :) (12:17, 06.10.22)


(19.10.22, 10:29) Jeg har fået tænkt noget mere over min forretnings(bevægelse)idé. Jeg har skrevet lidt ny brainstorm i et andet dokument, hvor jeg i går overvejde igen at tage mere udgangspunkt i omsætningen, men det går ikke. Og nu er jeg faktisk kommet frem til, at jeg nok bør ændre idéen til en mere simpel udgave (overordnet set, for jeg har også nogle nye tilføjelser, som jeg fandt på i går, om frit at kunne købe en vis størrelse kundeaktie oven i sin egen som kunde).
I bund og grund tror jeg nu på (bl.a. fordi jeg har indset, at mange af mine tidligere bekymringer skyldtes en tanke om, at virksomheden skulle være den eneste af sin slags, men det skal den slet ikke.. hm, ikke på nær måske hvis man tænker en web 3.0-virksomhed.. det må jeg lige tænke over, men lad mig her bare skrive om idéen med tankerne rettet mod normal industri og handel).. Jeg tror nu på, at idéen faktisk er bedst, hvis bare man simpelthen har start-aktierne og kunde-aktierne som før beskrevet, begge med en vis fast udløbskurve, således at aktiernes "størrelse" starter på et punkt og efterfølgende aftager efter hver lille salgsperiode. Nu mener jeg så, at det så bare skal være frit op til den samlede mængde aktionære (via deres stemmemagt) at beslutte løbende, hvor stort et afkast skal betales pr. aktiestørrelse efter disse salgsperioder. Virksomheden skal så bare have åbne regnskaber, så alle kan følge med i, inklusiv fremtidige kunder, hvad virksomheden har af reelle omkostninger, og dermed hvad pris-markup'en er for hvert produkt over tid (hvor man så selv kan vælge som iagttager, hvordan man vil regne udviklingsomkostninger ind sammen med "produktionsomkostningerne"). Det er så fornuftigt at forvente som kunde, og fornuftigt at drive virksomheden som aktionær, således at markup'en er rimelig konstant, når man midler over en periode, f.eks. over et år eller to. Og den skal i hvert fald helst gøres så stor, at kunderne er mere investerede til hver en tid, end hvad de samlede aktiver er hver, hvis man skulle sælge dem. Og desuden er det også smart at have en højere markup, hvis man gerne vil give større encitament for aktionærerne til at træffe gode beslutninger frem for dårlige --- plus dette giver også en vis investeringsbuffer, så virksomheden ikke hele tiden teknisk set er på randen af konkurs, altså fordi den "kun lige løber rundt," kan man sige. Men en al for høj markup er dog heller ikke at fortrække, for det kan skræmme nye kunder væk, som ikke rigtigt har nogen kundeaktier i forvejen. Dette vil så gøre virksomheden sårbar over for, at en konkurrent kan melde sig på banen og tiltrække alle disse kunder. Så disse tanker bør man altså gøre sig, når markup'en og det løbende afkast skal udregnes (i forhold til produktions og udviklingsomkostningerne). Men det er selvfølgelig rart lige at huske, at i sidte ende så kommer virksomheden jo meget hurtigt til at være styret af en stor (og i mange tilfælde almen) gruppe mennesker, som dermed ikke vil have meget ud af at prøve at presse citronen over for nye kunder, da disse jo ofte i høj grad vil være dem selv. Og i de få tilfælde, hvor der kan være en anseelig forskel på gamle og nye kunder, jamen så må man også forvente, at hvis en (\emph{stor}) gruppe mennesker vil presse en anden (\emph{stor}) gruppe mennesker som forbrugere, så er der jo stor chance for, at den anden gruppe vil gøre gengæld. Hvis der altså vil ende med at være visse store grupperinger af forbrugere, så er det altså naturligt at forudse, at disse bare vil indgå aftaler med hinanden i stedet for at prøve at presse citronen og skrabe til sig.. Ja, og al denne snak er jo stort set ligegyldig, for det vil jo være meget sjældent, at der vil være stor forskel på gamle og nye forbrugere af en virksomhed, og hvis der er, jamen så vil det jo kun lige være midlertidigt, må man regne med. Ja, så never mind al denne snak i bund og grund. (11:00) 
Så ja, afkaststørrelsen pr aktiestørrelse, eller rettere aktiestørrelse der udløber, hvis nu kurverne ikke er lineære, skal altså bare bestemmes rimeligt frit af aktionærerne via deres stemmemagt, og det samme gælder alle priserne. "proportionalitetsfaktoren," som jeg har snakket om, hvad der også svarer ret meget til "markup'en," den er altså nu bare en implicit størrelse, som folk selv kan regne ud hver især (idet alle regnskaber skal være offentlige (samt i øvrigt også alt muligt andet i virksomheden, f.eks. også hele beslutningsprocessen, når det kommer til den overordnede ledelse af virksomheden)). Så nu skal kunderne altså bare foholde sig til en enkelt pris, og så kan de selv regne ud, hvad markup'en er på denne. I denne version af idéen tænker jeg så også bare, at aktierne udstedes i slutningen af enhver lille salgsperiode, således at den altså er propertionel med prisen divideres med det samlede salg i den pågældende periode. Det vil sige, at kunderne ikke ved eksakt hvor stor en aktie de får ved købet ned til hvert decimal, men de kan stadig regne det ud tilnærmelsesvist eksakt i de fleste tilfælde, for man må jo formode, at salget vil være rimeligt konstant. Og hvis det lige tager et hop op på et tidspunkt, så vil det jo ikke gøre det vildt store. Det virker altså ikke som om, at det vil være værd at indføre et buffersystem eller tilsvarende, bare for den mikro lille generelle usikkerhed omkring aktiestørrelsen, man får med i købet, slet ikke.. (11:09)
Så det er altså den store nye ændring. Jeg har i øvrigt så også lige nævnt, at virksomhedens regnskaber og ledelses-beslutningsprocess gerne skal være offentlige (for det vil helt klart være det værd fra kundernes synspunkt, frem for den lille makedsfordel det vil kunne være, at holde visse ting hemmelige). Så det vil jeg også fremføre som en del af idéen. Og så har jeg altså nogle nye tanker om, hvordan kundeaktionærerne skal kunne sælge og ikke sælge deres aktier.
Jeg har som sagt fundet på, at kunder jo gerne må kunne sælge deres kundeaktier til andre kunder, i hvert fald så længe en specifik kunde bare ikke kan købe mere en en vis aktiestørrelse i forhold til dennes originale kundeaktie(størrelse), altså den mængde aktier, vedkomne har tilegnet sig via eget forbrug. Hm, jeg skal egentligt lige tænke over, hvad man gør, hvis.. Hm.. (11:14)
(11:24) Hm, der er ingen grund til at give så mange restriktioner. Man kan bare sige, at man altså kun må sælge sine kundeaktier til andre kundeaktionærer, og at enhver kunde ikke må købe en aktie(størrelse), således at deres samlede aktie bliver større end, vi kunne jo sige det dobbelte, af deres nuværende del af deres aktie, som de har tilegnet sig via forbrug. Fordi nykøbte aktier dog godt kan aftage langsommere i størrelsen (f.eks. hvis man bruger en lineær forskrift), så kan man godt komme ud for, at forholdet overstiger det dobbelte i den efterfølgende fremtid, men det er også fint nok; man kan bare sige, at det ikke må overskride det dobbelte i selve handelstidspunktet. Denne forordning bør være tilstrækkelig til at sikre, at folk kan finde købere, hvis de nu gerne vil sælge deres kundeaktier (måske til en anesle lavere end, hvad de er værd), men systemet forhindrer stadigvæk tredjeparter i at komme udefra og opkøbe en majoritet i virksomheden, så denne ryger væk fra kundernes hænder. (Det gør også, at afdøde kunder, kan få "solgt" deres aktier videre (og dette bør man altså sikre sig, at de kan, selvfølgelig ved at deres arvtagere får lov at styre handlen). 
Jeg har vist i øvrigt også en lille note om fissioner, lad mig lige se, og var der så ellers andet, jeg lige skulle nævne?.. (11:34) ..Hm, nogle ændringer i mine planer, men var der ellers andet?.. ..Nej, det var der vist ikke, og ellers kommer jeg i tanke om dem. ..Ah jo, lad mig lige berøre amnet omkring, hvem der er kunder kort.. Virksomheden skal stadig have en beskrivelse og, hvad der er dets "servicer og produkter," og hvad der ikke er, og dette skal det kunne ændre i løbende, men gerne hvor der så er en vetoret, således at enhver stor nok mængde aktionærer (også alt efter hvilken type) kan vetoe enhver ændring. ..Ja. Mere er der sådan set ikke at sige om dette..
Min tanke angående fission var bare, (hvilket jeg også har tænkt på før) at man jo også potentielt set kunne forstille sig virksomhedssplittelser, hvor virksomheden bare dels i flere afdelinger, som administrerer (og har magt over) forskellige ting. Og så kan det så altså stadig være sådan, at kunder, der er mere kunde det ene sted, så vil få mere aktie og stemmemagt hos denne afdeling. Vi kunne altså forestille os en form for "blød fission," hvor den "hårde fission" så altså vil være, at virksomheden skilte sig totalt ad i to (eller flere). Dette er helt klart værd at have med i tankerne, når man skal overveje fissioner. Hm, i øvrigt tror jeg da egentligt sagtens, man bare kan planlægge fissionsreglerne efter at virksomheden er i sving; man behøver vel ikke nødvendigvis at planlægge disse ting fra starten af? Nej, det må man jo ikke behøve, for hvis kunderne har træng og lyst til, at sådanne fissionsregler skal være en realitet, så kan de jo også indføre dem.. Hm tjo, men det kunne dog måske være smart nok, hvis man som startaktionær lovede sine kunder, måske med en kontrakt indblandet, hvis det giver mening.. at man rimeligt hurtigt vil forsøge at udforme gode fissionsregler for virksomheden.. Hm.. ..Tja, det allerførste kd.v.'er på markedet kan jo nok sagtens bare give dette som et løfte (hvis de vil), og når så teknologien bliver mere udviklet, så kan eventuelle nye kd.v.'er jo bare adoptere andres fissionsregler. Og det vil betale sig for en virksomhed (der har udviklingspotentiale) på et tidspunkt at lave sådanne regler, da dette sandsynligvis vil behage den brede kundebase, og dermed vil det sænke risikoen for, at en konkurrent med gode fissionsregler melder sig på banen (hvis vi altså tænker på en virksomhed, hvor startaktionærerne stadig har magt og så overvejer, om det kan betale sig at indføre fissionsregler på et halvtidligt tidspunkt).. Ok. Lad mig bare lade det være det for nu. Og i det dokument, jeg har tænkt mig at skrive nu her i de kommende dage, regner jeg så bare med, at jeg nævner "virksomhedsfission" kun ultrakort, måske bare i en liste over ting, jeg kan uddybe på et senere tidspunkt. Ok. Nu vil jeg så lige opdatere mine "planer" nedenfor.. (11:58)
...(12:13) Nå ja, jeg vil også lige nævne, at der jo er stor forretnings- og investeringsmulighed (for start-aktionærerne), for den positive kunde-feedback, nemlig i form af at kunderne i højere grad vil fravælgekonkurrenter, jo mere de selv er investerede, gør at kd.v.'er vill udkonkurrere ikke-kd.v.'er i samme branche, hvorved der jo vil være et stort vækst- og fortjeneste-potentiale. ..Og denne indsigt, hvis folk kan forstå den, gør også, at idéen vil sælge lidt sig selv, når først bare nogen vil have forstået den (tror jeg, 7, 9, 13). (12:17)

(25.10.22, 16:17) Okay, jeg har nogle nyheder. Nej jeg tror ikke længere, at idéen vil sælge sig selv helt så meget, som jeg ellers sluttede den sidste paragraf af med at sige. Min forretningsbevægelse vil nok i høj grad skulles gennemføres på baggrund af en stor politisk vilje i folk til at opnå de fremtidsudsigter, den handler om at opnå. ..Hm, jeg kan forresten også lige nævne, at jeg nu mener, at det nok kunne være en god idé at gøre, så at kunder i starten er frie til at handle med hvem som helst, og at det så bare er efter et vist tidspunkt, at nye kundeaktier kun må sælges til andre kunder. For det kræver jo, at mængden af kunder (for heri tæller vi jo ikke start-aktionærerne) er stor nok, før at det kan fungere, at de kun må sælge til andre kunder. Jeg mener så stadig, at man kunne gøre det sådan, at ingen kunde må få mere end dobbelt ved tidspunktet af sælget, end hvad denne ville have haft, hvis denne aldrig havde solgt eller købt kundeaktier. Og det skal så i øvrigt siges, at disse restriktioner måske er ret skrappe ift., hvad der måske er nødvendigt, men ja, om ikke andet så tror jeg altså, at de er gode nok, hvis ikke man kan finde på et mildere system, der også stadig klarer ærterne. Nå, det var lidt et sidespring: Det var egentligt ikke med i de 'nyheder,' jeg tænkte på.. ..Ja, for at fortsætte de egentlige nyheder, jeg tænkte på, så tror jeg altså, at forretningsidéen nu skal sælges meget mere på baggrund af den 'gode bevægelse' ligesom, mere end at 'de første kunder også bliver belønnede'.. Og nu tænker jeg så at skrive mine "bright future"-noter om, så at afsnittet om denne idé så mere bare kommer til at sige: Jamen hvis nu det går endnu mere ned ad bakke, jamen så må man jo på et tidspunkt nå et punkt, hvor der bliver grobund for sådan en bevægelse, hvis altså den ikke bare finder god nok grobund med det samme. Så afsnittet bliver så ikke så meget: "Nu skal I se denne sikre plan, som vi kan gå i gang med med det samme," men mere: "Okay, selvom kapitalismen for nogen kan se lidt sort ud pt., så kan det altså ikke gå helt galt; det skal nok gå den rigtige vej overordnet set." Og jeg kan se på, om jeg så vil prøve at vinkle afsnittet mere som et "fix af" kapitalismen eller som et "forsvar for" kapitalismen, det kan godt være, at jeg så vælger det sidste i stedet.. ..Nå, men på en god eftermiddagsgåtur her kom jeg så også på en masse nye ting. Jeg skal faktisk udbygge mit e-demokrati-afsnit en del: Det er ikke nok bare at lægge op til det majoritetsenevælde, som den gør; der kan være meget mere komplicerede og spændende forhold, som gør, at folk gerne vil kunne oprette grupper, hvor de så kan handle med de andre grupper med deres stemmer til diverse ting ("hvis vi stemmer for det og det, så stemmer I for det og det"), og også i øvrigt handle omkring, om gruppen overhovedet vil bakke op om den samlede enhed (hvilket f.eks. kunne være et parti eller et firma), hvis ikke de får sådan og sådan. Så det skal jeg altså også lige skrive om, inkl. at skrive om, at det digitale system skal indrettes, så brugere altså kan oprette disse grupper og sådan. Og noget helt andet er så, at.. Ja, eller der er faktisk tre ting mere, og måske skulle jeg starte med denne i stedet: Jeg har tænkt på, at.. (16:42) ..Hm nå, der gik jeg lige lidt død, så lad mig i stedet starte med: At jeg fik tænkt over, hvad der egentligt lidt er en gammel version af en anden idé (nemlig min "donationskæde-idé"), nemlig at man også kunne igangsætte en bevægelse, hvor folk simpelthen lover dusører for, hvis virksomheder eller organisationer m.m. opnår et eller andet specifikt i fremtiden. ..Nå, nu gik jeg også lidt død i det igen.. Hm, og den tredje ting var så omkring.. Hm, den første/anden ting var bare noget omkring at give de nuværende kunder mere magt, hvilket jeg faktisk tror kan være ret vigtigt især for en Web 2.0--3.0-virksomhed. Hm, men mere er der vel ikke nødvendigvis at sige/nævne om den ting her, så det var én ud af tre.. Og den tredje ting var så.. ..Nå jo, det var at jeg også nu har tænkt mig at hive "forbrugerforeninger" m.m. (også samt hvad jeg lidt har kaldt "civilforeninger" på et tidspunkt) mere i forfronten nu. Jeg kan så skrive om dette, efter jeg har skrevet om e-demokrati og det. Og så kan jeg altså kort gøre rede for, hvad man kan opnå med sådanne "forbruger"-/"civil"-foreninger, eller hvad vi skal kalde dem, og så også at man jo kan gøre brug af et e-demokrati her. I øvrigt kan jeg lige gentage/præcisere, at min idé om "civilforeninger" i høj grad bare handlede om, at man går sammen i grupper til at representere sig som borger og/eller forbruger i et samfund (gerne altså sammen med nogen i en lignende båd), og hvor man så begynder at samarbejde og opføre sig meget som en slags forrestning, både idet man så begynder at lave handler samlet og betale nogen for at stå for at indgå (handels- etc.)aftaler med andre grupper/instanser, og også idet man så begynder at betale folk der kommer med nye smarte idéer til, hvad man kan gøre som gruppe. Hm, det lyder godt nok løst, når jeg skriver det her (og det er lidt blandet sammen med "forbrugerforeninger"), men på den anden side er jeg også ret træt nu, kan jeg mærke, og ja, det er lang tid siden, jeg har tænkt så meget over det, så det skal nok give god mening, når lige jeg får støvet det af.. ..Men ja, så nummer tre ting er altså bare, at jeg også vil skrive om disse forbrugerforeninger, og altså sikkert også "m.m.".. Hm, og lad mig så vende tilbage og skrive om donations-/dusør-idéen på at senere tidspunkt, når jeg er mere frisk i hovedet igen.. (17:06, 25.10.22)
%(26.10.22, 10:58) Okay, jeg har tænkt lidt mere over min nye version af denne dusør-idé, og jo, det er lidt kød på den, men ikke nok til, at jeg vil skrive om det, og måske ingen gang nok til, at jeg vil bruge tid nu på at forklare den. ..Nej, lad mig bare forklare den på et senere tidspunkt ved lejlighed, for idéen er altså ikke så vigtig (den handler bare om, at investorer, der øjner nogle gode fremtidsmuligheder i en idé, men ikke synes investeringsmulighederne/afkastudsigterne er helt gode nok, de kan så bede folk om at søtte idéen ved at udlove dusører, betinget af at idéen går godt og at disse folk vil drage nytte af den; så kan de så love at give lidt retur for dette. (Så ja, ikke den vildt store idé, når man tænker over det..)).. Hm, nu fik jeg faktisk næsten forklaret den her i den parentes.. Og ellers tilføjer idéen bare lidt om, hvordan disse dusørløfter kunne gøres.. men det gider jeg ikke skrive om nu.. Ok. Jeg har så også tænkt mere over nogle af de andre ting, jeg vil skrive om, og nu tror jeg planen er, at skrive en lidt mere simpel version af min business movement-idé, at skrive e-demokrati-sektionen færdig (med de nye tilføjelser), og så også bare lige inkludere et afsnit om forbruger-/civilforeninger, inden jeg når til Web 2.0--3.0-sektionerne (og så videre derfra). Og jeg kan så forklare, at denne idé altså i bund og grund handler om, at gå sammen i store grupper og ansætte agenter til at finde gode tilbud til gruppen og til at finde frem til mulige gavnlige aftaler for gruppen i det hele taget.. (11:08) Ok.. Mere er der vist ikke at sige her. Nu tror jeg så derfor, jeg vil fortsætte skriveriet, hvor jeg så nok lige begynder på en version 2 af "bright future"-dokumentet i øvrigt. (11:09)
(12:34) Okay, nu har jeg godt nok lige tænkt lidt mere, og.. Ja, det korte af det lange er bare, at jeg faktisk virkeligt tror, det kunne blive en stor bevægelse. Nærmere bestemt så skal jeg vist bare lige fokusere på, at det især er detail- (retail på engelsk) forretninger, man nok bør starte med virkeligt at fokusere bevægelsen på. Alle kd.v.'er kan så have et bestemt mærke, som folk kan gå efter. Fordelen er her, at denne branche indeholder mange små virksomheder, og generelt kræver det ikke så meget kapital at starte en butik m.m., og hvis vi tænker butiks\emph{kæder}, så er der også alligevel så mange, så man kunne godt forestille sig at mindst én vil konvertere. Nå ja, og webshops / web stores (det første er muligvis et begreb vi mest bruger Danmark, men det ved jeg ikke helt) er selvfølgig også en rigtigt vigtig mulighed at satse på også. Så herved kan bevægelsen altså starte og begynde at få mere og mere opmærksomhed og kapital til rådighed. Og når man så har fået samlet kapital nok, så kan man så også begynde at brede sig ud til andre brancher, hvis altså ikke der ellers er nogen virksomheder, der har konverteret endnu her. :) Okay, så min idé kan altså muligvis stadig rykke en hel del, selv her i nutiden; det er nok alligevel ikke bare en idé, der ligesom kan være et sikkerhedsnet i fremtiden, den er mere end det.. :) (12:44) 




## Energi, ressourcer, klima

(18.08.22, 13:30) Ja, vi bør helt klart fremelske en slags tang- og/eller vandplante, der kan fungere som en slags hvede (eller lignende), men på havoverfladen. Og hvis vi så kunne opdyrke f.eks. dele af stillehavet, så kunne man jo i teorien få en KÆMPE ny ressource, som kan bruges til alt muligt (energi, føde, og potentielt set også til at grave ned for at indkapsle CO_2, hvis man altså \emph{[virkeligt} får overskud..). Man kunne jo så evt. gøde planterne bare ved at suge næringsholdningt vand op fra dybet. Kunne have potentiale til at blive kæmpe stort, hvis det kan fungere.. 

(08.09.22, 9:57) Kom lige til at tænke på: Gad vide, hvad der ville ske, hvis man bare konstruerede en masse rev i havet, måske bare ved at lægge et netværk a flydende slanger/rør ud eller lignende. Tanken er lidt, at der måske så ville dannes en hel masse tang/alger og måske andet fiskeliv. Og en follow-up-tanke er jo så lige, om man eventuelt så skulle pumpe næringsholdigt vand op og igennem slangerne/rørene.. Jeg tror, jeg vil give dette emne nogle flere tanker i min fritid, og så vende tilbage hertil, hvis jeg skulle få yderligere idéer omkring det, der er værd at nævne. ..Men ja, den helt simple version er disse tanker er bare: Gad vide, om man kunne skabe en masse plantevækst, og vækst i betanden af diverse havdyr, hvis man bare lagde flydende rev ud. Jeg ved jo godt, at alt bliver vildt dyrt at udføre, hvis det skal skaleres meget op, før det får en effekt, men idéen er da nogle flere tanker værd.. (10:05)

(26.12.22, 11:06) Idéen med at køle planeten med "aske" eller lignende er selvfølgelig fundet på, og det er faktisk en rigtig populær idé endda. Den går under navnet "stratospheric aerosol injection," og den virker nemlig faktisk rigtigt lovende (rent teoretisk altså)..:)



## Andre ting, der relaterer sig lidt web- og forretnings-idéer m.m., men som er lidt uden for kategori

(18:28, 27.09.22) Jeg kom til at tænke lidt over, i går eller i forgårs, retsystemer i fremtiden. Jeg vil så bare lige nævne, at jeg jo allerede har skrevet om (i mine 21--22-noter), hvordan man kan få klare fælles etiske retningslinjer i fremtiden i diverse samfund. Og hertil kunne man jo så lige tilføje, at man så også kunne forestille sig et retssystem, som baserer jeg lidt mindre på lovskrifter og deres fortolkninger, men lidt mere på en.. ontologi/model/.. mængde.. af retningslinjer for, hvordan man skal dømme diverse forseelser og andre sager/konflikter osv. Og så kunne man jo naturligvis have et rangsystem af en slags dommere, men hvor hele befolkningen i det samlede samfund ligesom sidder i toppen (i praksis) og som fællesskab så har ret til.. måske hvor forskellige mennesker får ret til forskelligt data.. ret til at udtage stikprøver af under-dommerinstansernes bedømmelser, og hvor man derfor kan rette op på.. Ja og/eller man kan selvfølgelig også bare have et anke-system, som jeg også tænkte på, hvor parterne --- og måske også vedrørende til disse (eller måske bare folk, der har fulgt med i retsagen) --- jo så kan få lov at anke til en højere instans.. Så ja, men den primære pointe er altså, at man kunne forestille sig et alternativ til et lovsystem baseret på en masse paragraffer, hvor man måske i stedet bare havde en stor mængde (hierarkisk ordnede) retningslinjer og eksempler at gå ud fra.. (18:40) 




## Evolutionsspykologi

(18.08.22, 13:35) Jeg tror ikke, jeg har understreget dette i mine 2021-22-noter, men ét punkt, hvor jeg virkeligt tror man kan komme langt med evo.-spyk., er til at analysere og prøve at forstå, hvad der bringer os lykke som mennesker. Jeg tror virkeligt man kan skubbe meget til den analyse, hvis man tager evo.-psyk. godt i betragtning.


## Lykke

(18.08.22, 13:38) Angående lykke, så har jeg også lige nogle flere ting, jeg vil skrive om det emne, men det kan være, at jeg lige udsætter det en gang.. 

(31.08.22, 20:02) Okay, lad mig lige prøve at forklare de her tanker lidt. Jeg havde/har for det første lyst til lige at kommentere noget omkring, hvorfor man bl.a. har så mange glæder som barn (hvis man altså er heldig nok). Ja, der er vel mange mange grunde, men jeg har bare lige lyst til at fremhæve, at man (måske især som drengebarn) kan have en virkeligt stor lyst til eventyr --- i hvert fald til tanken om dem, men man kan alligevel godt på en måde få udlevet sin eventyr lyst (også selvom man ikke rent faktisk tager på et eventyr) via lege og via bøger, tegneserier og film m.m. Jeg kan personligt huske at tanken om et eventyr (og nu tænker jeg faktisk selv meget på One Piece som et eksempel på et "eventyr") bare var "helt oppe og ringe" dengang. Samtidigt havde man også en anden ting som barn, som virkeligt gjorde mange glæder mere tilgængelige: Man blev så nemt awestruck af ting. Jeg kan huske at en af de helt store øjeblikke i mit liv, var da vi fik vores første pokemon (blå) gameboy-spil. Vi var bare Helt oppe at køre, og det var bare sådan en lykke; det var sådan en fed følelse; så spændende. Nå, hvorfor har jeg så lyst til at nævne disse ting (for de er jo rimeligt velkendte)?. Jo, min pointe er så, at vi jo altså lidt kan tabe nogen af disse lykke-givende faktorer --- eller "parametre" kunne man kalde det --- i vores sind, når vi bliver ældre. Eller de dæmpes i hvert fald lidt. Men man kan dog have disse ting for øje, når man skal overveje, hvordan man konstruerer et lykkeligt liv sammen i et fælleskab. Særligt den der awe: man kan gøre mange til for at give ting mere mening.. Ah, jeg kunne også nævne det her med, at gamle ting, man er så nostalgisk omkring (hvis man altså har sådan nogle ting), der er ofte en god grund til, at man synes de var/er så store, og faktisk en ting som ikke nødvendigvis har rent med alder at gøre: Når mange mennesker går og er hypet omkring det samme, f.eks. når et nyt spil (eller en ny bog, eller hvad har vi) udkommer, jamen så ligger der bare så meget mere.. underbevist prestige omkring at klare sig godt i det, og selv for middelmådige spillere vil der stadig bare være.. en følelse af at ting "vejer" meget mere (end hvis man går i gang med samme spil mange år efter, eller nu hvor der er sådan et kæmpe udvalg så ingen spiller det samme (medmindre det er et rigtigt populært og nyt spil)). Det er f.eks. også bl.a. derfor Pokemon GO var så stort, fordi så mange interesserede sig for det, og fordi man derfor blev grebet meget af, at avancere i spillet. Og igen, hvorfor er det her så interessant og nævne i forbindelse med emnet om "lykkelige fælleskaber?" jo, fordi man jo så kan prøve at begrænse adgangen til hobbyer og/eller gøre tiltag for at skabe nogle store "diller" (som det hedder; det er bare ikke vildt tit man bruger det ord mere) løbende, som folk i høj grad kan blive grebet af. Og ja, jeg synes det er interessant, for det er jo en helt anden dimension end bare at sørge for, at man har nogle gode muligheder og nogle gode traditioner (og kreative mennesker til at finde på events): Der er også hele den dimension omkring, at folk også tit skal \emph{gribes} af en lyst til at deltage i en ny dille(/sport / kunstnerrisk/udfoldningsmæssig/literær strømning osv.). Så man skal altså ikke nødvendigvis se på bare at lave gode events som folk kan deltage i; man må også gerne overveje, hvordan man får folk grebet af ting i fælleskab. 
Nå, så det var så ligesom tankerne omkring awe og generel begejstring (som også relaterer sig til, hvad man går og har nostalgifølelse omkring). ..Nå ja, og jeg kan forresten også lige hurtigt nævne, at disse betragtninger altsammen er noget, der kan forklares med evolutionspsykologi (hvis man lige udvikler den gren, så den handler meget mere om at se på, hvordan evolutionsprincippet spiller aktivt og dynamisk ind i vores nutid *(og i vores helt nære fortid osv.), og hvordan vi i høj grad stadig fungerer som skabninger af evolutionen, hvad vi er, *(således at vores følelser og handlinger stadig i høj (men dog ikke fuldstændig) grad kan.. "forklares," eller man kan i hvert fald gøre sig meget mere vis på emnet, ved at se det i lyset af, at vi er formet af evolutionen) i stedet for (*himler og tager hånden op til panden* (for effekt)) at fokusere på, hvordan vi er "fortidsmennesker" med basale instinkter, der ikke længere passer til den morderne verden (*himler*)). Nå, det var et lille sidespring..
Og lad mig så lige prøve at vende tilbage til det med eventyrlyst (hvis der altså er noget her jeg mangler at sige..?).. ..Nej, her er der faktisk ikke så meget at sige, andet end at det er lidt ærgerligt, at vi mister nogle af disse barnlige trænge/lyster.. hvad jeg en gang ofte ville kalde "behov" (og måske også "værdier" nogen gange, det kan jeg ikke lige huske (og gider ikke lige prøve)) (hvilket handlede om, at vi jo fra naturens side har behov, og mange af disse behov er vi så så heldige, at naturen har udviklet en "gulerod" til, således at vi føler lykke, når det lykkes os at opfylde behovet.). Det kan være at vi i fremtiden kan opfinde en terapi eller andet, så man kan forstærke disse "behov," i.e. disse lyster, men indtil da må vi jo bare nyde det imens vi er børn, og så ellers prøve i nogen grad ikke at slippe de "behov"/lyster, når vi bliver ældre. Så ja, det var vist rimeligt meget de tanker (plus lidt sidespring), jeg havde lyst til at nævne/notere. :) (20:50)

(05.09.22, 19:55) Mon ikke jeg har været lidt inde på dette, men lad mig lige nævne, at et rigtigt godt råd, og en rigtig god ting at bestræbe sig på, er: Vær gavmild med komplimenter! Giv dem ofte! Igen: Vi har jo i bund og grund mest bare den glæde, vi får fra andre. Og det giver bare SÅ meget mere lykke, hvis man hele tiden sørger for at sætte udtrykkeligt pris på sine nærmeste --- og komplimenter til alle de ikke-nærmeste er også en god idé at bestræbe sig på at være gavmild med: det bringer alt sammen lykke. Selvfølgelig er det mere og mere vigtigt, jo nærmere folk kommer på en, at give komplimenter (og ros og andre tegn på værdsættelse), men ja, så længe rosen/komplimenterne kan gives oprigtigt, så er der ingen grund til at holde igen med dem. Bare en lille ting, jeg lige ville nævne (måske igen), og som virkeligt kan være værd at leve efter --- det må jeg også selv gøre meget for at huske på. 




## Eksistens

(06.09.22, 10:31) Jeg har i øvrigt også tænkt nogle små tanker omkring, hvis man antager at der er en overordnet skaber-gud. Hvis man bare antager, at han ikke er \emph{uendeligt} potents, men måske bare potent langt ud over, hvad vi kan forestille os, og hvis man også antager at han faktisk er god --- ikke bare sådan god som i: "Åh, hvor er du god, gud! ..Vær nådig ikke at sende mig i helvede og brænde..!" eller som i: "Definition af god er hvad gud er, for gud er den største og bedste,"  men som i at han rent faktisk ønsker så mange sjæle som muligt at opleve så meget lykke (og så lidt ulykke, selvfølgelig, der trækker fra af den samlede lykke) som muligt --- jamen så ville det jo egentligt give god mening, at han ville vælge at bruge sine skaberkræfter på at skabe en afsindig stor mængde af universer, som er nemme at opstille lovene for, og som ikke kræver nogen kræfter at styre, således at han ikke hele tiden skal gå tilbage og passe sine gamle kreationer men hele tiden bare kan fokusere sine kræfter på at skabe flere. Jeg synes dette er ret oplagt at forestille sig, at det ville kræve mere energi, hvis man hele tiden skulle overvåge og indgibe i alle de universer, man har lavet --- især hvis man sætter sig selv den umilge opgave for at sørge for at "intet ondt sker imod gode mennesker"---ja, for så skal han jo endda gå ind og forudsige, hvad der sker, og så skal han jo basalt set "køre simulationen flere gange alligvel, indtil han får det resultat, han ønsker, og det må jo tage mange mange kræfter og meget fokus, relativt til bare at fokusere på at skabe det næste uhyrligt store batch af universer, som skal sættes i gang. ..Hm, der er egentligt også andre antagelser, man kunne tænke over, selvfølgelig er der det, men lad os bare begrænse os til dette her.. Og ja, det skal så understreges, at denne analyse ikke handler om, at konkludere på, hvad der må gælde for sådan en gud. I stedet handler det bare om at forklare, hvorfor det ikke er langt ude i hampen, hvis man gør disse antagelser, at nå til en teori/hypotese, hvor guds ikke-indgriben og tings tilsyneladende tilfældighed faktisk kan forklares ret godt, på trods af guds godhed (for en af antagelserne er jo faktisk, at han \emph{rent faktisk} er \emph{god}, altså i en forstand der passer meget bedre til, hvad vi almindeligvis vil betegne (på trods af at der kan være mindre variationer af, hvad folk ser som 'godhed') som 'godt,' når vi snakker om \emph{menneskers} handlinger). (10:52) ..(10:56) Hm, jeg kom lige i tanke om, at gud pr. den kristne (og jødiske --- og sikkert også den muslimske) tro jo skabte verden på seks/syv dage, så en antagelse om at "uendeligt potent" bare skal ses lidt metaforisk må jo egentligt være ret oplagt.. 

(05.10.22, 15:10) Jeg havde tænkt mig at forberede en lille teaser udgivelse, som jeg vill lægge ud på GitHub her som noget af det første, men nu har jeg lidt fortrudt. Her er mine tanker (noter) nu her fra et andet dokument, jeg skrev i:
\# Existence theory

%Let me begin this introduction/teaser on a small personal note.
%
%When I was younger, in my teens, I was quite interested in 

"How and why was the universe created?" "What constitutes consciousness?" and "how does matter, in particular brains, gain consciousness?" 
These are questions that many people have asked themselves, probably often with the same open-ended conclusion: These questions are perhaps just to big for us "mortals" to answer. 

Indeed this seems to be the case: Even if we found a good answer, how would we ever know whether it is actually correct or not? And furthermore, we might not even be able to understand the correct answer if a god/oracle could tell it to us; it might be too complicated, and it even might include some otherworldly logic that we can never comprehend.

So if we look at the %...(10:44, 05.10.22) Jeg søgte lige lidt på filosofi (har bare læst wiki-artikler), og jeg har lige set, at hypotesen/antagelsen om at "alle mulige verdener eksisterer" også hedder "modal realism." Spændende. Jeg har vist hidtil kun læst om "mathematical universe theory." Der står på wiki-siden, at nogle modstandere mener, at hypotesen er i konflikt med Occam's razor, hvilket jo er rigtigt interessant, for det er den nemlig ikke; det kræver bare lige lidt omtanke og analyse for at komme frem til det resultat. (Og altså også en antagelse om at verdener/universer har en naturlig, fundamental ordning i multiverset, nemlig ud fra, hvilken information de indeholder/bygger på.) ..Lad mig lige læse videre om det, og også omkring de andre emner, der relaterer sig til spørgsmålene ovenfor.. (10:51) ...(11:13) Hm, det virker alligevel til at associationerne omkring "modal realism," inklusiv hovedproponentens egne holdninger, alligevel er for forskellige fra, hvad jeg tænker på. Og nu læser jeg lidt om MUH, og det virker helt klart til, at det passer mine tanker. Jeg skal lige finde ud af, og der er forskel på CUH og så det, der også er nævnt i wiki-artiklen, nemlig MUH eksklusivt med kontruerbare universer, det må jeg lige finde ud af. Men ja, ovedparten af mine tanker lægger sig altså rigtig meget op ad MUH/CUH, og så er det altså muligvis bare mine tanker omkring bevisthed (som muligvis lægger sig op ad "idealism" og/eller "Platonism," *(nej Platon var vist "realist," ser det ud til, som så er det modsatte..) men det skal jeg lige have læst op på igen), og så måske også bare min tilgang med ikke at lede efter \emph{den} rigtige eksistensteori, men i stedet bare forgrene analysen, hver gang man støder på et spørgsmål, der med fornuft både kan antages, i nogen grad, at være sandt eller at være falsk. (11:21) ..Wow! "Virtually all  historically successful theories of physics violate the CUH"!! Helt ærligt. Så svært kan det altså heller ikke være at forstå Gödels ufuldstændighedsprincip..! Det ser ud til, at den originale (hvilket jeg på en måde også kan siges at være, mener jeg, men der var altså andre, der kom først..) opfinder/opdager af teorien tror (som i øvrigt ser ud til selv at foreslå CUH som modsvar på en vis kritik (om så end det ham, der fandt på det først, det fangede jeg ikke lige)), at f.eks. mængdelære og andre matematiske teorier, hvor ufuldstændighedsprincippet gælder, at det ikke har fuldstændige modeller.. Suk suk. Jeg ville ønske at Gödels fuldstandighedsprincip ikke var kommet så meget i skyggen af det andet princip; der virker til at være meget forvirring omkring det.. ..Hm, folk burde bare blive undervist mere i Gödels kontruerbare univers, og i hvad det betyder: at al matematik kan deles op i to mængder: matematik over objekter kontrueret af en endelig mængde information, og matematik over (filosofisk questionable) objekter dannet af uendeligt meget information.. (11:34)
%...(12:11) Hm, jeg tror hellere lige, jeg må summe lidt over, om det overhovedet kan betale sig for mig at tease mine idéer på dette område nu; MUH er jo ret gammel --- den går faktisk mindst helt tilbage til 1998, kan jeg se (jeg troede den var lidt nyere, selvom den jo stadig er ret ny overordnet set).. Og hvis man tager MUH, eller rettere CUH, som afsæt, så vil det måske blive svært for mig, at få mine idéer teaset, så de lyder interessante (altså hvis man kender til CUH i forvejen).. Ja, lad mig summe lidt over det.. (12:15)
%... (14:56) Ja, jeg er bange for, at der ikke bliver nok kød på det til ligesom at tease det.. Det er for inviklet at forklare, hvad jeg tror, jeg kan bidrage med til emnet. ..Det kan nok ikke rigtigt gøres kortfattet særligt godt. Og ift. at jeg jo havde tænkt mig primært bare at fortælle den lille hurtige redegørelse for, hvorfor man med meget normale antagelser (udbredt blandt ateister og lignende især) hurtigt kommer frem til, at vi så i bund og grund lever uendeligt og i alle afskygninger, nemlig i og med at der så også vil findes alle (og man kan i princippet blive ved med at zoome ind) mellemtrin imellem to forskellige personligheder og tilhørende liv ("oplevelse," i.e.), så vi dermed i praksis alle er den samme, bare i forskellige udgaver. Og jo, mange af mellemtrinene er vildt usandsynlige, men selv "vildt usandsynlig" er forekommer stadig groteskt "ofte" sat op i mod "uendelighed." Og budskabet er jo så, at vi alle er den samme i praksis, og at alt vi gør mod andre mennesker, det bliver så gjort mod os selv i et fremtidigt liv, i praksis, altså.. Men ja, selvom dette resultat ikke behøver så meget teori i forvejen, så føler jeg stadig, at det er altså bart i sig selv til, at det giver mening at tease/forklare det. Hvis det kunne være en del af en teaser til "eksistensteori" generelt, så ville det give god mening, men jeg tror ikke, det vil blive modtaget med meget begejstring, hvis det bare står helt alene.. ..Også fordi, hvis man skal være lidt streng ved sig selv, så kan det jo i bund og grund reduceres bare til at sige: "hey, har I tænkt over, at multiversets uendelighed vil medføre, at alle afskygninger af "liv"/"oplevelser" vil førekomme?" Og det vil sgu nok ikke skabe særligt mange bølger i sig selv.. (15:07) ..Så ja, jeg venter med at udgive (og brygge videre på) mine eksistenstanker (som jeg dog stadig tror virkeligt kan noget, \emph{selvom} meget af det jo dog er tæt på noget kendt)..
slut. 
Så ja, som sagt, jeg føler altså, at jeg virkeligt har noget at byde på, men jeg tror ikke jeg kan finde på noget kortfattet, der kan skabe meget interesse i sig selv.. (15:13)
... (17:13) Åh, jeg kan også lige nævne, at min intension var efter "Indeed this seems to be the case ..." paragrafen (i readme-filen) så at lægge op til: Men hvad med at droppe målet om at finde \emph{det} korrekte svar, men i stedet bare prøve at overveje/analysere (gerne i fællesskab, btw), det samlede træ, ligesom, over de mulige svar der kan være til de grundlæggende spørgsmål. (Og her jeg jeg i øvrigt lige nævne, at der dog ikke bare vil være ét træ, for man kan godt stille spørgsmålene i forskellige rækkefølger, hvor analysen godt kan have karakter heraf. Særligt kan det vist være betydende hvilket spørgsmål (eller hvilke få spørgsmål), man starter med. Jeg mener dog stadig, at det ikke er sådan, at vi så skal analysere en hel skov af træer på en gang; jeg tror på, at det nok bare bliver en lille gruppe af træer, der vil være interessante for de fleste..) (17:19) 



(05.01.23, 11:33) Jeg har nogle tilføjelser til dette emne, og så har jeg også nogle idéer til, hvordan jeg nok vil strukturere en artikel om det. Lad mig se.. I virkeligheden har jeg nok skrevet meget af det før. ..Hm, jeg tror lidt, at jeg har en ny måde at tænke på det mulige fænomen med at Oplevelser bliver vagt til live, hvor jeg altså nu tænker meget, at man nærmest kan sige, at det er [...] At man nærmest kan sige, at det er "universet" --- og her snakker vi altså om det idealistiske univers: et univers der beskriver Oplevelser (hvilket også bare kan være hele multiverset selv) --- der oplever Oplevelserne. Og ja, mine yndlingsteorier har multiverset som selve dét (eneste) idealistiske univers, så jeg fortolker det altså nu meget som at "multiverset oplever Oplevelserne." (Og da en af mine klart yndlingsteorier nu er den hvor multiverset "udregner" al logik, og at Eksistens dermed ligesom er den fundamentale logik om alt, der så at sige udleder sig selv (eller rettere alle "sætninger" i logikken), så ser jeg det altså meget sådan at "multiverset udleder alle Oplevelser, og dermed også udlever/oplever dem"). [...] Nå, men dette var jo en lidt mindre ting. 

En større ting er så, at jeg er gået lid væk fra at forestille mig den fundamentale logik som et sprog; altså som noget med en syntaks eller tilsvarende. Nu tænker jeg altså mere, at den fundamentale Logik ligesom er "rent semantisk." ..Vi kunne snakke om "Pure Reasoning".. "Pure ..." Hm.. ..Ja, "pure and fundamental logical reasoning." Og denne opfattelse betyder faktisk rigtigt meget, for det gør det nemlig pludselig meget nemmere at forestille sig, at der bare er én "fundamental logik for alt." ..Så ja, det er altså derfor, at jeg nu hælder rigtigt meget til, at multiverset ligesom bare er en fundamental og "ren" "logik," der forstår mere og mere "af sig selv," så at sige, og dermed også forstår, hvordan diverse forskellige sammenhængende Oplevelser må føles, og idet "den" forstår dette, så vil den også opleve disse Oplevelser, enten netop idet den forstår det, eller for alt tid igen og igen efter den ("den") har forstået det. (Så altså med andre ord: Enten sker udlevnigen af Oplevelserne på kanten af den forståelses-kulge/-mængde, der udvider sig mere og mere, eller også sker udlevningen konstant indenfor kuglen/mængden (hvor der så bare kommer flere og flere Oplevelser til denne mængde).) 

...Nå, og nu kunne jeg så fortsætte med at sammenligne "den fundamentale logik" i denne teori med, hvad man næsten kunne kalde en gud (og den sammenligning er hurtig at lave), men nu vil jeg i stedet prøve at følge den struktur, jeg har i tankerne for en artikel om det. Jeg forestiller mig nemlig at starte med at liste nogle gode kandidater til Eksistens-teorier, hvoraf den ene så skal være den, jeg lige har beskrevet (som egentligt er to teorier, alt efter om Oplevelserne udleves på kanten eller inden i kuglen/mængden af Oplevelser).

Hm, så lad mig prøve at skrive, hvad den første sektion i den artikel kunne indeholde.. (12:56)

Nå ja, jeg skal jo starte med at redegøre for hypotesen om, at "alt hvad der kan eksistere, eksisterer." Med andre ord er hypotesen, at der er en komplet symmetri ift. hvad der kan eksistere, og hvad der rent faktisk eksisterer af denne mængde; hvis ét univers eller ét delmultivers indeholder nogle specifikke "valg," jamen så må der bare eksisterer modsvarende universer/delmultiverser i lige mængde. Men denne tanke leder så til at spørge: Hvordan defineres den underliggende teori for det samlede multivers så, for for at man kan afgøre, at multiverset er symmetrisk eller ej, så må man jo have et udgangspunkt for at definere, hvad der er symmetrisk og ikke symmetrik --- hvad vil det sige, at et univers er "modsvarende" til et andet univers for eksempel? Ja, og svaret på det er... Ej, det var bare for sjov; det kan vi selvfølgelig ikke svare på. Men vi kan hypotisere, at der kunne finde en fundamental "teori" for multiverset, selvom "teori" dog i så fald vil være et dårligt ord at bruge for det, fordi det indebærer, at der findes andre teorier. Så lad os hellere kalde det "en fundamental logik for alt," og her skal "logik" altså ikke forstås som en formel logik, men i en meget mere løs forstand, nemlig som det fundamentale koncept om, at visse ting kan være sande og visse ting kan være falske, og ting kan følge logisk af andre ting. Så lad os hypotisere, at der eksistere en fundamental logik under den samlede eksistens, for hvad er alternativet? At der ikke er en samlet eksistens? At der ikke er nogen "logik" (i ordets meget løse forstand) bag? Nej, det går ikke rigtigt, så det virker som et fornuftigt aksiom. Og lad os forresten også bare benævne den samlede eksistens for 'multiverset,' da det er lettere at sige. (Og så må man bare endeligt ikke antage, at 'multiverset' består af en mængde af universer i den forstand som 'universer' ofte betegner, nemlig en samling love, noget rum og noget tid. Lad os endeligt ikke antage, at det er den eneste form for selvstændige eksistenser, der findes.) ..Hm, faktisk tror jeg, jeg vil bruge et nyt begreb om.. Hm, eller..?.. ..Nå, det vender jeg tilbage til. Men, hvad dælen beskriver denne fundamentale logik så? Ja, det er så her det store spørgsmål virkeligt ligger. Hvad beskriver den fundamentale logik? Den kunne f.eks. beskrive objekter, så som strygejern, computere, jordkloder og hele universer, og så ville vores princip om, at "alt hvad der kan eksistere, må eksistere (i symmetrisk forhold)," føre til at alle "ting" eksisterer. Så det vil særligt sige, at alle mulige universer må eksistere. Jamen det lyder da meget godt, især hvis man er materialist i forhold til spørgsmålet om bevidsthed. Men selv da kunne man så også spørge, eksistere strygejern virkeligt side om side og på lige fod med hele universer? Er multiverset ikke bare en samling af universer? I så fald må man jo hypotisere, at den samlede fundametale logik om alt har en særlig "klausul" om, at det der kan eksisterer, er "universer," hvordan man så lige skal definere det begreb helt præcist. Nå, men det er detaljer: Overordnet set har vi altså bare en mulighed for, at genstandene for eksistens i multiverset --- med andre ord de ting, der kan eksistere --- er, ja, "ting." "Genstande." Fysiske objekter med andre ord, og muligvis altså yderligere begrænset til kun at indebære, hvad vi kan tænke på som 'universer' i en ret gængs forstand af ordet (altså samlinger af love, materie, rum og tid). Der er dog også en anden vigtig mulighed, især hvis man mere er såkaldt idealist frem for materialist, og der er, at genstandene for eksistens i multiverset er: Bevidste (sammenhængende) oplevelser. I denne hypotese er universerne i multiverset altså ikke en samling af rum, tid, materie og tilhørende love for, hvordan dette forløber, men af bevidste oplevelser (jeg vil skrive Oplevelser med stort fra nu af), der så også har nogle love for, hvordan de forløber. Da sanseinput er en stor del af Oplevelser, så vil sådanne Oplevelser jo også skulle indeholde beskrivelser/"love" for, hvad der sanses i Oplevelsen, og disse "love" kan jo så indebære de fysiske love i vores universer. Så hvis vi tænker på vores eget univers, så er der tydeligvis nogle love for, hvordan objekter bevæger sig og udvikler sig i tid. Med den.. objektorienterede hypotese om genstandene for eksistens, så vil disse love være "indskrevet" i multiverset direkte om objekterne, hvorimod i den bevidstheds-/Oplevelse-orienterede hypotese, der findes de samme love også for et univers, men de hører så i stedet bare ind under, hvor jeg-personen/erne oplever. To sider af samme sag. Ingen af os kan empirisk afgøre, om vores univers har love, der tager udgangspunkt i objekter eller om det tager udgangspunkt i de bevidste oplevelser i det. Hardcore materialister vil nok hælde mest til, at universer er orienteret omkring love, da disse per definition ikke ser noget problem i, at bevidste oplevelser bare opstår af sig selv, men alle os andre, der synes, at der ligger noget mærkeligt i tanken om, at bevidste oplevelser bare kan opstå af genstandes bevægelser (og denne forundring bliver kun forstærket, når man dykker grundigt ned i kvantemekanikkens verden, skulle jeg hilse og sige) *(Det skal så dog siges, at jeg hele mit liv selv har hældt mest til materialisme, selvom jeg kunne se nogle store spørgsmål ved det, som er svært at svare på, og at jeg først opdagede det elegante ved idealismen (som jeg slet ikke vidste, det hed på det tidspunkt) der i sommeren 2019, hvor jeg pludselig fik en række åbenbaringer om dette emne, bl.a. også omkring hvad der så svarer til den eksisterende teori om CUH.), jamen vi vil naturligvis være så meget mere desto åbne over for et oplevelse-/bevidsthedsorienteret multivers, fordi dette løser hele den problematik automatisk: I et oplevelseorienteret multivers skal oplevelserne ikke opstå fra noget andet, men i stedet er de der fra starten af, og man kan så nærmere sige, at objekter "opstår" ud fra dem (fordi objekterne altså så kun eksisterer i det omfang, at de bliver oplevet af en bevidsthed). (13:42)

Man kan så selvfølgelig ogå hypotisere, at multiverset har begge ting som genstand for eksistens, fysiske objekter og bevidste oplevelser, og så vil det så bare være spørgsmålet, om man er materialist eller ej, der afgør om førstnævnte så også fører bevidste oplevelser med sig indirekte eller ej.

Okay, så det var en ret vigtig og grundlæggende opdeling i mulighederne ved, hvad den fundamentale logik om alt har som genstand for, hvad kan eksistere i det samlede multivers. Et andet vigtigt spørgsmål omhandler så subjekterne for Oplevelserne. (13:46) ...(14:10) Hvem (eller hvad) er jeg-personerne i fortællingen med andre ord. En hardcore materialist tror som bekendt ikke på, at der er en sjæl som er genstand for de oplevelser, som objekterne producerer, og en sådan vil derfor nok sige, at det er simpelthen ikke er nogen.. hm, vi kunne sige, at der ikke er noget "modul," der indgår i oplevelsesskabelsen, som oplever Oplevelsen; en oplevelse oplever bare sig selv. Hm, jeg vil meget nødigt kalde disse moduler for "sjæle," for vi har desværre nogle associatioer til dette begreb, der er uhensigtsmæssige i visse sammenhænge (altså med visse hypoteseantagelser).. ..Hm, lad os kalde det en "oplevergenstand" her.. ..Nej, et "oplevelsessubjekt." Ok. Nå, og det er så slet ikke kun materialister, der kan have denne opfattelse. I hypotesen, hvor den fundamentale logik beskriver Oplevelser som genstande for eksistens er det jo også ret unødvendigt at have eksistensen af en helt trejde ting, nemlig et oplevelsessubjekt, for at Oplevelserne kan udleves. En måske mere naturlig opfattelse (det synes jeg i hvert fald) er nok, at det bare ligesom er multiverset selv, der udgør det samlede "opevelsessubjekt," og at alle eksisterende oplevelser derfor bare opleves af.. ja, af muliverset, eller af den "fundamentale logik for alt," kunne man også tolke det som. Men der findes altså også en mellemvej, hvor at multiverset indeholder mere end ét oplevelsessubjekt, som vi altså ofte kan tænke på som "sjæle" (men ikke i alle henseender). Og hvis multiverset indeholder en samling (meget vel en uendelig samling) OS'er.. Hm, lad mig bare kalde det Subjekter med stort S fra nu af.. Hvis multiverset indeholder sådan en samling Subjekter, så afhænger det så af, hvorvidt multiverset er oplevelses- eller objektorienteret (eller en blanding), om hvert Subjekt så tilknytter sig en Oplevelse i multiverset, eller om de tilknytter sig en "hjerne" (lad mig skrive Hjerne fra nu af), som altså skal forstås i en meget bred forstand af ordet (maskiner kan f.eks. også være Hjerner, og det kan alt muligt andet også (medmindre man specifikt begrænser sin hypotese for multiverset herom)), i et specifikt fysisk univers af objekter. I denne todelte hypotese vil vores oplevelser altså hver især være et produkt af, at der "sidder" et specifik Subjekt et eller andet "sted" i multiverset --- enten i et abstrakt rum eller i et fysisk rum, muligvis lige oven i din Hjerne, som den oplever fra (i hvilket tilfælde "Subjekt" netop bliver helt ækvivalent med vores normale forståelse af begrebet "sjæl") --- og er så i færd med at opleve, de vi oplever ligenu, og nærmere bestemt er vi hver især det Subjekt og den er os. Vi skal senere diskutere noget mere om, hvad dette betyder for os. Men lad os bare her påpege, at det sjove ved denne hypotese, hvis vi kan sige det sådan, er at hvis man har to universer, der indeholder samme Hjerne med same tidsudvikling, eller hvis man i et oplevelsesorienteret multivers har to oplevelser, der i en vis periode er helt identiske med hinanden, så vil helt den samme personlighed, med de samme tanker og helt den samme selvforståelse, opleves af to forskellige entiteter.. Tja, det kan man jo sige alligevel.. Nå, men.. Ja, lad mig bare lige nævne her i stedet, at lige netop denne (todelte) hypotese kan føre til, at man kan bekymre sig om døden, for hvad skal der så ske med ens "sjæl" (ens Subjekt) bagefter? Dette problem har materialisterne og idealisterne der tror på at alle Oplevelser udleves af et stort samlet Subjekt (som man meget vel kunne tænke på som multiverset selv); for dem er to identiske (del-)oplevelser, der udleves i multiverset, også identiske i forhold til, hvad de betyder for den samlede mængde af oplevelser, nemlig fordi der ikke i disse hypoteser vil findes nogen skjult variabel, så at sige, der afgør om Oplevelsen i givet fald opleves af det ene eller det andet Subjekt i multiverset. For dem, eller rettere for os, for jeg er selv idealist med tro på ét samlet Subjekt) er alle oplevelser ligeværdige, for vi vil så mene, at vores egen nuværende oplevelse er en del af ét samlet hele, og at vi altså ligeså meget er en del af alle andre Oplevelser i multiverset, som den Oplevelse, vi selv føler at vi lever lige nu (hvad "nu" så end betyder helt præcist, men det kommer vi til).

Nå, og nu fik jeg så lige akkurat teaset den næste store opdeling, man kan have i hypotesen for multiverset, og det er nemlig i forhold til, om der findes en form for en global tid eller ej. (14:47) ...For materialister er det meget naturligt at antage, hvis ikke en global tid for det samlede multivers, så i det mindste lokal tid for hvert enkle univers --- ja, det er nærmest uundgåeligt. Og herfra er der så ikke megt i vejen for videre at antage, at der også er en global tid. For de idealistiske hypoteser er spørgsmålet derimod en smule mere indviklet. Her er der nemlig ikke et behov for "tid" andet end som noget, der er subjektivt for hver Oplevelse. En oplevelsesorienteret multivershypotese kan således godt bare antage, at "tid" er et rent subjektivt begreb, og at alle Oplvelser (hvad end de bliver oplevet af individuelle, adskildte Subjekter eller af et stort samlet Subjekt) bare er, og at de via deres væren (som altså så er konstant så at sige, i og med der ikke findes nogen egentlig tid (eller måske bare ikke en "tid" som svarer til, hvad vi normalt forstår ved begrebet)) bare resulterer i at de ligesom konstant udlever sig selv, så at sige, eller bliver udlevet af de Subjekter, der har knyttet sig til dem. Dette er faktisk ret dejligt, for konceptet om Tid kan også i sig selv godt virke lidt mærkeligt, lidt ligesom da vi snakkede om, at konceptet om, at bevidsthed skulle opstå af genstandes bevægelser, også kan virke mærkeligt. Så det er dejligt, at der findes Eksistens-hypoteser, hvor tid er et rent "subjektivt" fænomen, så at sige. Nå, men idealistiske hypoteser kan nu også godt indeholde koncepter om tid. For eksempel kunne man have en specifik idealistisk hypotese, der sagde at alle oplevelser udleves samtidigt i multiverset --- enten af et stort samlet Subjekt eller af adskilte, individuelle Subjekter hver især --- og at den globale Tid i multiverset så dermed bare måles i den subjektive tid som hver Oplevelse har. Med andre ord kunne man fortolke dette som, at multiverset indeholder en (uendelig) række af Oplevelser, som multiverset, hvis vi personificerer dette i denne metafor, så ligesom "trykker play på" i Tidens begyndelse, og så kører de ellers hver især samtidigt i henhold til deres subjektive tidsopfattelse. En anden mulighed kan være, at der til hver Oplevelse også er tilknyttet en vis "regnekraft" så at sige, og at man metaforisk set så kan sammenligne hver af de "afspilne" Oplevelser som en slags computer, der regner på, hvordan Oplevelsen forløber. En oplevelse, der foregår i et stort univers med meget materie i og med "regnetunge" fysiske love, vil så "afspilles" langsommere end en oplevelse, der foregår i et mindre "regnetungt" univers. (I øvrigt kunne man også have den hypotese, når det kommer til at objektorienteret univers: Her kunne man også stille alle universerne på række og så sige, at den globale tid ikke svarer til de lokale tider, men i stedet afhænger af, hvor "mange udregner skal klares," så at sige.) Disse tanker svarer altså til en antagelse om at den fundamentale logik ligesom skal bruge tid på at udregne sig selv, og så at sige opdage flere og flere sandheder om sig selv, hvilket, når vi siger det på den måde (og ikke snakker om det som om hvert univers/Oplevelse udregnes af en computer), så lyder det jo faktisk pludselig slet ikke helt så dumt. Og med den grundlæggende fortolkning, så hører dette faktisk også med til min egen yndlingshypotese, nemlig at den fundamentale logik om alt ligesom fra Tidens begyndelse opdager flere og flere sætninger om sig selv, og at det er i takt med, at den opdager (og nu tillader vi os altså lige at personificere den her) disse sætninger, så udlever den så også de Oplevelser, som sætningerne omhandler. *(Det skal dog siges, at jeg også synes rigtigt godt om flere andre hypoteser.) Nå, men det vender vi tilbage til. Ellers skulle man ikke tro, at denne forskel gør så meget, nemlig om den globale Tid, hvis der er en, afhænger af "udrengernes" kompleksitet eller ej, men faktisk så giver det meget muligt en forskel i den samlede 'prior'-sandsynlighed, som det hedder. Som et sovt lille eksempel på dette, så kan man faktisk teoretisere omkring, om det faktum, at vores univers er relativistisk, måske ligesom kunne skyldes, at det hermed så faktisk kan have uendelig størrelse, uden at det er uendeligt komplekst at "regne på"/"simulere," fordi man i et relativistisk univers kan tillade sig at regne på/simulere alt ved at starte i et enkelt punkt og så regne på alt med udgangspunkt i en lyskegle derfra. Hermed bliver et uendeligt tung simulering faktisk til en endelig tung simulering. Man kunne også nævne mange andre sjove ting i denne sammenhæng, men lad os bare stoppe her, for det er lidt et sidespor ift. det overordnede tema her. (15:37)

Nå, det næste man så kunne tage fat på, det er så sprøgsmålet, hvis vi specifikt snakker de oplevelsesorienterede multivershypoteser, og det er hvordan.. hm, hvordan de beskrives, men det bør næsten komme i et helt nyt afsnit, for nu bevæger vi os så videre til noget helt nyt, og det er at fundere over, ..ja, over "strukturen" af den fundamentale logik så at sige.. Hm, det er lidt en stor mundfuld, men jeg tror muligvis, der er en god, hurtig vej igennem det, så lad mig lige tænke mig om først... (15:42) ..(Okay, men hjerne skal også lige bruge en god pause, tror jeg...) (15:47) ...(16:02) Ah jo, jeg tror godt nogenlunde, jeg ved, hvad jeg vil sige.. ..Ja.. Men jeg synes næsten, emnet fortjener, at jeg skriver det færdigt i morgen, når jeg er mere frisk igen --- hvilket jeg i øvrigt godt tror, jeg kan; de næste "afsnit" behøver nok ikke at blive så lange..:) 

(06.01.23, 11:45) Okay, det var rigtigt godt, at jeg lige tog aftnen til at tænke mere over emnet, for nu kom jeg i tanke om nogle andre vigtige ting. I forbindelse med de objektorienterede multivershypoteser, så fik jeg kun snakket om genstande/objekter og universer, og fik så også snakket om Subjekter, altså hvad vi nærmest kan tænke på som en slags "sjæle," selvom der dog følger flere antagelser med, hvis vi kalder det 'sjæle,' som vi ikke ønsker at antage om Subjekter. Men ja, jeg fik jo så udeladt den mulighed, at det kun er Subjekter, der eksisterer, og at fysiske universer og objekter bare er noget som de ligesom "tænker frem," så at sige. Sådanne hypoteser indeholder jo også de hypoteser, der siger at multiverset består af en mængde guder, som hver især står for at skabe fysiske universer, samt udleve de tilhørende oplevelser i de universer. Så altså også en rigtig vigtig gruppe af hypoteser at få med. Og i sidste ende bør det også nævnes, at når vi kommer til at antage, at "alt hvad der kan eksistere i den fundamentale logik, gør det," så får vi jo faktisk et samlet multivers hvor en "logik" ligesom skaber ting spontant. Aha, men kunne man så ikke også i stedet forestille sig et multivers af flere end én "logik," hvor hver "logik" hver især så skaber universer/delmultiverser og skaber og udlever de tilhørende Oplevelser (..eller skaber Subjekter, som så udlever dem)? Jo, det kunne man selvfølgelig godt, men i så fald så falder disse hypoteser jo faktisk sammen med de hypoteser, der siger at Subjekter er de fundamentale genstande for eksistens.. Nå nej, ikke helt, vent lidt.. ..Hm, hvis vi ser på hypoteserne, hvor en fundamental logik skaber alt og også udelver alt selv, og hvor der altså ikke er individuelle adskildte Subjekter, men hvor alt opleves af multiverset/"logikken" selv.. Hvis vi tager de hypoteser og omdanner dem, så der nu er flere "logikker" i stedet, så svarer denne mængde af hypoteser ret meget til.. Nej, den indgår i mængden af hypoteser, hvor kun Subjekter er genstande for eksistens, nemlig hvis man tillader sig at bruge en bred definition af, hvad Subjekter kan være (og hvorfor ikke, for det er et super abstrakt begreb i forvejen), således at det også inkluderer "logikker." Hm, og hvad så med de hypoteser, hvor den fundamentale logik også skaber individuelle Subjekter, der er adskildt fra alt andet..? ..Tjo, men her kunne man udvide.. Tja, never mind, det er også lige meget; lad os bare inkludere den mulighed som en selvstændig ting, og lad os bare notere os, at det under visse antagelser også kan svare til en gruppe af hypoteser som hører til den mængde, hvor Subjekter er de fundamentale genstande for eksistens (altså de hypoteser, hvor "guder" (hvis man fortolker dem sådan) er de fundamentale genstande for eksistens, nemlig fordi man her kan omfortolke "logikkerne" til at være det samme som "guder;" at en "gud" er en "logik"). 

Okay, så det var rigtig godt lige at få de former for mulige hypoteser med. 

Nu kommer vi så til at tale om, hvad man så får ud af at antage at "alt hvad der kan eksistere, eksisterer" ovenpå de beskrevne hypoteser om, hvad kan eksistere. Og dette bliver så faktisk et relativt kort afsnit, for det korte af det lange er, at det ville kræve en forståelse af, hvordan den fundamentale logik om alt er.. "struktureret"/"ordnet," før man ville kunne sige noget præcist om vores univers-/Oplevelse-prior-sandsynligheder (og her må man altså lige læse lidt sandsynlighedsregning og statistik for at forstå, hvad menes med 'prior-sandsynligheder'). Og det kan vi jo aldrig komme til. Men! Vi kan teoretisere os frem til nogle ting, bl.a., og dette er rigtigt vigtigt, at man med nogle ordninger vil opnå det, der (desværre allerede er opfundet af en anden;)) kaldes 'Mathematical Universe Hypothesis' (MUH), eller hvis man skal være mere præcis (for selv ham, der postulerede idéen er vist gået over til at fokusere på følgende også): 'Computable Universe Hypothesis' (CUH). Begge teorier (altså teorierne omhandlende hypoteserne) handler så om, at man ved at antage, at alt hvad der kan beskrives i en (ordnet) matematisk teori eksisterer, faktisk nok for en høj frekvens af ikke-kaotiske universer som vores eget i multiverset. (Mere specifikt en høj frekvens af universer, som kan beskrives med relativt lidt information.) Og CUH præciserer så bare og siger: Vi er ligeglade med ikke-konstruerbare matematiske objekter (og hvorfor skulle nogen også kære sig om dem, andet som en filosofisk beskæftigelse? (jeg er matematisk konstruktivist, kan man høre)). 

Men for at nå CUH, så kræver det altså, at der er en vis ordning i den fundamentale logik, samt en ordning i.. ja, i hvilken rækkefølge at Oplevelserne bliver udlevet (men hvor man dog godt i princippet kan have, at et endeligt antal Oplevelser kan udleves på én gang). I mange hypoteser kan dette skabe nogle store problemer. Men det gode er så, at man altid kan sige, at, jamen, bare fordi vi med vores jordlige (er det et ord?..) matematik ikke har mulighed for at definere et fornuftigt sandsynlighedsrum, hvis ikke alle Oplevelser i multiverset er ordnet på en vis måde, så er det jo ikke ensbetydende med, at multiverset ikke selv kan.. ja.. se ud på en fornuftig måde. ..Bare fordi vi vil opnå logiske paradokser, hvis vi prøver at tildele sandsynligheder til noget, der er udvalgt fra en uendelig mænge, så betyder det ikke at multiverset behøver at indeholde paradokser, hvis det nu f.eks. indebærer, at uendeligt mange Oplevelser udleves "samtidigt" --- eller hvis de udleves i rækkefølge, forresten, med hvor prior-sandsynlighederne bare aldrig konvergerer.. Så ja, selv hvis man ikke lige kan finde, eller ikke lige synes om de hypoteser, hvor alle Oplevelser er ordnet pænt, så betyder det ikke at multiverset ikke godt kan følge de hypoteser, uden at det bryder sammen. Vi kan så selv pålægge nogle antagelser til de hypoteser, der får prior-sandsynlighederne til at konvergere alligevel, og her er det så bestemt værd at nævne, at man herved alt andet end lige sikkert også vil komme frem til CUH i sidste ende. 

Der er dog også et problem til den anden side, og det er, at nogle hypoteser fører til et komplet kaotisk univers. Disse problemer er dog helt anderledes, for der kan man bare sige, at fordi vores eget univers/vores egen Oplevelse ikke er komplet kaotisk, så må man forkaste de hypoteser, der siger, at det/den/de bør være det. Dette forklares nemmest, hvis vi ser på et eksempel. ...(13:04) Hvis vi ser på et idealistisk multivers, hvor det er (bevidste) Oplevelser, der er genstand for eksistens, så er det betydende for Oplevelsernes prior-sandsynlighed, hvordan Oplevelserne er "beskrevet" i den fundamentale logik, så at sige. Hvis en signifikant delmængde af alle Oplevelser er beskrevet med udgangspunkt i en Hjerne, hvor man altså ser på de fysiske bevægesler i en Hjerne (som dog med idealistiske antagelser kun eksisterer i kraft af den bevidste Oplevelse og ikke omvendt), og hvor Oplevelsens forløb så afhænger af disse bevægelser.. Hvis en signifikant delmænge af Oplevelserne i multiverset er beskrevet på den måde, så vil ikke opnå komplet kaos i multiverset, og hypotesen kan således ikke forkastes. Men hvis vi i stedet antager til vores hypotese, at alle Oplevelser i multiverset er beskrevet lidt som et slags computerprogram, hvor hver linje beskriver en ny følelse i rækken, som Oplevelserne følger, så vil der jo herved blive komplet koas, når man så antager (\emph{hvis} man altså antager), at "alt hvad kan eksistere, eksisterer." Så ville der være 0 orden i alle Oplevelser og alt ville være koas og tilfældigt. Enhvert udsnit af en Oplevelse, hvor denne indebærer en følelse af orden, vil så med al sandsynlighed hurtigt erstattes af nget komplet kaotisk igen. Og selv hvis man prøver at pålægge, at kun Oplevelser, hvor der er en sammenhængende selvforståelse, der gennemgår Oplevelsen, er gyldige, så vil dette stadig ikke kunne forklare, hvorfor vores omgivelser ikke går amok omkring os. Så alle sådanne hypoteser kan vi altså udelukke.

Dette er i øvrigt også interessant i en anden henseende, for nogle af modargumenterne mod materialisme går bl.a. ud på, hvis vi forestiller os.. Ja, der findes en vis xkcd, hvor en mand går i en ørken og flytter sten for at simulere vores univers. ..To sek.. ..Nummer 505, A Bunch of Rocks, hedder den. Så kan man så spørge, hvad ville der ske, hvis han gjorde det to gange? Hvad ville der ske, hvis han gjorde det to steder samtidigt, måske forskudt med en lille tidsforskel eller ej? Og slutteligt, hvad hvis han bare havde to sten hvert sted, som han mere eller mindre flyttede samtidigt? Nå ja, og helt slutteligt, hvad hvis det i stedet var bunker af sand, han flyttede rundt på, måske endda hvor nogle sandkorn faldt fra og nogle kom til i bunkerne, når han flyttede dem. Disse spørgsmål klarer de Oplevelses-orienterede multivershypoteser jo nemt, hvor der definerer hver Oplevelse jo bare selv, som en del af dens "naturlove," hvordan dens Hjerne defineres, samt hvordan denne bevæger sig og udvikler sig i tid. Hm, jeg kan dog nævne, at jeg lige her i går kom til at tænke på, at man måske kunne slippe af sted hvs man prøvede at definere en materialistisk hypotese, hvor man gør brug af entropi og koncepter om, hvad definere information, hvrnår information er unikt, og.. ja, og ting i den stil, men hvem ved? måske løber man bare ind i andre paradokser/svære spørgsmål herved.. Anyway, det jeg egentligt ville hen til, det var at jeg kan huske, at vi på et tidspunkt snakkede om dette i forbindelse med VT (videnskabsteori og etik (for fysikere)) på fysik, hvor en af mine venner fra fysik sagde, at han så (vist nok; sådan husker jeg det i hvert fald) troede på, at to identiske.. ja, "Hjerner" med identisk udvikling bare producerer netop én bevidst Oplevelse i multiverset. Elegant svar. Men nu kan jeg jo så se, at der faktisk er et stort problem med dette svar, for medmindre vi begrænser multiverset til noget meget endeligt, så vil alle mulige Hjerner jo forekomme, hvilket vil sige at alle mulige Oplevelser, der afviger fra hinanden vil forekomme netop én gang i multiverset/den samlede Eksistens. Men dette vil jo derfor medføre en komplet kaotisk prior-sadsynlighed for alle Oplevelser, og denne hypotese går derfor faktisk ikke, interessant nok. (13:46)

(15:10) Hov, jeg har også helt haft glemt noget andet virkeligt vigtigt. Når jeg har skrevet om de objektorienterede/materialistiske hypoteser ovenfor, så har det måske lydt som om, at materialismen har nogle ting, den ikke kan forklare, som Oplevelsesorienterede hypoteser kan forklare, men sådan er det nu slet ikke. Jeg synes personligt, at de Oplevelses-orienterede hypoteser gør det en anelse mere elegant, men det er bare en personlig holdning. For hvis vi nu starter med at se på den her hypotese, som jeg beskrev, med at hver Oplevelse har i/med sig en beskrivelse af/nogle love for, hvordan Oplevelsen starter og udviler sig i tid, eksempelvis ved at definere en Hjerne (muligvis sammen med en større samling af objekter, som Hjernen er en del af, nemlig et fysisk univers) samt nogle love for, hvordan bevægelsen af information i den Hjerne (hvor 'Hjerne' altså er et fuldstændigt abstrakt begreb, og kan endda indebære et helt univers f.eks.) fører til en (eller flere) bevidst(e) oplevelser. Men i de objektorienterede hypoteser kan man jo i stedet bare have nogle love, ved siden af lovene der beskriver, hvordan materie i universet bevæger og udvikler sig, som så beskriver, hvordan bevidste oplevelser kan opstå ud fra disse fysiske genstande. Hvis vi så tænker på xkcd-eksemplet (A Bunch of Rocks), så kunne der altså bare være nogle universer, hvor to af hver sten vil føre til to adskildte Oplevelser, nogle hvor de kun vil føre til én, osv (men hvor alle de fysiske love måske er de samme, og hvor startkonfigurationen af universet også er det samme; bare hvor lovene for de resulterende Oplevelser produceret af den fysiske materie er forskellige). Så ja, det kan sagtens lade sig gøre at give et klart svar på, hvorfor fysiske objekter kan føre til bevidsthed i et ellers overvejende objektorienteret multivers, og som altså ikke bare antager hardcore materialisme og siger: "jamen det sker bare helt automatisk, nemlig at når man har en fysisk Hjerne et sted, der kan have en bevidst oplevelse, så har den det også." Men ja, jeg synes så dog, at de Oplevelses-orienterede hypoteser klarer denne del mere elegant, end de overvejende objektorienterede multiversehypoteser, hvor man så indfører Oplevelses-love oveni, ved siden af de "fysiske love" i de indeholdte universer. (15:29)

Okay, nu når vi så til et afsnit, hvor jeg bare lige siger et par ting om, hvilke af de hypoteser, vi har set på, som jeg selv synes er ret nice, og som jeg tror mange sikkert vil kunne finde fornuftige i større eller mindre grad, og derefter kommer så det sidste afsnit, hvor vi ser på konsekvenserne ift. multiversets Subjekter (du og jeg og vi), og også på nogle pointer omkring moral.

Lad mig starte med at pointere, at en hypotese, hvor der er én grundlæggende (og "ren") logik om alt, og hvor alt så forekommer i takt med at denne logik ligesom "opdager flere og flere sætninger om sig selv," så at sige, og dermed også forstår hvordan flere og flere samlede oplevelser må føles.. At denne hypotese faktisk muligvis kunne give et matematisk regnestykke for prioren, ikke som vi kan finde frem til nøjagtigt, selvfølgelig, men hvor vi kan sige, at dette regnestykke faktisk på fornuftig vis godt kunne indeholde en ordning af alle Oplevelser, således at vi faktisk (med vores "jordlige" matematik) ville kunne tillægge en prior-sandsynlighed til hver Oplevelse i princippet. Lad mig prøve at omformulere dette.. ..Det er ikke ufornuftigt med en sådan hypotese, at teoretisere, at multiverset i princippet kunne indeholde en orden, en rækkefølge, kunne vi også sige, hvor alle Oplevelser (og jeg kan som man måske kan gætte sig til godt lide at antage, at hver Oplevelse er endelig --- det er i hvert fald en god antagelse, hvis man gerne vil nå frem til, at der må være en i princippet udregnelig prior i multiverset på denne måde..).. hvor alle Oplevelser udleves mere eller mindre én efter hinanden. Okay, kan jeg sige dette endnu mere klart..? ..Whatever, måske er dette underemne bare for komplekst, således at vi må gemme det til endnu senere (og at jeg altså ikke vil tale så meget om det i min første artikel om emnet). Men det korte af det lange er bare, at jeg altså tror, at der findes hypoteser, der (i hver fald for mig, og sikkert for mange) lyder ret fornuftige, og som kan føre til en fornuftig antagelse om, at multiverset har en pæn ordning af alle dets Oplevelser (også selvom rækken er uendelig), som gør at man matematisk (vores vores "jordlige" matematik) kan tilægge en prior-sandsynlighed til hvert univers/hver Oplevelse. Ok. Jeg vil ikke sige meget mere om, hvorfor jeg tror dette, men jeg bliver dog nødt til lige at nævne her, at jeg i går kom lidt i tvivl om fornuften ved dette, for hvordan skal en stor, samlet, "Ren" logik om alt lige vægte forholdet imellem, hvor lang tid sætninger "tager" at udlede (altså hvor mange logiske skridt, der går til udledningen), og hvor meget information sætningerne indeholder, når de skal ordnes. Nu ved jeg godt jeg "vrøvler" igen, så lad mig lige se på, om ikke jeg kan omformulere dette mere klart..  ..Hm, jo: Hvis vi ordner alle matematiske sætninger i en teori, f.eks. mængdelære, ud fra, hvor mange logiske skridt det tager for at udlede dem, så går det ikke ift., hvad vi ønsker a opnå, for så vil der (så vidt jeg lige kan se) blive uendeligt mange sætninger i hver (skridtantal-)kasse. Men hvis man så til gengæld indfører, at det også koster nogle skridt at læse lange sætninger, f.eks. hvis man har en lang antecedent som skal sammenlignes med en vist sætning i et modus ponens-skridt --- ret meget som om det foregik på en Turing-maskine (eller anden maskine), jamen så vil der pludselig blive endeligt mange sætninger i hver (skridtantal-)kasse. Problemet bliver så, at dette giver noget arbitrært til den "Rene" fundamentale logik, men ja.. Hm.. ..Okay, lad mig bare stoppe her, for det bliver hurtigt vildt kompliceret.. ..Det næste man så kunne tage hul på, det er at sige: "jamen hvad så hvis der så bare er en undelig mængde af fundamentale logikker," hvorved hver "logik" så kan tildeles en matematisk veldefineret prior for dets Oplevelserne, men så render man så bare ind i spørgsmålet: "Hvad hjælper det at der er lokale eldefinerede prior-sandsynligheder for hver 'logik,' hvis de samlede Oplvelser i multiverset, når man sætter det hele sammen, så stadig giver en svært-definerbar samlet prior for hver Oplevelse".. ..Hm.. ..Hm, måske skal man bare give op på, at få en matematisk veldefineret prior (ikke at vi nogensinde ville kunne regne den ud alligevel). I så fald kan man dog godt måske sige, at hypotesen, som jeg beskrev her lige ovenfor, nemlig med en helt fundamental "logik," der ligesom udleder (og "forstår"/"føler"/"oplever") sætninger omkring sig selv, "kommer tæt på," hvis det giver mening.. Det synes jeg i hvert fald lidt det gør..

Nå, men ellers har vi altå ogå bare rigtigt mange andre gode kandidater, må man sige. Jeg kan personligt faktisk også rigtigt godt lide den, hvor det ligesom er en masse "logikker"/"guder," der ikke har et mål med deres tankevirksomhed, og nok ikke har en selvbevidsthed på samme måde som, hvad vi forstår ved selvbevidsthed, som bare fremtænker universer, nærmest som en konsekvens af, hvad man kunne kalde en simpel nysgærrighed --- eller hvis man tænker mere "logikker" frem for "guder," så bare fordi at, jamen det er bare det fundamentale logikker gør; udvikler sig selv og "opdager" (og oplever) sætninger i sig selv. ..Og i sidste ende, så kan jeg egentligt også ok godt lide den hypotese, der bare siger: Alle mulige "objekter" eksisterer, og så forholder det sig i øvrigt bare sådan, at 'objekter' ikke bare indebærer dumme genstande, der flyver rundt og passer sig selv, men at 'objekter' i vores multivers også kan indeholde nogle definitioner af Oplevelser, som så bliver udlevet, enten ved at multiverset indeholder Subjekter samt nogle love for, hvordan disse Subjekter kan opleve ting, eller fordi der i hvert univers simpelthen bare er plads til, at der ved siden af de fysiske love også står nogle love, der simpelthen bare definere, hvornår og hvordan diverse Oplevelser bliver udlevet i universet (altså et sæt love, som vi nærmest kunne kalde "sjæle-love"). En todelt objektorienteret multivershypotese, som også bestemt lyder ret fornuftig i mine ører, selvom jeg dog selv hælder mere til de første, jeg har nævnt her, som ikke er ligeså "objektorienterede." 

Ok. Jeg synes, vi slap nogenlunde godt igennem det. Så når vi til det sidste afsit, som i høj grad handler om spørgsmålet: Hvordan skal vi forholde os til "døden?" (Ikke at vi vil besvare dette spørgsmål eksakt, men det er altså i høj grad temaet for afsnittet.) Og et andet spørgsmål for afsnittet er også: Hvordan skal vi forholde os til moralspørgsmålet. (16:16)

Det korte af det lange, hvis vi snakker omkring "døden," det er at langt de fleste af de hypoteser, inklusiv alle dem, der garanteret er/vil være mest udbredte hos folk, er at, hvad vi normalt betegner som "døden" ikke rigtigt har nogen betydning. For hvis multiverset er uendeligt, så vil vi leve igen og igen og igen i alle mulige afskygninger af os selv, og dette gælder så f.eks. både hvis man er hardcore eller semi-materialist, eller hvis man tror at ens eget Subjekt, som jeg har kaldt det ovenfor, ikke er fundamentalt adskildt fra andre Subjekter i universet, men bare er en del af det store hele, hvad end "det store hele" så er en "gud" eller en "logik" for ens univers. Så hvis man altså ikke er tilbøjelig til at tro, at vi har en "sjæl," jamen så når man den konklusion (at vi skal lave alle afskygninger af vores liv --- og af alle andres liv, men det kommer jeg til om lidt), og hvis man tror på, at vi har en slags sjæl, men at den sjæl enten bare er en del af Gud (eller en del af noget andet meget grundlæggende i universet og/eller multiverset som helhed), eller vi returnere og blive en del af Gud efter døden, og således også blandes sammen med alle andre nuæevende sjæle, jamen så når man også samme konklusion. I sidstnævnte tilfælde (især hvis man også forestiller sig at der er en global Tid i multiverset --- eller bare en lokal til, som den lokale "gud" eller "logik" også følger) så il det jo nemlig være naturligt videre at antage, at når en ny person fødes i universet, jamen så tages der lidt af "Gud" igen til at danne en sjæl igen, og således vil ens nuværende sjæl altså fordeles ud på alle andre personer/Oplevelser, som leves efter en selv. Og medmindre Gud/"logikken" der foresager det univers, vi lever i, er utroligt begrænset, så vil der være mange universer, som dette væsen foresager, og der vil altså aldrig ophøre med at være liv. Jeg tror allerede disse antagelser dækker, hvad rigtig mange mennesker ville synes giver god mening. En anden antagelse, som ikke har så meget med "alt hvad der kan eksistere, eksisterer"-hypotesen at gøre, men som måske også ville være udbredt hos folk, det er at sige: Multiverset er faktisk ret begrænset, men jeg tror på en Gud, og at man sjæl når op til ham og bliver passet på ham efter døden. Og ja, denne antagelse gør jo selvsagt også frygten for døden ret irrelevant --- ja, medmindre man i stedet tror på, at man skal i helvede, men det er nu nok de færreste, der slås for alvor med den tanke, for hvis man er en person, der tager den tanke seriøst om sit eget "efterliv," så vil man nok bare prøve at leve mere fromt og så håbe på det bedste. Så ja, det virker virkeligt ikke som om, at nogle af de hypoteser, der nok vil være mest udbredte hos folk, vil føre til andet end, at man ikke behøver at frygte dødens kommen. Nu mangler jeg så bare lige at forklare mere om, hvorfor at vi ikke bare skal lave alle afskygninger af vores egne liv men også alle andres med de første hypoteser nævnt i denne paragraf, og så mangler jeg også at dykke ned i de få hypoteser, der antager "alt hvad der kan eksistere, eksisterer"-hypotesen, men hvor man stadig kan være urolig for "efterlivet".. Nå ja, og så mangler jeg også lige at sige: Der vil måske også være nogle få helt- eller sei-materialister, som af en eller anden grund tror på, at multiverset er ret begrænset. Men hvis bare multiverset indeholder universer som vores, og hvis det nu indeholder bare ét unvers, som bliver ved med at Big Crunch'e og udvide sig igen i en uendelighed, jamen så er det også med al sandsynlighed det vi lever i *(og alle andre døende universer vil med al sandsynlighed allerede være døde for en fantasilliard år siden), og så vil vi dermed også leve igen i alle afskygninger. (16:42)

Ok, nu til den der pointe om, at vi ikke bare skal lave "vores eget liv" i alle afskygninger, men også alle andre, og det er simpelthen fordi, at hvis vi antager at multiverset er uendeligt, så vil hver eneste mulige liv man kan forestille sig (og også sikkert vildt mange, som vi ikke kan forestille os;)) forekomme, nogle bare med virkelig lav frekvens i forhold til andre. Så hvis vi opstiller to liv overfor hinanden, så vil vi kunne finde udgaver af liv midt imellem de to liv på en kontinuer linje, hvor hvert liv vi plotter ind på linjen har en vis, større eller mindre frekvens ift. hvor ofter det forekommer i multiverset. Og vi kan sågar finde undeligt mange forbindelser på denne måde mellem to liv. Hvis man så spørger, hvad hvis den ene er en mand og den anden en kvinde, hvad hvis de bor på to forskellige planeter, hvad hvis de er af to helt forskellige arter (f.eks. hvis den ene eller de begge er en eller anden alien)? Jamen selv i alle disse tilfælde vil man kunne finde en glidende overgang, hvis altså man bare dykker dybt nok ned og tager fra de lavfrekvente livsforekomster i multiverset. Og målt op mod uendeligt vil selv ufatteligt lav frekvente livsforekomster forekomme, ja, uendeligt mange gange. Så på den måde indebærer "alle afskygninger af vores eget liv" simpelthen bare "alle afskygninger af mulige liv." 

Og hvis man altså dermed tror på, at multiverset ikke er begrænset, men er uendeligt ift. dets muligheder og dets forekomster, så når man altså ret nemt til, at "vi skal leve alle afskygninger af vores eget og alle andres liv igen og igen." Dette er dog medmindre man altså antager nogle ret specifikke ting, nemlig: At vi har en sjæl hver især, som er adskilte fra hinanden, og som aldrig smelter sammen igen på noget tidspunkt. At disse sjæle af en eller anden mærkelig grund også oveni købet er dødelige --- eller at de bare ligesom lever den samme meget begrænsede mængde liv igen og igen. Hvis man mener nogle af disse ting, så når man altså ikke nødvendigvis den konklusion. Jeg tror dog, at førstnævnte udgave, nemlig at vi alle har for altid adskildte sjæle, som dog er dødelige, vil være vildt sjælden at finde hos folk. At ens sjæl f.eks. lever det samme liv igen og igen, enten helt uden eller måske med nogle få variationer, den vil måske være lidt mere udbredt, men på den anden side kun slem, hvis man har haft et ligefremt dårligt liv. Men selv da, så vil mange nok hælde til den version, hvor der dog sker nogle få variationer gang på gang, og hvis man så dykker ned hypotesen herfra, så vil mange nok ende med at erkende, at hvis dette sker i al uendelighed, så vil variantionerne også ende med at blive uendeligt store, og så når man samme konklusion igen. Det kan man om ikke andet håbe.

Men ja, så det korte af det lange er altså, at hvis man tænker i dybden over multiverset afgrænsning, eller nærmere bestemt mangel på afgrænsning, så vil de fleste nok kunne blive ret afklaret med døden heraf. (Ikke at de fleste ikke allerede er afklaret med døden, men der findes dog alligevel også mange der frygter den på nuværende tidspunkt). 

Og så kan vi så slutte af med spørgsmålet om moral *(hov, jeg mener 'etik,' rettere), for det smukke ved disse teorier, er at når man når omtalte konklusion med at vi skal leve alle afskygninger af alle liv igen og igen, jamen så når man dermed også frem til en utrolig bogstavelig udgave af "what comes around goes around." Man udvisker altså herved helt forskellen på, hvad en filosofisk egoist vil mene er korrekt etik, og hvad en utilitarist (eller andre etikker, der fremhæver altruisme og "godhed") vil mene! Jeg vil altså påstå, at man, uanset hvordan man vender og drejer det (stort set), når frem til en etik der siger: Lev dit liv som om, at alt hvad du foresager af godt og ondt med andre (inklusiv andre arter og livsformer), det vil du selv opleve (med rollerne byttet om) i et efterfølgende liv, og bak om om at andre i dit samfund bør følge den samme etik. Og svaret på, hvorfor denne etik bør følges, er så både, at, jamen, dette er en god etik at følge for et samfund, men også at, jamen, antagelsen i den etiksætningen er sikkert også sand for all intends and purposes. ..Kortere sagt kan man sige: Lev dit liv ud fra en antagelse om, at du og alle andre skal leve hinandens liv i lige forhold i alle jeres efterliv.

Det skal så lige siges, at nogen vil pege på fri vijle og sige, at jamen, bare fordi jeg med min frie vilje gør skade/ondt på en anden person, jamen så betyder det ikke, at den/en anden person vil gøre skade/ondt på mig i efterlivet i de udgaver, hvor rollerne er byttet om. Denne opfattelse fordrer, at man tror at ens handlinger ikke kan forklares alene ved hjernens fysiske bevægelser, men at sjælen på en måde også sidder der med en slags joystick i overført betydning og påvirker, hvad hjernen gør. Hm, tja, det har jeg vel egentligt ikke så meget at sige til, når det kommer til stykket, for det er muligvis så langt væk fra min egen opfattelse af, hvordan virkeligheden fungerer, at jeg nok aldrig har tænkt så meget på at argumentere omkring de antagelser.. Hm.. Oh well, lad mig så bare slutte for nu, og så lade den diskussion stå åbent.. ..Hm, ah øv, den holdning kunne godt gå hen at blive problematisk, når det kommer til at enes om etiksprørgsmålet.. ..Hm, og måske også når det kommer til at trøste folk, der har levet et direkte dårligt liv, og er bekymret for, hvis de skal gøre det igen og igen i al uendelighed.. Hm.. Nå, men jeg lader det være for nu. I de ovenstående noter har jeg bare antaget, at alle Subjekter bare oplever deres Oplevelser, og at Subjekterne altså ikke selv går ind og påvirker de Hjerner, de har tilknyttet sig.. Hm, men det er da egentligt en hypotese-mængde, der er værd at have med også. Ja, ok. Så når jeg på et tidspunkt skriver dette som en artikel, så må jeg lige huske, at inkludere sådanne hypoteser også, og så må jeg også lige sørger for inden da at tænke lidt mere over, hvad man så kan sige om døden og om etik, hvis man antager sådanne hypoteser.

Men slut for nu.:) Det var rigtigt dejligt lige at få gennemgået det hele i en nogenlunde sammenhængende tekst, for jeg tror at alle mine tidligere noter omkring emnet alt i alt har været ret usammenhængede. Så rigtigt dejligt lige at få gået det hele (eller rettere det meste af det) igennem igen i store træk --- og dejligt også at få tænkt nogle nye tanker omkring emnet!:) Og jeg tror altså umiddelbart godt, jeg kunne skrive denne gannemgang her om, så det kunne blive en god lille (eller knap så lille, alt efter hvor kortfattet jeg kan gøre det..) artikel. Det vil jeg se frem til.:) (17:36, 06.01.23)

(07.01.23, 9:13) Okay, der er lige nogle få ting, jeg skal huske at nævne også, og så mangler jeg også at diskutere den mulighed, at vi har dødelige "sjæle"/Subjekter noget mere. Lad mig lige starte med at uddybe, at i de Oplevelse-orienterede hypoteser er hvert "univers" i multiverset ikke et fysisk univers, men et idealistisk univers, der indeholder én eller flere Subjekter, der udlever en eller flere Oplevelser. Jeg mener endda, at det mest oplagte for sådanne hypoteser bare er at have ét univers pr. Oplevelse. Men så skal det altså ikke forstås sådan, at vi er.. alene om at være bevidst i vores fysiske univers --- jo, det er vi på en måde, for det fysiske univers findes kun i kraft af vores egen Oplevelses eksistens i så fald, og ikke af personer okring os, men man skal så huske på (og dette er så selvfølgelig antaget, at "sjælen"/Subjektet ikke har indflydelse på Oplevelsen, og at hver Oplevelse der fastlagt ud fra nogle love, ligesom også jeg har antaget i resten af denne tekst), at alt hvad man gør i ens "eget" univers så bare bliver spejlet i et tilsvarende univers, hvor "sjælen"/Subjektet har tilknyttet sig en anden hjerne (med lille 'h,' fordi vi her snakker om vores egne "kød-hjerner"). Det var det første, jeg lige ville uddybe.

Det næste, jeg vil uddybe handler om hvordan Oplevelser mon kan defineres i hypotesen. Her kan vi starte med at se på en sjov lille idé om, at alle Oplevelser kunne være meget korte, altså i subjektiv tid, og at vores egen opfattelse af en lang, sammenhængende Oplevelse bare er.. ja.. er subjektivt skabt.. Men nej, vi kan faktisk forkaste sådanne hypoteser, eller i hvert fald givet den indledende antagelse om at "alt hvad kan eksistere, eksisterer," for så vil en vilkårlig sammenhængende Oplevelse jo ikke behøve at følge nogen lovsætninger rigtigt. For eksempel kunne vi have en sammenhængende oplevelse af, at en person træder ud af en dør og med det samme kommer ind ad en helt anden dør; oplevelser der isoleret set måske følger nogle lovmæssigheder, men ikke når man sætter dem sammen. Alt ville derfor blive totalt kaotisk (sandsynlighedsmæssigt), mere eller mindre, og derfor kan vi altså forkaste det. Ok. Så Oplevelser i sådanne Oplevelse-orienterede multivershypoteser skal altså være længerevarende. Men hvor lang tid skal de så vare? Jo, det ville jo være underligt, hvis de alle var en meget specifik længde; hvorfor skulle det store samlede multivers være så specifik? Så de tre eneste fornuftige muligheder er nok bare, at de enten er uendelige alle sammen, at de er endelige men med vilkårlige længder, og som den tredje mulighed at der både findes uendelige og endelige Oplevelser. Nu er det så oplagt at spørge: Jamen slutter en Oplevelse ikke bare ved døden, mere specifikt altså når den pågældende Hjerne ikke længere opfylder de krav der skal gælde for den (pr. de love som "universet" (som i dette specifikke tilfælde er defineret som led i definitionen af Oplevelsen) påskriver)? Tjo, det kunne de sikkert sagtens gøre i mange tilfælde. Men man kunne også sagtens forestille sig, at Oplevelsens/"universets" definition af den iboende Hjerne tillader, at Oplevelsen kan hoppe fra fysisk hjerne/Hjerne til en anden fysisk hjerne/Hjerne. Desuden kunne man også have Oplevelser, der bare simpelthen er sammensatte, i den forstand at de er defineret med en "lovtekst" noget i retning af: "Først skal du hoppe sådan og sådan fra fysisk hjerne/Hjerne i det her fysiske univers for så og så lang tid (eller indtil det og det sker), og efter det skal du så leve i det og det fysiske univers (med de og de fysiske love) og hoppe sådan og sådan fra Hjerne til Hjerne indtil sådan og sådan, og efter det..." På den måde kan man altså definere nogle oplevelser, der er virkeligt lange. Og både hvad angår endelige og uendelige Oplevelser kunne man endda have definitioner, der definerede hver del-Oplevelse i sekvensen ud fra en mere abtrakt formel (eller (Turing-)maskine-starttilstand, eller hvad man nu kan tænke sig), og så iterere over alle de individuelle udgaver som følger den formel (eller hvad man tænker sig). Og hermed kan man så nå nogle virkeligt lange Oplevelser. Og hvis vi videre tillader, at Oplevelsernes definitioner også kan sige noget så som: "Gentag disse iterationer et antal gange lig Grahams tal" (eller TREE(3) eller TREE(TREE(3)) og hvad vi ellers kan finde på), jamen så kan man have (bogstavelig talt) helt ufatteligt lange Oplevelser. Ok. Hertil skal det så pointeres, at hvis vi antager at, "alt hvad kan eksistere, eksisterer," og hvis vi kan danne vilkårligt lange af sådan nogle Oplevelses-beskrivelser, jamen hvis vi så prøver at spå om, hvor lang vores egen Oplevelse-beskrivelse må være, så vil vi jo ikke kunne sige andet end: Dens længde må i gennemsnit være uendeligt. Det virker vildt med det er faktisk konsekvensen.. Nå, og nu er det så her teorien om CUH kommer ind, for hvis man så overvejer hvilke nogle del-Oplevelser (altså dem med en nogenlunde konstant selvforståelse), der må være flest af i sådan en uendelig mængde af Oplevelser med vilkårligt lange beskrivelser, jamen så kommer man vist rimeligt nemt frem til (tror jeg/mener jeg), at de del-Oplevelser med tilsyneladende relativt lav information vil være mere frekvente.. Tja, eller det giver faktisk lidt sig selv: Der vil være en høj frekvens af del-Oplevelser, hvor det iagtagende univers tilsyneladende følger ret simple principper. Så det er altså sådan, at CUH kommer ind i billedet, når vi snakker Oplevelses-orienterede multiverser. *(Der er kan være lidt forskel på, hvad (prior-)sandsynlighedsfordelingen er i forskellige Oplevelse-orienterede hypoteser, eksempelvis afhængende af hvorvidt multiverset ordner Oplevelser og udlever dem ud fra, hvad der svarer til en "regnekraft" og sådan. Men det er nu ikke fordi, vi alligevel kan regne os frem til den faktiske sandsynlighedsfordeling overhovedet. Så for os behøver vi bare at vide, at vi nok får noget, der svarer til CUH, hvilket det vil gøre hvis det opfører sig pænt, og altså ikke giver os komplet kaos, som vi har set på.)

Nå, og nu kan jeg så slutteligt vende tilbage til den mulighed, at multiverset indeholder endelige ("dødelige") Oplevelser, og hvad det bør betyde for vores tilgang til døden. Og det korte af det lange her er så bare, at hvis der både er endelige og uendelige Oplevelser, jamen så vil der med al sandsynlighed, for dig der læser dette, allerede været gået en fantasiliard år (altså TREE(TREE(TREE(...))) år; find selv på hvor mange TREE der skal stå i rækken) og størstedelen af alle endelige Oplevelser vil allerede være døde, og du vil med al sandsynlighed være en af de uendelige. Og faktisk kan man næsten sige noget tilsavarende, når det kommer til de hypoteser, der kun indeholder endeligt varende Oplevelser. ..Tja, eller det afhænger godt nok af den specifikke hypotese, men under antagelse af at Oplevelsers levetider godt kan være defineret ud fra koncepter så som TREE(TREE(...)) osv., så vil de afsindigt lange Oplevelser også lynhurtigt.. tja, det var et forkert ord at bruge, men set i forhold til uendeligt, så jo, så vil det "lynhurtigt" blive kun dem, der er tilbage. Og ikke nok med det, de vil også veje utroligt meget mere end alle de knap så lange Oplevelser. Hvis man f.eks. ser specifikt på antallet af gange, hvor et Subjekt spørger sig selv (eller rettere har oplevelsen af at spørge sig selv): "Hvor lang mon min Subjektive levetid er endnu?" Hvis vi ser på statestikken omkring det antal for hver Oplevelse, så stort set alle.. nej, basalt set alle (som i: alle for all intents and purposes) forekomster af disse spørgsmål findes i Oplevelser, der er længere end T=TREE(TREE(...)) tid, efter vi den globale tid er lig TREE(TREE(...)). Altså når det globale ur slår TREE(TREE(...)), så vil forekomsten af alle sådanne spørgsmål til sig selv have fundet sted på ligeledes langvarige (eller længere) Oplevelser. Ok, dette er sikkert vrøvl for mange, og desuden så har jeg også her antaget, at der findes en global tid, eller i det mindste at der findes noget der svarer til en sådan. ..Okay, lad mig bare sige det sådan her: Hver gang et Subjekt spørger sig selv (eller rettere har oplevelsen af at spørge sig selv): "hvor lang mon min Subjektive tid har varet indtil nu?" så vil denne tid i gennemsnit være uendeligt (så i praksis, når vi spørger os selv, så vil svaret være: så ufattelig stor at du ikke vil kunne skelne det fra uendeligt). Og når man så spørger: "hvor lang mon min Subjektive levetid er endnu?" så vil svaret være det samme. Forklaringen på, at jeg mener at dette er tilfældet, den er lidt indviklet, og den kræver også lige nogle antagelser, må jeg indrømme, men under rimelige antagelser når man altså ret nemt hen til det samme svar: Hvis alle Oplevelser er dødelige, så vil alle korte og mellemlange Oplevelser "lynhurtigt" dø ud, når man opvejer dem mod uendeligt, og kun de ektremt lange (ja faktisk ufatteligt lange) Oplevelser vil være tilbage, hvilket vil sige at du selv, i det øjeblik du læser dette, i så fald så med al sandsynlighed vil tilhøre mængden af de ufatteligt lange Oplevelser. Okay, så er det vist godt med det for nu.xD^^ 

Det var, hvad jeg havde at tilføje om dette emne.:) (10:31, 07.01.23)







## Blockchain

(31.08.22, 10:25) Jeg havde egentligt lidt tænkt mig alligevel at udgive min angrebsvektor (med tilhørende forsvar) hurtigt på min GitHub, men jeg tænkte lidt over det i går, og det er lige før, at jeg faktisk ikke gør det alligvel; ikke i nogen stor fart.. Jeg kan lige tænke lidt mere over det, men jeg tror faktisk ikke helt, der er kød nok på.. tjo, tja, jeg ved det ikke; jeg skal nok lige tænke lidt mere over det. Men umiddelbart tænker jeg altså ikke at bekymre mig om at skynde mig at få det ud.. 
(02.09.22, 11:01) Nej, jeg tror simpelthen ikke der rigtigt er noget guf på denne idé. Så ja, alle mine blockchain-tanker er nu ret meget ude af vinduet.. Selvfølgelig vil jeg dele idéen om angrebet på et tidspunkt, men jeg tror altså ikke rigtigt, den kan få nogen til at spærre øjnene op (og være vildt interesseret, i.e.).. 


*((18.09.22, 11:51) Okay, glem stort set alt, hvad jeg har skrevet her i går:)
(17.09.22, 12:27) Jeg havde en ret vild (som i 'ude af normen'; ikke vild som i ' fest-vild') nat, hvor jeg gik i seng lidt efter tolv og så var vågen helt til omkring seks. I lang tid kunne jeg bare ikke sove (selvom jeg ikke synes, jeg gjorde noget som helt galt, eller havde det for varmt/koldt; det eneste jeg kan tænke på var, at jeg måske var en lille smule sulten, men kun en meget lille smule og ikke noget, jeg synes forstyrrede mig!..), men på et tidspunkt begyndte jeg også at tænke lidt over fysik, så lidt om mine "planer" (jævnfør sektionen nedenfor), og så fik jeg så også tænkt på blockchain, hvor jeg mellem fem og seks synes jeg fik et hel væld af gode idéer.. Så ja, dem vel jeg så skrive om her (og genoverveje dem)..:).. 
..Hm, lad mig bare prøve at forklare, og så kan jeg overveje imens:
..Hm, eller lad mig egentligt lige starte med at skrive om, at jeg i første omgang fik nogle tanker, hvor jeg bare tænkte: ah, måske kan jeg alligevel godt skrive om blockchain (og mit angreb) i min GitHub-mappe, hvis jeg bare indleder den grundlæggende del af det/hovedparten med at sige, at det altså bare er et argument, hvorfor en kryptovaluta (KV) ikke kan overtage og blive en meget almindelig valuta på lige fod med normale penge. Så fik jeg tænkt på, at pointen i sig selv om, at et angreb kan være mere attraktivt at udføre, fordi man nemt kan ende med ikke at skulle betale alle de mønter, man satte på højkant i replay-angrebet, jo er en vigtig pointe i sig selv, som er værd at dele.. Nå, og der ved femtiden (måske lidt efter; måske tyve over) kom jeg så til at tænke på, at man jo faktisk ingen gang behøver at sætte penge på højkant, i bund og grund, fordi man bare kan forke og lave en gren, hvor man har (brugte!) penge, og så sætte dem på "højkant." I løbet af den næste halve time derfra (omkring tyve over fem altså) fik jeg så en masse gode supplerende idéer (nogen af dem, som jeg har fået før i andre sammenhænge), nemlig om at man jo kan snyde med tiden og dermed sørge for at booste mining-farten en smule til at starte med (ved at skrue tiden frem en smule, nemlig til.. tja, eller også kunne man egentligt bare starte fra nutidspunktet, det ville måske være det nemmeste..), hvilket både gør at man hurtigere kan danne blokke trods stærkt formindsket minin-kapacitet (og man bør i øvrigt helst forke lige inden den blok, hvor "målet" (the target) bliver sat ned) og altså hrutigere kan få sine malicious kontrakter ud, og også gør at det bliver noget nemmere at tiltrække minere (for lønnen er jo den samme pr. blok). Derfra tænkte jeg så også, at man bare kon offentliggøre kontrakterne forud for at blokkende bliver minet. Og så tænkte jeg på, at man jo så også kan rekrutere alle, der har solgt KV siden fork-punktet, for man kan jo gentage alle de kontrakter, medmindre de har betingelser, der nævner tidligere blokke i kæden (som jo nu vil blive erstattet). At sælge sine mønter med smartkontrakter, der nævner, hvad tidligere blokke er, kan så i øvrigt være en måde at sikre sig mod sådanne angreb *(nå nej, man sikrer sig jo ikke herved, så never mind den del (her til venstre for denne kommentar)), hvilket på en måde faktisk bare er godt for angrebet, for det gør det jo bare nemmere at rekrutere folk, nemlig som har sikret sig, at de ikke selv kan udnyttes. Nå, men man kan også gøre endnu mere, tænkte jeg på: man kan også starte med at gøre så den ekstra miningløn, som angreberne sætter minerne i vente på angrebsforken, ligesom bliver administreret på en sidechain af angrebsforken. Her skal folk så kunne melde sig til rimeligt frit, og man kan så implementere, at man kan udlove dusører på betingelse af, at den endelige blok overholder nogle ting, hvorved man altså kan gøre så dusører bliver betinget af, hvilke kontrakter der kommer med, og hvilke ikke kommer med (når man arbejder sig hen imod nutidsdatoen). I øvrigt (tænkte jeg på lige nu her) kan man jo potentielt set, hvis man skal gøre det virkeligt sofistikeret, sørge for at angriberne har en vis frihed til at lave bestemmelser over de dusører, de allerede har udlovet, hvor de altså så får en vis frihed til at vælge, hvilke eksisterende kontrakter skal med og ikke med, men hvor det så skal sikres, at de ikke har mulighed for at skabe nogen modstride og gøre deres dusør-kontrakter ugyldige herved. Og ja, ellers kan man jo også bare have det sådan, at de betingede dusører udstedes, når der er behov for dem, for angriberne kan jo sagtens give flere og flere dusører løbende (og hvor "angriberne" altså også med tiden kan indbefatte flere og flere).. (13:04) ..Nå ja, og prikken over i'et, som jeg kom til at tænke på omkring ti i seks (ja, det gik ret hurtigt, kan man sige ..tja, men mange af "idéerne" minder jo trodsalt rigtig meget om tidligere idéer..), er jo så denne pointe, nemlig at angrebskæden faktisk har en fordel over for den "uskyldige kæde"/den originale ("rigtige") kæde, fordi angriberne jo, i modsætning til folk på den "rigtige" kæde, der skal prøve at gå til modangreb, ikke "mister" noget som sådan, når de udlover dusører, for de penge har de jo allerede brugt!. (13:08)
..(13:09) Okay, nu ser min angrebsidé jo faktisk ud til virkeligt at virke, hvilket ville være kæmpe stort, for det kommer bare til at booste interessen for mit andet arbejde \emph{så} meget mere, kan jeg forestille mig. Så hvis jeg ikke tager fejl i det her, så har jeg altså nu potentialet til, med en rimelig kortfattet tekst (jeg vil bare forklare det simpelt; i kortfattede, måske to-tre-sætnings-lange, paragrafer), at opnå, hvad der ift. mit fysik projekt vil svare til vildt meget arbejde (hvis vi tænker på sådan noget som at arbejde på "future work"-emnerne, og også bare sådan noget som at rette min artikel godt igennem, så den kommer til at fremstå skarp --- det bliver pludesligt ikke nær så vigtigt, hvis jeg også har denne kæmpe nyhed om blockchain (der endeligt kan bane vejen for mere "grønne" blockchains(/soft forks)))..! :D:) (13:15) ..Hm, det er i øvrigt sikkert også det \emph{helt} rigtige tidspunkt at komme med sådan en idé som denne..!.. 
...(13:33) Hm, og det er jo klart, at dette stadig mere er et argument for, hvorfor nuværende KV'er ikke kan fungere som konventionelle betalingsmilder, for det vil aldrig være attraktivt at lave et konspirationelt replay-angreb på en kæde, der så bare mister al dens værdi (hvilket jo er rigtig godt; det gør jeg jeg ikke behøver at have skrubler over at udgive det). Men en etableret kæde, hvor store dele af samfundet pludselig har stake i kæden, det er en anden snak, for så kan værdien nemlig holdes oppe af denne stake. 

(18.09.22, 11:53) Glem alt hvad jeg har skrevet her ovenfor. Nu hvor jeg har fået mere hjerne igen (har sovet godt i nat, men kom allerede frem til i går aftes, at mine tanker her ovenfor ikke kunne bruges), kan jeg se, at det ikke holder. Især ikke den del med, at angriberne "har en fordel".. ..Og de andre ting holder bare heller ikke rigtig; gider næsten ingen gang forklare hvorfor.. Nej.. ..Nej, lad mig bare strege hele den.. hvad skal vi kalde det? undersektion?.. fra i går.. Ok. 




## Planer

(02.09.22) Nu hvor blockchain-idéen lidt er ude af vinduet, så tror jeg let det kan blive en langtrukken proces om at slå igennem. Jeg er så ved lige at planlægge, hvad jeg skal gøre efter min udgivelse. Jeg er lidt kommet frem til, at jeg skal starte med at give nogle korte ("less is more"-agtige) udgivelser (i min GitHub-mappe) omkring mine web 3.0-idéer --- hvor jeg i øvrigt måske kan fokusere lidt på "ratings" i det semantiske web, som en af de gannemgående idéer, men så ellers også bare det at starte det ud fra web 2.0-sider og wiki-sider; ting som virker allerede, men som kan forbedret af brugerdrevet semantik.. ..Nå, men jeg har lige nogle få ting, jeg lige skal planlægge færdigt omkring det.. (11:10) ...Ah, jeg tror måske, jeg ved hvad jeg gør.. Måske lader jeg bare være med sige, at der er mere ved idéerne end hvad jeg skriver --- ah, og måske også skriver om dem som om de er meget nye idéer (hvad de på én led også er, kan man sige, selvom jeg dog har gennemarbejdet dem lidt (men ja, jeg kan så lidt lægge skjul på, at jeg har gennemarbejdet dem overhovedet, og præsentere dem bare som nogle idéer, jeg gerne vil arbejde videre på.:))) --- og så tænker jeg nemlig særligt også at præsentere min forretningsidé som en helt ny idé, jeg godt kunne tænke mig at arbejde videre på.. ..Hm, men jeg tænker nu dog lige at vente en ekstra omgang stadigvæk med at udgive denne idé-skitse af min forretningsidé. ..Ah, eller endnu bedre ift. at kalde dem nye idéer: Jeg kan bare sige, at de alle er ret nye; at jeg har haft lidt tid til at overvejet dem hver især, men at de dog stadigvæk er på design-stadiet (og på et stadie, hvor de bør overvejes endnu mere for at finde fejl og mangler i dem)..:) Nice.!.. For så har jeg dækket ryggen på en fin måde, og så kan jeg bare lade pitchene tale for sig selv. ..Nå ja, og jeg skal så heller ikke reklamere med, at jeg har en forretningsidé til at starte med: Pointen er lidt \emph{ikke} at give folk opfattelsen af, at jeg muligvis sidder og gemmer på en guldgrube --- ikke før det kan betale sig. (11:42) (For på den måde tror jeg, jeg vil få meget mere positiv energi, og nemlig forhindret en masse potentiel negativ energi (bl.a. fordi folk kan få en negativ reaktion til en, de mener, har munden for fuld).) (11:43)
(03.09.22, 11:09) Tror faktisk endda lige jeg venter en omgang med at nævne min wiki-idé og dabatside-idé også. Til gengæld kan jeg måske nævne ret hurtigt, at der er en/nogle ekistensteori(er) på vej også. Men det kan jeg lige se på. Det er forresten lige før, at jeg vil arbejde på at skrive en uddybende tekst (på engelsk) omkring min forretningsidé først, før jeg begynder at skrive om mit selvadjungeretheds-bevis.. 

(04.09.22, 10:11) Jeg skal faktisk lige overveje noget mere, om det nu også er klogt at offentliggøre sine idéer, så de gængse sider faktisk nærmest får et forspring. Jeg tror muligvis, det går, men det må jeg altså lige tænke mere over i mine pauser.
(14:58) Ja, det går; jeg skal helt sikkert bare offentliggøre de idéer med det samme. Jeg skal i øvrigt også huske at snakke om brugergrupper og anonymitet i disse, men ja, jeg vil jo bare gå igennem alle mine punkter, npr jeg når dertil, og så udgive om alle dem, der kan forklares rimeligt kortfattet, nok på nær dem der har med vidensdeling og debat lige i første omgang, dog. (15:00)


(13:17, 17.09.22) Jeg tror muligvis jeg snart vil begynde at oplaude ting til min note-mappe, og måske vil jeg faktisk også allerde begynde at lave nogle små tidslåse (bare over et par måneder), f.eks. til min blockchain-angrebs-idé (hvor jeg så på den anden side vil udgive løsningsforslaget med det samme). 

(11:58, 18.09.22) Hm, nu overvejer jeg faktisk bare at give hints til koden, og så måske lave en kode (også) bare af nogle danske ord sat sammen (og måske gentaget tre gange, hvis det ellers er kort). ..Det virker på en måde sjovere, end det andet, og jeg tænker alligevel faktisk at åbne det hele før snarere end senere.. ..Og jeg overvejer også faktisk lidt at pitche min forretningsidé i samme omgang, som jeg pitcher mine idéer til en ny web 3.0-bølge.. ..Men det må jeg jo lige tænke nærmere over i de kommende dage (i min "fritid").. (12:03)

(19.09.22, 16:11) Okay, nu har jeg nogle meget bedre planer..! Jeg er kommet frem til her i dag (i en pause fra at tænke på fysik her på min seneste gåtur). Det korte af det lange er, at jeg bare skal forklare om min forrestningsidé med det samme, og så ikke være bleg for at sige: jamen, jeg er sikker på, at dette bliver den næste vildt store ting; langt langt større end BitCoin osv. endda (hvad jeg jo helt klart også tror på selv). ..Jeg tror lige, jeg vil vende tilb.. nå nej, det hører jo alligevel til ovenfor. Ok, så jeg har også nogle idéer til, hvordan man kunne opfordre til at starte det meget simpelt, nemlig med en kickstarter og med nogle løfter (som man så hurtigst muligt skal underbygge med kontrakter). Og dette vil jeg så altså også bare lægge op til, når jeg (meget hurtigt efter min fysik-udgivelse) skriver om idéen i min GitHub-mappe.. ..Ok, lad mig vende tilbage hertil, og uddybe lidt mere, hvis jeg synes, jeg bør sige noget mere...
%..(16:21) Nå jo, lad mig også lige nævne, at jeg nu også har tænkt mig at give en kort note om, hvordan der ikke skal "særligt meget uendelighed til" i multiverset for at man når frem til, at vi basalt set genfødes som alle levende væsner igen og igen --- og at man derfor kan tage "what comes around goes around" fuldstændig bogstaveligt, for vi skal på den måde alle opleve de samme glæder og smerter. 
%(17:38) Jeg tænker så også bare at lægge alle mine noter ud med det samme, bare til \emph{hvis nu}, nogen skulle være interesseret i at sneak-peak'e (og ofre noget tid), inden jeg får skrevet mere sammenhængende noter over emnerne (de vigtige af dem i hvert fald). Og så tænker jeg i øvrigt også bare ikke at lægge skjul på, at jeg tror min forretningsidé, hvis den udbreder sig til andre områder, kan blive lidt en kur til de negative sider af kapitalismen (men endda uden at bryde med kapitalismen; forretnings baserer sig helt på et frit markede osv.!). (17:41) 


(18:07, 27.09.22) Jeg tænker nu lidt faktisk at starte med at skrive om min forretningsidé i sig selv (og som jeg lige har skrevet ovenfor, bliver dette altså uden at hype den som den næste store investeringsdrøm, for det er jeg kommet i tanke om, at den jo nok ikke vil være som sådan..). Jeg vil så forklare om, hvordan den fungerer, hvad den lover for fremtiden, hvad hver part vil få ud af den, hvorfor forbrugere i det hele taget burde have magten i et kapitalistisk ("forbruger-")samfund, hvem det kan komme til at gå ud over, og, også rimeligt vigtigt, hvorfor det egentligt ikke behøver at gå ud over de rige som sådan (og hertil hører også en lille idé om, at man kan slå to fluer med ét smæk og gøre idéen mere attraktiv for de rige, og forhindre, at boligmarkedet eksploderer i fremtiden, når bevægelsen har slået rod og de velhavende naturligvis vil begynde at lede efter steder, hvor de alligevel kan få deres penge til at yngle..) (For hele pointen med idéen er jo netop, at man når til et ret lige samfund, hvor der stadig er masser af plads til rigdom, men hvor rigdom i sig selv ikke bare kan yngle; hvis rige mennesker skal gøre sig selv rigere, skal de gøre dette ved at bruge deres (eventuelle) talenter til at forbedre samfundet, i.e. de skal gøre et stykke arbejde (medmindre selvfølgelig, de har haft held med at lave og opretholde en privat virksomhed, der ikke følger princippet i min forretningsidé, for sådanne skal bestemt ikke forbydes --- der skal jo ikke laves nogen som helst nye regler/love i samfundet i princippet i forbindelse med min forretningsidé).) (18:18) ..Og så vil jeg så forklare, hvad jeg lige har nævnt ovenfor under den relevante sektion, nemlig at man kun i visse tilfælde kan forvente, at der kan blive en stor investeringsdrøm i det, og at én (vigtig) mulighed her lige præcis er (nogen af) mine web-idéer, fordi sådanne virkeligt kan have gavn af, at brugerne har magten (og ved at brugerne af systemerne altid vil have dette). Og det vil jeg altså så nok slutte af med at referere til, og så må jeg jo se, hvornår jeg så får skrevet om de emner efterfølgende.. (18:26) 


(11:59, 19.10.22) Okay, der er ændringer i mine planer. Min fysikartikel ser faktisk næsten ud til at være lidt et flop muligvis.. Jeg skal lige have overvejet alle tingene og læst godt op på literaturen, men ja, der er altså muligvis ikke så meget nyt i den. Mine nye planer er så, at jeg skriver et samlet dokument om lidt af hvert: min forretningsidé, e-demokrati, og nogle af mine web-idéer/forudsigelser, samt også om eksistensteori, og så regner jeg med at gøre den samlede overskrift til noget a la "idéer og forudsigelser..".. Hm, eller jeg har også tænkt bare "En lys fremtid".. Men ja, pointen er: Jeg har nogle forudsigelser om den nære og fjerne fremtid, som fortæller, at denne er rigtig lys (og så har jeg også lige nogle eksistensbetragtninger, som gør det hele endnu mere lyst at tænke på). Så altså en meget positiv tekst om den nære fremtid (og idéer til at gøre denne bedre), om den fjerne fremtid også (og det vil jeg i øvrigt også skrive lidt om (at vi nok får et godt post-scarcity-samfund på et tidspunkt)), samt også hvorfor vi sagtens kan gå at glæde os over en lys fjern fremtid, også selvom vi ikke selv kommer til at leve iden (hvor vi altså snakker mine eksistensteori-betragtninger). Det vil jeg altså gå i gang med nu, og så vil jeg prøve også at arbejde lidt på at reparere min fysik-artikel om aftenerne. (12:07)   




## Diverse tilføjelser her i starten af 2023 (muligvis afrundig på dokument)

(04.01.23, 16:36) Okay, jeg har lige fået ig en ny computer, efter at min forhenværende gik i stykker i julen, og har lige fået installeret Linux. Her under nytårsræset (nærmere bestemt natten til d. 31.) fik jeg tænkt lidt over Eksistens igen, og det har jeg også brugt de følgende dage på indtil nu, imens jeg ikke havde en funktionel computer. Jeg har et par nye tanker om emnet, og har også en nogenlunde idé til, hvordan jeg ville strukturere en lille artikel om det. Det vil jeg derfor lige skrive om ovenfor i 'Eksistens'-sektionen, efter (..uh ha, det er et lidt drilsk tastatur, fordi man godt kan trykke ned på siden af en tast uden at den registrerer et ryk.. he, meget passende: jeg skulle have skrevet 'tryk'..) at jeg har skrevet denne sektion. 

Jeg kan starte med at skrive, at selvom jeg tror på at mine idéer omkring tag-ratings, kommentarkategorier, fanetræer og alt det omkring en web 2.0--3.0-side virkeligt indeholder et kæmpe potentiale (også rent forretningsmæssigt), så er det altså ikke sikkert, at de idéer bare sådan lige vil føre et semantisk web med sig med det samme.. Måske vil det hjælpe, at folk bliver vent til at diskutere i træer/diskussionsgrafer, når det kommer til kommentarer, men det kommer nok ikke til at accelerere overgangen til en videns-/diskussionsgraf (med sandsynligheder på, altså en "p-ontologi," som jeg før har kaldt det) super meget. Det tror jeg til gengæld nu mere mine debatside-idéer vil. Og også mine e-demokrati-applikations-idéer. For e-demokrati-idéerne kommer jo måske nok til at give incitamenter til folk om at deltage i (graf-)diskussionerne, og mine debatside idéer vil i øvrigt også åbne op for, at folk vil være meget mere villige til at lytte til hinanden på tværs af grupper, nemlig fordi man gør det til en udfordring: "Hvis du tror denne anden gruppe er helt henne i vejret, hvorfor så ikke bevise det via en grundig diskussion med en saglig og upartisk 'dommer' (eller flere) for diskussionerne?" Så det tror jeg altså mere kunne være dét, der kan sætte skub i den udvikling. 

Nå ja, og så kan jeg også sige, at jeg i går eller i forgårs kom til at tænke på, at (semantisk struktureret) NLP måske kan gå hen at blive en virkelig vigtig kilde til, at vi en dag får videnskabet semantisk struktureret (hvad ville være SÅ (SSSÅÅ!!) godt), hvis nu ikke semantic web-løsninger når at komme inden om først og tilveje bringe den realitet på en mere direkte måde (altså mere via menneskeligt arbejde frem for hjælp fra en A.I.). For når først den tekologi bliver udviklet tilstrækkeligt, hvad den sikkert gør i en ikke alt for fjern fremtid, så vil man ret nemt kunne opnå et kæmpe spring fremad simpelthen ved at få en A.I. til at lave et stort forarbejde med at analysere al eksisterende videnskabeligt arbejde og fylde det ind i en stor semantisk struktureret graf. Og når først man så har sådan en graf, så kan man derfra ved hjælp af menneskearbejde og v.h.a. yderligere forbedriger af A.I.'en (og altså ikke mindst ved en synergisk sammenblanding af disse) relativt nemt få udbygget denne store graf, så man får struktureret al viden semantisk. Så NLP-teknologien kan altså sagtens komme til, hvis ikke sem-web-løsninger kommer indenom først, at blive utroligt vigtige for den samlede videnskab (og dermed hele vores teknologiske udvikling). Og det virker som om, at den allerede er godt på rette spor, for der tænkes vist allerede godt i, hvordan man kan gøre NLP-algoritmer mere semantisk funderet (hvilket jo er klart, for så må man jo i sidste ende ende ud med et mere "intelligent" produkt). Så lad mig da endeligt huske mig selv på at følge noget mere med i den (spændende) udvikling. 

Udover min e-demokrati- og debatside-idéer, som jeg på et tidspunkt vil prøve at iværksætte (er planen), så har jeg altså nogle forskellige politiske og økonomiske idéer. Nå ja, og én af de politiske idéer handler jo så om at bruge en e-demokrati-app, nemlig til at lave et e-demokrati-parti.. ..Hm, jeg skal forresten nævne, at man også kunne forestille sig e-demokrati-appen mere som et socialt medie, hvorved altså alle personer og grupper altså enten direkte eller inddirekte har adgang til hinanden, og mere eller mindre deltager i det samme "digitale rum," kan man kalde det, når de bruger appen. Og så kan alle mulige befolkningsgrupper, og alle andre typer grupper (hvis ikke befolkningsgrupper er et altomfattende udtryk), altså finde sammen på appen og diskutere og forhadle med alle andre grupper på mediet. ..Og ja, så tænker jeg altså også, at man kunne blande appen sammen med debat-appen, således at e-demokrati-grupperne også kan oprette diskussioner/debatter med hindanden ovre i det andet ben af appen, der så altså er "debatside"-delen. (17:18)

Men ja, og udover disse ting, så har jeg altså mine idéer til nye typer af forbrugerforeninger (som forklaret i mit nye dokument ('consumer unions.pdf')) og mine idéer omkring "share-redistributing companies," hvilke jeg begge tror kan blive virkeligt store, ja, og sådan set ligefrem neutralisere alt (ikke ALT, men ~alt) hvad der er skidt i den nuværende udgave af kapitalismen, således at vi kan få en meget bedre form for det. Så planen er altså, at jeg vil prøve at diskutere SRC, CU, og.. EDP (e-demokrati-parti) med andre politik-interesserede, og så prøve at fokusere mit ejet faglige arbejde i retning mod at kunne iværksætte ED- og debatside-app --- bl.a. faktisk også ved simpelthen at læse open source kodebaser i min fritid (når jeg får sådan en igen). (17:25)

Hm, var der mere jeg skulle sige her (som ikke omhandler Eksistens)..? Der ver lige en lille ting, og det er bare, at jeg lige tænkte på igen, at hvis man som befolkning skulle åbne mere op for overvågning, så skulle det være via personlige kamerare, som alle folk helt selv er frie (ikke bare lovligt men også fysisk) til at slå fra og til, hvornår det skal være, og hvor det alt sammen sendes til datacentre, som er offentligt overvåget via kamerarer og lydoptagelser --- og digitale diagnosticeringer --- hvor man så bare altså har alt indholdet krypteret hele vejen, også hvis nu det skal bruges af ejeren og altså dermed sendes tilbage igen.. Men ja, jeg har sikkert sagt (skrevet) noget tilsvarende en gang.. ..Men jeg kom fra: var der andet, jeg skulle skrive her..? 

..Det tror jeg ikke, og ellers vil jeg bare lige vende tilbage. Så nu vil jeg altså skrive nogle tilføjelser til Eksistens ovenfor. Derefter vil jeg gå i gang med at se på at skrive (/ om jeg skal skrive) min SRC-artikel om og/eller skrive en ny version. Samtidigt med dette vil jeg så også tage kontakt til flere omkring det, og her tænker jeg så særligt på en vis tænketank, jeg er blevet fortalt om: Demokratisk Erhverv. Og når jeg så endelig når til et holdt/en pause i det, så vil jeg faktisk se på at få skrevet en Eksistens-artikel. Og ja, derefter snakker vi så at arbejde mig frem mod at kunne realisere mine e-demokrati- og debatside-idéer. Nå jo, jeg skulle forresten også nævne, at min wiki-idé nok heller ikke i sig selv bliver sindsygt accelererende for sem-web-udviklingen, mener jeg nu, selvom den nok dog vil kunne blive en rigtig god ting med tiden. Og lad mig så lige påpege, hvis det giver mening, at det nok er for meget at håbe på, at en videnskabelig semantisk ontologi vil kunne indeholde de helt grundlæggende argumenter til at starte med. I stedet bør man nok huske kun at sigte efter i starten, at den bare kan indeholde samlede videnskabelige værker som dens grundsten, hvilke så godt nok dog kan få noget semantisk data omkring sig om, hvad de siger, men som man dog altså ikke kan forvente skal splittes ad til atomer i den semantiske struktur. Jeg håber, det giver mening.. ..Man må altså forvente, at videnskabelige værker, der belyser et emne, må indgå so mere eller mindre atomare grundsten i den videnskabelige ontologi/semantiske graf til at starte med, og så er det nok først på meget længere sigt --- medmindre NLP-/AI-teknologien virkeligt kommer til at sparke røv på det punkt ---  at man kan forvente at disse værker i sig selv bliver splittet ad til semantiske atomer. ..Og når vi f.eks. særligt snakker e-demokrati-og-debatside-diskussioner, så må man også i høj grad forvente, at folk skal gøre brug af tredjepartsinstanser (altså forskere/forskergrupper, tænketanker, fagfolk, eksperter, ordfører, osv.) og hvad de siger/skriver om en ting, mere end at man skal forvente at hver del af alle disse analyser også bliver uploadet til mediet og behandlet online af brugerne (og analyseret semantisk). Selvfølgelig er det sundt jo mere der kommer online og bliver behandlet der, nemlig således at alle kan få indblik i detaljerne, og så der altså er høj gennemsigtighed, og så det er nemt at finde og udpege fejlslutninger m.m., men i sidste ende må man altså nok regne med, at dette ikke er muligt, og at man er nødt til bare at inkludere værker og udsagn fra andre som grundlæggende, atomart materiale for diskussionerne, uden at dette materiale bliver taget ind og splittet ad (og analyseret) på selve siden/i selve appen. (17:52)

..Men ja, nu fik jeg vist skrevet alt, hvad jeg ville sige, lige inden jeg kom med den sidste tangent her, så jeg kan vist bare afslutte her.:) Det er altså planerne, som de er nu, og for det første vil jeg altså så lige prøve at tilføje nogle ting om Eksistens ovenfor. (17:54, 04.01.23)


\end{comment}




































































%
%
%
%\chapter{E-democracies} \label{E_democracies}
%
%The concept of a so-called `e-democracy' is not a new one. Wikipedia thus has (in the moment of writing) a whole article about the overall concept that one can read. (That article, in its current form, defines the concept perhaps a bit more abstractly than what we need for our purposes here, but it might still be helpful to glance at.) In this section, I will therefore not introduce the overall concept, but simply give some short notes on how one might implement such an e-democracy, which can for instance be used to govern a company like the ones described in the previous chapter (as its shareholders), or a political party, etc. 
%
%
%\section{A basic digital application where voters can build proposition graphs}
%
%Imagine a digital application where all voters in a given democracy (concerning e.g.\ a company, a union, a political party, etc.) can log on and build a proposition graph together, which can then define the policies of the body governed by the given democracy. We are here talking about the `graphs' of mathematical graph theory. (One can make a brief search the internet for `graph theory' to see what this is about, and one might then also want to search for `directed graphs' and `connected graphs' at the same time.) 
%
%Each node of the graph holds a proposition, which is simply expressed in plain text of whatever natural language (such as English) is appropriate for the case. 
%
%When adding a new node to the graph, one can add it by itself (i.e.\ not connected to any other nodes) or add it with at least one of two kinds of (directed) edges to an existing node. The two types of edges then represents whether the node's proposition is an elaboration on the parent node, or if it is a self-contained proposition that should, however, only apply conditioned on the parent node being active.
%
%A node becomes active if it has enough votes and if a majority of those votes are positive rather than negative. Whether `votes' are counted simply by number (such that all voters have equal power) or if the votes are weighted (meaning that some voters have more power than others) of course depends on the case. 
%
%The point of being able to `elaborate' the proposition nodes rather than having to replace it with a more detailed note instead is simply to make the work easier for everyone, and also to make the graphs easier to read. It means that the policies can be defined somewhat loosely at first (and therefore much more quickly and easily), and whenever some vagueness of the propositions is discovered subsequently, either by people studying them or because of a relevant case that reveals it, the voters can then work to specify and mend the propositions. 
%
%The point of being able to add proposition nodes that are conditional on their parent nodes being active is of course some propositions might only be beneficial to implement given that certain other ones are already in place. If a somewhat fundamental proposition node is voted inactive again, it is thus convenient that such `conditional child nodes' follow along. If the parent node is then voted active once again (or perhaps for the first time) at a later time, all the child notes that has retained a positive voting score in the meantime will then become active one again, as well as any child node whose score has become positive in that time. 
%
%The application might also allow these `conditional child notes' to have several parent nodes for convenience. 
%And the same could also apply for the `elaboration child nodes' since there might be case where it could be beneficial to be able to elaborate the interpretation when two propositions nodes are active at the same time, for instance if these two proposition have a slight conflict with each other, or if the create some other issue that needs to be handled when they are both active together.
%
%`Elaboration child nodes' should of course also depend on their parents being active. The difference between a `conditional child node' and an `elaboration child node' is therefore essentially only in the interpretation: The propositions of `conditional child notes' and those of their parents are meant to be independent of each other as statements, whereas `elaboration child nodes' are free to correct and override parts of the statements contained in their parent nodes, thus allowing these to not necessarily be absolutely precise and self-contained. 
%
%Every user should be able to add new proposition nodes and each node should also have a separate `interest score' that users can rate (with the same weights on the votes as for the first score in the case where these are weighted). A proposition node whose `interest score' exceeds a certain threshold becomes visible to all users in the main graph, and people will then have to give their votes to it, if they want to influence whether it is applied or not. 
%
%Users should thus also be able to view nodes in the graph that has not yet exceeded said threshold, perhaps by being able to select various ranges of interest scores to look at. It might also be beneficial to let such nodes expire after a certain time if their `interest score' has been low enough for too long. 
%
%Users should also preferably have their own `workbench' with enough storage capacity to hold a number of propositions nodes. If a proposition node expires, they can thus make sure that the work is not lost as long as they keep said proposition on their own `workbench.' It would probably be beneficial also if users could then have shared `workbenches' as well, where they can collaborate on making new proposition nodes. 
%
%Anonymity is of course generally very important for democracies. So it is naturally very important that no one can see which user has added what nodes, unless of course they have collaborated on it from the same `workbench.' Users should also not (for most cases of democracies) be able to see which users has voted for what. 
%%
%For cases with weighted voting, either with very few voters or with very precise weights, this might be helped further by making sure that the exact voting scores are not visible to the users, and that the can thus only see a number that is rounded to a less precise floating point number. One might also implement intervals such that new votes are always declared together in groups, some time after they have been cast individually. 
%
%
%\section{How the proposition graphs are used to govern a body}
%
%The point of building these proposition graphs is then that the leadership of the body you are governing should to some extent be required to follow the active propositions, at least within some basic limitations of they can be required to do. 
%
%When the proposition graph changes, they leadership should be required to implement these, but here it might of course be a good idea to implement some delays on when new changes are supposed to be carried out. One might thus rule that a change should only be implemented after a certain period from when happened, and only if that change has remained active in the proposition graph during that period. 
%
%If the proposition graph gets some contradictions and/or ambiguities that makes it hard for the leadership to know what to do, they should also be allowed to postpone implementing the relevant changes until the voters sorts out the issues (by which they make some new changes which restarts the acceptance process). 
%
%How to make sure that the leadership follows the democratic decisions of the proposition graph? Well, by making sure that the voters also have enough direct power over the governed body to enforce their will. This might typically be ensured by the group of voters having the power to fire leaderships and/or decrease or increase salaries, thus giving this group ``sticks'' and potentially ``carrots'' that they can use to make sure that the hired leadership does what it is supposed to.
%
%
%It has to be mentioned that a high level of transparency is an all-important part of an effective e-democracy when it comes to the body that is being governed. Luckily, one can say that as long as the voters have the aforementioned ``carrots'' and ``sticks'' at their disposal, they should at least be able to make the body more and more transparent, even if it not very much so from the beginning.
%
%
%
%%Husk:
%	% Fortolkningspolitikker (inkl. hvad man gør, hvis der er modstride) og delays. (tjek)
%	% The point with having conditional propositions.. (tjek)
%
%
%\section{A more advanced application}
%
%A basic system like the one described above is good enough for very simple cases where it is okay to just have a majority rule. But for more complex cases where there are a lot of groupings of voters with different interests when it comes to various topics, to have such a majority rule is not really sufficient. If we for instance think of the policies of a whole country, this is a good example of such a complex case, where most people probably have \emph{some} special interests that are only shared with a fraction of the society. In such a system, it is important for people to be able to \emph{negotiate} with their voting power in order to get what they want, not just to always vote for exactly what they want as individuals. One group might thus want to meet with another to make a deal where they say: ``If you vote for this and this, even though you might not be particularly interested in that, we will vote for this and this which you do have a particular interest in (even though we might not).'' 
%
%In order to accommodate these realistic needs of its users, the digital application in question should therefore also first of all make it possible for users to form groups in the system. On a technical note, having such groups can of course be implemented in a lot of ways, but I can suggest an implementation where the creators of a group start out with some divisible `moderation tokens' that give them power to decide who can join the group and who gets kicked out, and where they are then free to transfer parts of (or all of) these tokens to other users within the group at any time. This moderation system is open enough that the users can implement any other moderation system on top of this, if only they trust some central party (which can then control a user profile in the system) to enforce the results of this external moderation system.
%
%And in order for such groups to be able to start negotiating with their voting power, it is then first of all important that some overall statistics (perhaps where numbers are rounded to ones with less precision for the sake of anonymity) of how a group votes on average is made public at all times. Otherwise a group who has made a deal with another group would not be able to check that this other group holds its promises. 
%
%With this addition to the application, groups can now in principle make all the deals in private that they want to. But of course, a good implementation of an `e-democracy application' would also afford its users with ways to make these deals within the digital application, online. 
%A way to do this might be to add what we could call `conditional votes' to the system. A `conditional vote' is then a vote on a proposition, whose sign can depend on other factors. In particular, a conditional vote should be able to depend on parameters regarding the voting statistics of groups. A group that want to make a deal with another one can then decide to make a conditional vote for something the other group wants and then make the condition such that this latter group has to vote for something the former group wants to unlock the conditional votes. 
%
%On another technical note: Depending on how the system is implemented, such conditional votes might be able to cause deadlocks, where two or more conditional votes all wait for the other to turn the other way in order to turn themselves. But a way to mitigate this is to give a direction to all conditional votes which denotes the sign expected from a successful deal. The system can then continuously refresh the proposition graph by turning all conditional votes in their positive direction and then see if they fall back to the same state or if they settle on a new state, which will mean that some deadlock has been conquered. 
%
%And on a design-related note: The conditional votes can be visualized/rendered as leaves in the graphs, each one attached to a certain proposition node. The users can then create and add these `conditional vote nodes' to the system in the same way as proposition nodes are added, and then all users can decide to cast their vote for the given proposition either by casting it (unconditionally) on the proposition itself or casting it instead on one of the conditional vote nodes (meaning that their vote will now be automatically conditioned on some parameters of the voting statistics in the system, continuously, until they change their vote again). 
%
%%Another thing that a more advanced system might account for, is the fact that the power of the voters might not just have different weights but might also be dependent the area that a given proposition deals with. This could for instance be in a company or a government where there are many departments/ministries in charge of different areas. If such a company/government decided to go for a more democratic leadership, it might still want to keep some division of power within the democracy. This example is perhaps not the most realistic one so here is one that is more so:  
%
%
%Another very important thing that an advanced application should afford its users is to make sure that the voters can choose representatives. It might seem odd to want to implement a direct democracy only for people to end up choosing representatives once again, but is indeed exactly what a direct democracy should aim for. It is nowhere near feasible if the system requires all users to engage in all discussions and decision making in order for the democracy to work, not unless we have a simple case with relatively few voters who are all quite engaged. But in most cases that one could think of, being able to choose representatives and trust these with looking into specific and/or complicated matters and vote on the person's behalf is all-important. The problem with representative democracies that a direct democracy aims to fix should thus not be to get rid of representatives, but simply to ensure that people can change these much more rapidly should they want to, and also that any voter can always choose to look into specific matters themselves and choose to vote differently on those than how their representative has voted.
%
%An advanced e-democracy application should therefore also allow users to choose representatives. With `conditional votes' implemented, users can of course in principle just cast conditional votes on all propositions that they want representatives to decide for them, but this is too cumbersome and we can do much better than that. The application could thus first of all allow the voters to give their votes to others. But it is likely that some users will only trust a certain representative to decide for them in a certain area of concern. And in general, users will therefore probably want to be able to have multiple representatives at a time, each responsible for making decisions for the voters in specific areas. 
%
%I therefore propose that an advanced e-democracy application also implement what we could simply call `areas of concern,' which are then essentially groupings of propositions regarding a certain subject. Whenever a new proposition is added by itself (as what we could think of as the ``root'' of a connected graph) it should thus be given an area of concern such that the application can group it with proposition graphs with the same area of concern. And whenever a child node is added, it should of course get the same area of concern as its parent. With this implemented, users should then be able to give their votes to another user (i.e.\ representatives) when it comes to any specific area, which should then effectively mean that the user will automatically cast the same vote as their representative, at least when it comes to propositions that the user has not voted on themselves. (And one might then implement different settings to this, such that a user for instance might be able to even let a representative override the user's own previous votes.) 
%%(If someone creates an otherwise relevant proposition node but adds the wrong area of concern, one can expect that it will then simply not be voted forth (over the aforementioned threshold), not until the author gives it the right area of concern.)
%
%It now almost goes without saying that each `group' in the system can then potentially choose to have their own specific representatives that the members are recommended (or perhaps required in some special instances) to use. 
%
%The system might also implement `subareas,' such that any user can try to add one such to any proposition node. Users should then be able to vote such subareas in and out, and if one is voted in, the proposition node and all its children will then get this extra area, that users can then also choose to sign representatives to. With these `subareas' implemented, this then allows users to delegate different representatives to these, even if they are also part of the same overall area of concern. **(This paragraph will probably need some rephrasing.)
%%(One could also implement `subareas' simply by requiring that these are also added from the beginning when the relevant proposition nodes are created, but it might make it easier for the users if they can just change the subareas by vote at any later time (instead of having to recreate and substitute the whole subgraph, with similar nodes but with updated subareas).)
%
%
%%These `areas of concern' also allows for something else that might be very useful, namely that the same community of users/voters can govern a variety of bodies with the same overall (potentially disconnected) proposition graph. 
%%Because when the contracts and/or agreements concerning the various bodies' commitment to follow the proposition graph are external to the digital system, a body might as well agree to only be ruled ...
%%The usefulness in this, apart from maybe having everything gathered in one place, is that this will mean that voters
%%(16:06, 06.11.22) Hm, dette kan nok godt blive mere kompliceret, fordi flere foreninger så skal blive enige om, hvordan stemmerne fordeler sig, og så skal det lige pludseligt topstyres på en helt anden måde.. Så lad mig lige se en gang... ..Hm, men handler det så ikke bare om, at forskellige grupper skal kunne "genbruge" de samme propositionsgrafer, og også om at de andre gruppers aktivitet så også godt må kunne gøres synlig i samme propositionsgraf (altså for en vis gruppe, der bruger denne)..? (16:09) ...(16:29) Jo, men så har det så ikke rigtigt så meget med subareas at gøre.. ..Nej, for så skal man også simpelthen gøre, så at graferne.. er helt adskilte, ja, så måske giver det altså slet ikke mening.. hm, andet end at man stadigvæk kunne have graferne side om side, og mere vigtigt, at conditional votes så også kan komme til at afhænge af eksterne grafer.. Ja, er det ikke bare det..?:) 
%
%
%%Furthermore, each group should have its own page and/or own `area of concern,' where the members of that group have all the voting power. This is useful since it means that each group can then build their own proposition graph over its policies and opinions. A group might then also signal external actions via this proposition graph. For instance, a group the represents a workers union might create conditional votes in their own proposition graph that depends on some statistics regarding the main proposition graph.. 
%%say that: ``On these
%
%
%And lastly, it might be beneficial for various groups in society who govern different bodies, e.g.\ political parties, unions, organizations, companies, to also be able to negotiate with each other online and to view each other's policies. For instance, a company might want to say to a governing political party that: ``if you implement certain laws, we will move out company elsewhere.'' And a trade union might then say to a company: ``if you do not give us higher salaries, we will go on strike.'' These are thus examples where a group in society can use their power over one body (including simply themselves as a group) to negotiate concessions from another group with power over a different body. 
%So if the advanced e-democracy application really wants to afford its users with all that they could want for negotiating effectively with each others, it should allow different voter groups to come together in the same space. First of all, each `group' in a e-democracy should have their own proposition graph that only they have voting power over. This local proposition graph can then be used to signal the groups policies, opinions and potential actions. And when it comes to the `conditional votes' in this local proposition graph, these should also be allowed to depend on statistical parameters in the main proposition graph, outside of the local one. 
%And furthermore, different e-democracies (governing over different bodies) that uses this same digital application should also be able to invite another group to join together, such that the two e-democracies can have their proposition graphs shown side by side (but with the same distribution of voting power in each of these graphs), and more importantly, that one e-democracy can then start making conditional votes that depends on statistics regarding the other e-democracy and vice versa. 
%
%
%\section{An e-democracy party}
%
%There are of course a lot of different examples where an e-democracy such as this could be useful; political parties, companies, unions, organizations and other communities. %In this section, I will, however, only give some points when it comes to political parties and companies of the type that I described in the previous chapter.
%%If we ..
%And when it comes to political parties, there is the natural option that these are run only by their members. We could thus imagine two or more parties competing for power, each being run e-democratically by its members. But since politically parties are typically inclusive anyway, why not just strive to have one political party where every person in the society gets an equal vote? 
%
%I believe that such a party could gain massive support over time. It might start out as a small party, especially in the early days where people are still getting used to working with the proposition graphs, and when the technology is perhaps at an early stage. And then as the technology to matures and the userbase grows, more and more people would trust the new system enough that they would want to give their vote to this `e-democracy party.' That party might then, at least in multi-party systems, get some representatives in government and by that point, the interest in the party would grow further, since all registered users would then be able to have a say in the policies of those representatives. And if the technology works, more and more people would then see the potential in an e-democracy. This is especially true in countries where the people in general do not always feel heard by there politicians: When they then see that the resulting proposition graph for most people will fit their interest better than what the traditional political parties offer, they will want for the e-democracy party to be voted in as a ruling party. 
%
%Now, if the party thus lets member of society have an equal vote in it, this might then be problematic at this stage when the party want to take over from the traditional parties, since people might then be tempted to make their vote count twice, essentially, by voting for their favorite traditional party and then also using their vote in the e-democracy party. And since voting is anonymous, there is no real way that the e-democracy party stop this. That is, apart from taking steps to balance out this effect. The e-democracy party might thus choose to temporarily break its commitment to giving all people an equal vote in this phase, and instead promise that it will commit itself to try to counter all representatives in government that are not part of the e-democracy party by giving more votes internally to a group of representatives whom it deems are exactly at the mirrored end of the spectrum than the group of non-e-democracy representatives in government. (The chosen counter-group can, however, be much larger then the group of representatives it is supposed to counter.) This way, a voter who wants the e-democracy party to take over would not be tempted to cast their votes to a traditional party instead. It also means that once the party sits on a majority of the power in government, other representatives are more likely to join it while in power (if the relevant constitution permits such migrations of representatives while in power) if they see that the e-democracy is more practical since the e-democracy party can then just remove the appropriate amount of counterbalance as these former outsiders join. 
%
%
%E-democracies as governments of countries might thus be a much closer reality in the near future, than a lot of literature on the topic seems to suggest, at least in countries governed by a multi-party system. In two- or one-party systems, the development might of course be much slower. But then again, once some multi-party governments successfully switches to an e-democracy, the two- and one-party governments would then be able to analyze and copy the technology, at least giving them a much easier route to an e-democracy, should their voters want one. 
%
%
%
%\section{Anonymity}
%
%
%As mentioned, anonymity is often very important for a democracy, especially if we think about the case of governing a country. Therefore, the digital application should allow the users to vote anonymously. This can be achieved letting each user control an anonymous profile, but if information about which user has which anonymous profile is stored on a server, that server might be hacked. 
%
%So the question is, can an e-democracy system be as safe and anonymous as going to a box, drawing a cross in a field on a piece of paper and putting that paper into a box? Yes, actually: there are ways to ensure complete anonymity of the users where the anonymity is preserved even if the servers of the application is hacked.
%
%The following protocol allows a set of clients to each provide a server with a set of public keys such that each client knows the private key of exactly one of the keys in the set (and no one else but them knows this private key) but where no one knows which public key belongs to which client apart from the clients knowing their own key. The protocol is furthermore resistant to DoS attacks. 
%
%It works by having the clients take turns building blocks in a block chain, which we can think of as a `block spiral,' where the clients form a circle and where the turn to provide a new block to the spiral goes around in the circle. 
%
%\ldots\ \textit{Okay, jeg tror lige, jeg venter med at forklare om min idé her, for det kan godt være, at der findes en lidt nemmere måde. Det vil jeg lige tænke over. Men ellers er det en god idé, altså den hvor hver klient sender nogle nøgler videre til en tilfældig anden klient i kredsen (hvor hver blok krypteres med den næste klients offentlige nøgle (fra begyndelsen) og sendes til denne), og hvor klienter, der modtager nøgler gerne skal sende dem videre og slette dem fra hukommelsen. Herved vil man meget sjællendt kunne se, hvem var den oprindelige sender af en nøgle (medmindre både modtagerklienten og klienterne for og bag brugeren er ondsindede), og selv hvis den bliver sporet tilbage kan pågældende klient bare sige, at ``den nøgle kom fra en tidligere omgang og altså fra en helt anden bruger, men jeg har altså slettet data om, hvor den kom fra, som jeg burde.'' Men ja, jeg tænker nu lige lidt mere over det, inden jeg skriver denne sektion færdig. .\,.\,Jeg har i øvrigt også tænkt mig at sige, at man efter at have brugt denne protokol så bare kan bruge et VPN herfra, men hvis man vil være endnu mere sikker, så kan man endda bruge helt den samme protokol til at indsende data om, hvordan man vil stemme med sin profil, hvor man så altså bare erstatter de (tilfældigt) genererede nøgler i protokollen med tilfældigt genereret data samt det faktiske data, man vil indsende, og til sidst så offentliggør man så bare, hvilket skrald, man har sendt ind, men ikke den faktisk data, man så lader serveren beholde. (.\,.\,Så kan det dog godt være, at man skal ændre protokollen lidt, så man lige sørger for, at hver mængde data også vil nå slutningen af protokollen, så at ingen data-klumper bliver tabt i protokollen --- medmindre der altså er sket en synlig fejl i protokollen.)}
%
%\ldots\ \textit{Nej, der er vist en nemmere protokol, hvor man vist nok også kan finde frem til en DoS attacker. Man kan vist bare have et VPN, hvor klienterne sender beskeder frem og tilbage, og hvor de så kan pakke en nøgle ind i flere krypteringer med forskellige nøgler, hvor beskeden så skal sendes til alle de klienter i rækkefølge, som kan dekryptere beskeden en efter en. Og hvis så man gør det tilfældigt, hvor mange krypteringer, der skal til, så kan ingen igen vide, om en nøgle kom fra en person, bare fordi de får opsnappet, at beskeden på et tidspunkt blev sendt fra denne, for vedkommende kunne jo sagtens have fået den fra andre og så bare have sendt den videre. Og hvis man så har nogle få DoS'ere i netværket, så kan brugere der har sendt en nøgle der aldrig nåede frem jo pege på, hvem der kan have været de skyldige (af den række af brugere).\,. Hm, ja, men hvis man nu vil bevise det også, så kunne disse brugere.\,. Nå nej, man kan ikke bevise det på et VPN, men det gør vist heller ikke noget. For brugere skal jo stadig gerne sende flere nøgler pr.\ protokol, og hvor de så bare opsiger alle på nær én til sidst. Og hvis der så er en DoS'er i netværket, jamen da det ikke vil være fatalt, så må det være fint nok, at brugerne bare kan page dem ud nogenlunde. (Og hvis det så bliver et større problem, så kan man altid bare bruge den mere krævende blok-spiral-protokol, jeg har haft tænkt på.)} %(08.11.22, 10:27)
%
%
%
%
%
%
%
%%Hm, jeg har fået tænkt lidt over anonymitet, men det kan godt være, at jeg lige skal tænke lidt mere. Men jeg har altså fundet på nogen fine systemer til at skjule stemmeres identitet, og jeg tænker, at stemmere generelt skal kunne vælge enhver tredjepartsbruger til at videreformidle deres stemme anonymt. Sådanne kunne så med fordel få lov at give floating point værdier (i stedet for bare 0 eller 1) med deres stemmer, eller de kunne bare råde over et antal stemmer, således at de både kan give et antal positive og et antal negative stemmer til hver proposition (men jeg tænker at det første næsten er nemmest..). Og ja, så kunne én form for sådan en tredjepart så være en organisation med fysiske lokationer, hvor medlemmerne så kan møde op personligt og ændre deres stemmer og/eller repræsentanter, og hvorved organisationen kan opdatere deres stemmer herefter med en frekvans, der kan afhænge af, hvor mange ændrer deres stemmer ad gangen over en gennemsnitlig periode. Og en anden, meget smartere;), måde at have en videreformidlingsrepræsentant på, kunne så også være.. hm, lad mig lige se.. (13:50) ...(14:30) (ordner også vask) Jo, man kan også have en videreformidlingsrepresentant, der fungerer via mindst to tredjeparter, som klienten selv kan vælge. Først er der en trejdpart, eller instans bør vi nok hellere kalde det, bare.. som via asymmetrisk krypering får en nøgle fra hver bruger, som kun denne instans og hver enkelt relevant bruger må kende. ..Ja, eller på nær at de også så skal sende alle disse nøgler til en anden instans, der heller ikke må offentliggøre dem, og som så i øvrigt ikke ved hvor hver enkelt nøgle stammer fra (og må ikke få dette af vide af første instans). ..Hm, vent, giver dette mening..? ..Ah, jo, jeg kan få det til at give mening, men lad mig nu lige se.. (14:36) ..Hm jo, denne instans nr. 2 kan så også få en offentlig nøgle med fra brugeren til hver enkelt nøgle af første instans, sådan at denne altså bare får et sæt af nøgle par, hvor den ene er en offentlig nøgle. Denne instans kan så kryptere.. Hov, nej, så behøver vi faktisk ikke den første nøgle; instans nr. 1 sender altså bare et sæt af offentlige nøgler videre (gennem en krypteret kanal) til instans nr. 2. Denne offentliggør aldrig disse, men bruger dem hver især til at kryptere en besked med en ny nøgle i, og offentliggør alle disse krypterede beskeder. Brugerne prøver så at dekryptere dem hver især, indtil de finder deres egen.. Hm, er dette får ressourcekrævende, eller skal denne instans også lige tilknytte et meget lille hash a hver offentlig nøgle med beskeden, så hver bruger ikke skal igennem så mange..? ..Det kunne man sige.. ..although.. ..Tjo, men brugerne kan så stadig downloade alle beskeder i rækkefølge og så bare nøjes med at beholde dem, de skal tjekke.. Hm, lad mig lige tænke, om ikke der er en smartere løsning.. ..Hm, men ellers var pointen så, at enhver bruger, som ikke får en passende besked, bør så anråbe dette, hvorefter alle nøgler så skal indgives, sådan så man kan finde ud af, hvilken part var synderen (inkl. anråberen, hvis dette var en fejl), hvorefter man så kan starte forfra, muligvis uden synderen. Men når hver bruger så har fået en ny nøgle, som kan kan spores hen til dem, hvis alle de involverede instanser (for man kan godt have flere nr.-2-instanser her) bryder deres løfter og offentliggør deres data (og ikke bare sletter det kort tid efter). Nu kan man så være sikker på, at alle brugere i gruppen har netop én anonym nøgle, som nu kan bruges til at oprette en anonym bruger profil for hver bruger, selvfølgelig med VPNs involveret, hvormed denne frit kan afgive sine stemmer og ændre dem, hvornår det skal være, uden at det kan spores tilbage til dem. (14:52) .. ..Og disse anonyme brugere kan så udløbe således at de skal opdateres en gang imellem, således at hvis nu nogen for lækket deres bruger, så vil det allerhøjest kun være den seneste aktivitet, der bliver lækket (og derudover kan man selvfølgelig også dele brugeren op i flere (der ikke kan kædes sammen af andre), hvis man synes, der er besværet værd, men ja, og sådan vil der selvfølgelig altid være ting, man kan tilføje, hvis man finder frem til, at det giver mening..). Nå, men selv hvis der findes et bedre system end dette, så kan jeg jo bare skrive, at det f.eks. ikke er svært at finde på systemer, hvor man via flere instanser, der hver især holder på sin del af en samlet hemmelighed (hvor alle stykker skal bruges, hvis man vil spore tilbage), kan opnå at hver bruger i en gruppe får netop én anonym bruger. Og ja, hvis man så sørger for at de udløber med jævne mellemrum.. Og at brugerne skifter.. Hm.. ..Hm, men det er nu ikke perfekt anonymitet, hvis man sammenligner med valg, hvor ingen data bliver gemt til at starte med, således at ingen nogensinde kan spore det tilbage.. Hm.. ..Hm, men kunne man ikke bare bruge en teknik, som jeg vist også har tænkt på før, hvor en instans bare offentliggør en mængde af.. Hm.. ..Hm jo, en mængde af dens egne offentlige nøgler, nemlig med et antal svarende til antallet af klient-deltagere i øvelsen, og hvor hver klient så vælger et hemmeligt ID, krypterer.. Hm, nej, lad mig lige se... ..Hm, hvad med at alle klienter bare opretter et VPN kun med demselv som noder, og så begynder at sende data rundt. På et tilfældigt tidspunkt sender hver bruger så et ID videre til en naboknude, som modtager, sender ID'et videre til én naboknude, og noterer også ID'et og modtagelsestidspunktet.. nej.. Hm, dette virker vist næsten, men ikke helt.. ..(15:21) Ah, nu har jeg det måske. Man kunne lave en kæde af krypterede blokke, hvor hver blok offentligt hører til en klient, og hver blok rummer data, som brugeren fik tilsendt af ejeren af den tidligere blok, og data som brugeren har sendt videre til næste klient. Denne blokkæde kører så på omgang i en ring, således at den tager flere runder. Og på et tilfældigt tidspunkt tilføjer hver bruger så et offentlig nøgle, som de sender videre. ..Hm, nej det er endnu ikke helt vandtæt.. ..Ah, men måske hvis man tilføjer sin nøgle i krypteret tilstand, så den først kan lukkes op, når den når til en (tilfældigt udvalgt) anden bruger.. Hm, spændende idé.. (15:27) ..Ja, man må næsten kunne lave sådan et system, hvor klienterne billedligt talt danner sådan en rundkreds, hvisker data videre til hinanden én ad gangen i rundkredsen, og hvor klienter i kredsen så kan kryptere en hemmelighed, som en klient et andet sted så kan forstå. Denne bør så med det samme kryptere en ny besked, hvormed denne hemmelighed kastes videre til en anden person. Hemmeligheden er så en offentlig krypteringsnøgle. Man slutter så, efter et vist tidspunkt, når man er næsten 100 \% sikker på, at alle brugere for længst vil have kastet deres nøgle ind i rundkredsen, og at denne er læst af modtageren. Alle brugere offentliggør så de nøgler, der har været sendt frem til dem. Herefter skal alle brugere/klienter (jeg kan ikke lade være med at skrive "brugere" i stedet for klienter, men det er vel også næsten ligeså godt..) så sige, om deres nøgle er iblandt de offentliggjorte (men selvfølgelig ikke udpege dem). Hvis antallet af nøgler passer og alle brugere/klienter siger, at deres er med i mængden, så stopper "legen" succesfuldt. ..Eller rettere, det gør den, efter at man så beder alle brugere om at slette de nøgler, de ville have brugt til at dekryptere deres egne blokke med. Og sikkerheden i systemet handler så om, at man har tillid til, at størstedelen af klienter vil gøre dette (selvfølgelig fordi de bare bruger det udleverede software til det, og ikke har bygget eller tilegnet sig en malicious kopi af denne software).. Men hvis der er for mange nølger, eller at en klient mangler en nøgle, jamen så må man så bede alle brugere om at dekryptere alle deres blokke. Og så er pointen, at man kun ved at have alle disse blokke dekrypteret, kan finde frem til, hvem der er synderen, fordi man så både vil kunne se, hvis de ikke har opfundet netop én nøgle selv, og fordi man kan se, hvis de ikke har videresendt den rette nøgle hver gang.. Nå ja, og hver bruger skal så også bare i det hele taget indsende deres private nølger, så man kan finde frem til synderen. Og hvis enten en klient nægter at indsende den private nølge i dette tilfælde, eller hvis man finder synderen ved at dekryptere alle nøglerne, så må man så udelukke denne bruger i næste tur (altså give denne karantæne). Men ja, som sagt, hvis legen derimod ender succesfuldt, så skal brugerne endeligt ikke offentliggøre deres private nøgler, nej faktisk skal de slette alle deres nøgler, der blev brugt under selve legen og kun beholde den private nøgle, som passer til den offentlige nøgle, de herved fik indsendt anonymt via legen. Og ja, så længe de fleste brugere bare gør dette, så er man ikke i fare for, at det bliver afsløret, hvilke nøgler i slutmængden hører til hvilke klienter. :) (15:53) ..(16:02) Hm, der er faktisk en lille smule hangman's paradox tilstede i denne løsning, men det kan man vist gøre bod på ved bare at sige, at hver knude.. Hm.. ..Hm, eller hvad i stedet med bare at gøre sådan, at klienter i kredsen generelt skal vente et tilfældigt antal omgange, inden.. hm, men det løser dog ikke problemet eksakt.. (16:07) ..Hm, men jo, man kunne vel også bare sørge for, at sandsynligheden for at ens software sender en nøgle starter virkeligt lille og kun vokser over mange runder, og så kunne man gøre sådan, at hvis en bruger bagefter kan se, at deres software har sendt.. Hov, vent, dette er da slet ikke et problem, netop fordi man kaster hemmeligheden frem i rækken.. hm.. ..Hm, der skal kun tre (specifikke) andre brugere til at afsløre en i denne løsning, men de kan det kun hvis man har været uheldig at softwaren har sendt ens nøgle tidligt.. ..Hm, man kunne også bare give hver bruger mulighed for at afbryde legen, hvis deres sofware har sendt deres nøgle tilstrækkeligt tidligt.. Hm.. ..Hm, i øvrigt kan man hurtiggøre processen, hvis kredesn har mange kæder i gang på én gang, så alle klienter kan bygge en blok i hver runde (nemlig hvis der er ligeså mange kæder i gang, osm der er klienter i kredsen).. ..Hm, men kan man ikke bare generere flere nølger, end der er behov for..? (16:18) ..Jo, og så kan brugerne/klienterne til sidst bare vælge, hvilken nøgle af dem, de har fået genereret i legen, de vil beholde, ved at.. Hm.. ..Ah, ved selvfølgelig bare at bekende offentligt bagefter, at "disse nølger var mine, men jeg skal ikke bruge dem alligevel."!:) Og hvis så der lige præcis bliver det samme antal efterfølgende, som der er klienter, og hvis alle meddeler, at de har en nøgle iblandt de endelige, så når man i mål, og ellers må man så bare til at optrævle kæden, for at finde DoS-synderen, hvis ikke legen ender som den burde. :) (16:25) Og ja, det skal så bare anbefales, at hver bruger ikke vælger en nøgle, der blev genereret helt i starten af systemet, men ved at det stadig er brugerens beslutning at udvælge den ønskede nøgle, så eliminerer man altså hangman's paradox.:) (16:26) ..Nå ja, og lad mig lige præcisere, at hver blok så skal indeholde en liste af krypterede nøgler (som hver er kryperet med en tilfældig andens offentlige nøgle), og denne lister vokser altså bare.. tja, eller man kan måske begynde at fjerne ting fra bunden af listen efter et vist stykke tid, når det er sikkert, at samme nøgle er blevet indsat igen i ny version (nemlig ved at en knude har dekrypteret og re-krypteret nøglen og sat den på). Og man kan så kræve, at hver knude tilføjer netop én ting til listen i hver runde.. how, "runde" er et dårligt term at bruge for hvert enkelt lille step, når vi har en rundkreds, så lad os kalde.. tja, lad os bare kalde det enten hver 'step'/'skridt' eller hver tur.. nej, lad os udelukkende kalde det 'skridt'/'step.' Og hvis en bruger så modtager flere beskeder på én gang i et step.. ..Hm, nej vi kan også godt kalde det turn i stedet (for så tænker man jo bare på et lille turn af hjulet).. Så må denne bruger så altså gerne vente en omgang med at sende nummer 2 besked (osv., hvis der modtages flere end to), og altså så kun videresende én af nøglerne i den første tur, hvor nøglerne modtages. Ok, så det var vist bare det, jeg lige skulle præcisere.. (16:40)
%
%%(16:42) Nå, men der er også et andet issue, jeg skal tænke over, og det handler om: Vil det ikke være for fristende for folk at stemme på deres vante repræsentanter i et regeringsvalg, hvor et e-demokrati kæmper, og ser ud til at kunne vinde? For hvis man gør dette, så vil man vel kunne få dobbelt magt, medmindre e-demokratiet kan se, hvem der ikke stemte på det.. hvad de jo ikke vil kunne.. Hm, måske er dette et ret stort problem, men ja, nu vil jeg altså give mig til at tænke godt over det... (16:44)
%
%%(31.10.22, 9:21) Kort efter, jeg klappede i i går kom jeg frem til, hvad vist også havde været oppe at vende i periferien af mine tanker tidligere på dagen, at den simple og måske eneste løsning nok bare er, at sørge for, at e-demokrati-partiet i starten også har til opgave at booste stemmevægte inde i systemet (på en helt transparant måde selvfølgelig), således, at alle repræsentanter, der ellers har fået mandater udover partiet, de får en modvægt til sig inde i partiet. På den måde kan det ikke betale sig at stemme uden for partiet for at pågældende mening skal få mere magt, for så vil den pågældende mening bare blive countered. Og ja, det er så partiets opgave at finde frem til og være ærlig omkring, hvad der er midten af det politiske spektrum i henhold til forskellige punkter, således at man kan counter'e et vist mandat ved at give mere magt til en (eller flere) fra den modsatte (i.e. spejlede) ende af spektrummet. Når partiet så er i regering, så kan man så også bede de repræsentanter, der ikke er med, om at joine, for så vil e-demokratiet bare fjerne magt igen fra dem, der står for at counter'e/udbalancere magtbalancen.. (9:29)
%
%
%%\section{A note on transparency}
%
%
%\section{E-democracies in companies}
%
%%To finish this chapter, let me just make a small point about how an e-democracy application like this might also be incredibly useful when it comes to democratically run companies, or indeed the almost-democratically run `Economically Sustainable' Companies (ESCs.\,. hm, that looks a lot like `Escape(s)'.\,.) that was described in Chapter \ref{MSE}. 
%%
%%If the company in question has a goal of expansion, such as should be the case for the 
%
%To finish this chapter, let me just make a small point about how an e-democracy application like this might also be incredibly useful when it comes to democratically run companies, or indeed the almost-democratically run `economically sustainable' companies that was described in Chapter \ref{MSE}. 
%
%If the company in question has a goal of expansion, such as should be the case in general for the `economically sustainable' companies as described, I envision that this venture will be all the more exciting for the participants if there is a vibrant online community that engages in discussing and finding what strategies to go ahead and try in order to expand the company. 
%
%And if this e-democracy application can be as useful a tool for this as I believe it can, it could thus accelerate the interest in taking part and supporting such a company immensely. 
%
%%Hm, skal jeg så bare stoppe her for nu? (Eller skal jeg skrive videre på denne sektion, og var der i øvrigt andet, jeg har glemt at nævne..?) (15:21) ..Hm, jeg har glemt at nævne min pointe omkring gennemsigtighed ved at sørge for, at folk med jævne mellemrum bliver udtaget til at sætte sig ind i detaljerne og så rapportere tilbage til den interessegruppe, der udvalgte vedkommende, men måske jeg bare skal gemme denne pointe til en anden gang.. (15:23)
%%...(16:01) Nej, jeg tror ikke, jeg behøver at tilføje mere nu. Når jeg så lige får tænkt lidt mere over spiral-protokollen, så kan jeg skrive om den, og ellers er det nok bare lige at redigere teksten. (16:02)
%
%
%
%%Husk:
%	%Jeg havde tænkt mig her at nævne det med, at det kan være smart at udvælge nogen (som så jo kan vælges til at være upartisk og/eller repræsentativ (men måske smart/intelligent nok)) fra en gruppe til at studere og gennemgå systemet i nærmere detaljer og så rapportere tilbage..
%	%Transparancy.
%	%
%	%You never have to waste a vote (and never have to fear wasting a vote). And never have to be fearful, that who you voted for does something you didn't expect (since this system requires no trust in representatives, at least not except in cases why you don't feel like you have the time (or interest) to go through the details of a matter).
%	%..(16:47, 29.10.22) Hm, og husk det her med at man kan have flere områder, hvor forskellige bestemmer, og at dette så også gør, at andre grupper kan logge sig på i systemet, hvor vi snakker om at styre et land. I et sådant e-demokrati kan grupper altså også tilføje områder. På den måde kan de gøre det offentligt for alle, hvad de har tænkt sig. Hermed kan vi altså få en stor markedsplads, der handler om at lave aftaler og bestemmelser, både i regeringen, men også i andre instanser (det kunne f.eks. være såsom fagforeninger, hvilket jo vil være meget relevant i den sammenhæng). ..Og ja, det kan også være grupper, der egentligt ikke har nogen anden magt over noget, men som alligevel vil oprette et område, der hedder "vi mener sådan og sådan, og vil vil gøre sådan og sådan," altså et område, hvor de kan signalerer til omverdnen, hvad deres interesser er, og hvad de gerne vil / er parate til at gøre. (16:54) ..Og ja, det kan så nævnes, at dette så også kan være sådan noget som at trække sig fra den overordnede gruppe (f.eks. e-regeringspartiet eller trække sig som kunde og/eller investor i et firma). 
%	%Jeg kunne godt nævne muligheden i "forbrugerforeninger" kort også (som et eksempel på anden form for magt), men så tilføje, at min kd.v.-idé så netop nok ville være endnu bedre her, for så kan man undgå sådanne reprimanter (eller hvordan det staves). Men om ikke andet kunne det så blive en måde at tvinge gang i en kd.v., hvis nu virksomhederne indenfor en branche er tøvende med det. 
%	%Jeg skal forresten huske at have område-repræsentanter med under avancerede punkter, sammen selvfølgelig med områderne selv. Jeg kan således nok godt nævne "områderne" først, også selvom det egentligt er vigtigere, det med at kunne vælge repræsentanter.. 
%	%"Det handler om at det bliver: meget lettere at samle sig i små grupper, og meget lettere at sætte i gang i en proces, hvor man overvejer, om ikke der kan gøres noget ved et forhold, netop fordi man bare kan starte denne diskussion i nogle små grupper (som så kan kontakte andre grupper, små eller store, når de har fået samlet en oversigt over, hvad problemet er, og hvad man kunne gøre for at løse det m.m.). Så altså langt større tilgængelighed for den enkelte og dermed mange mange flere mennesker aktiveret ad gangen (som så overvejer og finder på løsningsforslag til problemer i samfundet (ofte særlige problemer for nogen specifikke i samfundet, men det kan jo også være mere almene)). Og så vil der så derefter også kunne være meget kortere tid til, fra løsningsforslag til løsning i sådan et direkte demokrati, der er klart. Og ikke mindst vil folk (i grupper) få langt nemmere mulighed for at indgå selv komplicerede politiske aftaler med andre folk (i grupper (ikke nødvendigvis disjunkte med de første, btw)), således at man får et meget bedre og hurtigere kan få handlet sig til at få opfyldt sine behov som en gruppe af mennesker, og således at smafundet derfor vil blivet meget bedre fintunet, så at sige, til at opfylde så mange menneskers forskellige behov som muligt på en gang."
%	%(15:01, 01.11.22) Jeg skal huske noget, jeg lige fik tænkt på, og det er, at et sådant demokrati kan få en meget meget fladere struktur, hvor at man, når man har en ny idé til forandring, lad os sige som lille gruppe, i stedet for så at skulle indsende og ansøge om idéen til en central, så kunne man i første omgang dele den, med den/de mest relevante nabogruppe(r). Hvis de så også er med på den, så kunne man så brede det til endnu flere. Og når idéen så har samlet nok opbakning, så kan man melde det til det brede fællesskab, hvor idéen så allerede har opbakning, når den ansøges om. Jeg ved godt, at sådanne måder at fremføre idéer på allerede finder sted mange steder, men jeg tror, at man i et e-demokrati kunne gøre den fremgangsmåde endnu nemmere og endnu mere hyppig.. Hm, måske vil jeg skrive om dette, men om ikke andet er det da bare rart at tænke på, at der kunne blive sådan en rigtig flad struktur, hvor relaterede grupper selvstændigt kan diskutere og handle om, hvilke idéer og forslag, man vil gå videre med..:).. (15:08)
%	%Man kan også bruge min blok-spral-idé til når stemmerne skal kastes..!
%
%
%
%
%
%
%%(09.11.22, 9:46):
%\section{(I'm considering adding something like:) A similar application for scientific discussion}
%
%\textit{I have now realized that this application could also be used for scientific discussion graphs, which goes hand in hand with decision making since facts are of course important when deciding policies. In a discussion graph, on would just not really need the `conditional node' edges, but would instead just use the `conditional votes' instead --- which could then be drawn as edges between notes for this type of application. %(This all of a sudden make this idea quite a bit more interesting for me in terms of what I would like to work on myself.\,. .\,.\,Hm, hvilket er relevant for mig at have i tankerne i denne stund, for jeg skal nemlig snart til jobsøgeningsmøde med A-kassen. Og ja, med denne indsigt, så må det da næsten være denne idé, jeg vil prøve at gå videre med (og sige jeg vil iværksætte), det tænker jeg.. (..Altså i stedet for Web 2.0--3.0-idéen/erne.))
%*And it should then be very much recommended (as a key part of the idea), that users try to commit themselves to continuously update their votes for propositions as conditional ones, once more fundamental propositions are added to the system. A scientist might for instance be an expert on drugs and say (or actually ``vote'') that: ``this drug is so and so addictive,'' but then once propositions are added about the existence of relevant studies are added, as well as propositions about trust, then that scientist (along with everyone) are then strongly recommended to change the vote into a conditional vote such that the vote now depends on the study existence proposition and the trust proposition. This way (if the community follows this (strong) recommendation), every proposition can slowly become more and more founded in the basis empirical propositions/data, plus trust propositions (which are essentially propositions about how the users want to apply epistemology, i.e.\ when these propositions are also boiled down to their roots). This both has the advantage of the system being more flexible, when new studies turn up or if old ones come into question at some point, and also, importantly, it makes it easier to browse and find out what fundamental facts our more abstract facts in society are built on, i.e.\ to find the sources, and it also gives a better and easier understanding of what is interesting to research, since it shows were the ``gaps'' are, so to speak, or more precisely: where the research is thin and could use bolstering. 
%}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%%\chapter{A possible road towards Web 3.0}
%%
%%
%%**(Lad mig bare lige skrive, hvad jeg tænker nu at skrive i dette afsnit/kapitel bare ud i én køre, og så kan jeg altid redigere bagefter..) %(06.11.22, 9:46) (Jeg fik nemlig lige tænkt en del over emnet igen i går aftes, og nu synes jeg alligevel, at jeg bør kunne forklare meget af det ret kortfattet..:))
%%*(Okay, jeg har alligevel ikke tænkt mig at beholde dette kapitel, men lad mig bare lige skrive denne køre færdig, også fordi jeg har nogle små nye gode tilføjelser, mener jeg..)
%%
%%
%%\section{Everything section}
%%
%%
%%My idea for how we can reach the promises of Web 3.0, and specifically the Semantic Web, is to first implement a Web 2.0 site with an underlying semantic structure and then really try to give the users a lot of power to redesign things on the site and to program algorithms themselves. This implementation of the Semantic Web then does \emph{not} rely on XML/HTML. Instead, all semantic sentences should be recorded in relational database. 
%%
%%This is radically different from the first implementations of the Semantic Web, where metadata is simply added to various sites and resources on the web, and then algorithms in the Semantic Web would simply work by querying the web (i.e.\ the World Wide Web) and finding the necessary information online. But when all the semantic sentences (what is also called triplets in the current conventional implementations) are stored in one database, the algorithms can run way faster. 
%%
%%Essentially, one can say that the idea is to start out with a Web 2.0 site as we know them, e.g.\ such as YouTube, Reddit, Twitter, etc., and then implement the Semantic Web there. But hold on, you might say, it can hardly be called the Semantic \emph{Web}, if it is controlled by a private company. No, but if it is instead controlled by a open source organization (similar to how the web is run today, e.g.) it is another matter. Hereby it can be ensured that no one owns all the user contribution, save perhaps for the relevant user, and that any other organization can always come and take up the mantle at any time, should it be needed (just how it also is with Wikipedia).
%%
%%Alternatively, if starting this idea as a non-profit organization is slow and lacks investment, one could also start it as the type of company as described in Chapter \ref{MSE}, such that the ``organization'' can start out as a private, commercial company, but where it is guaranteed that the users will slowly become the owners. 
%%
%%But let us move on from this topic for now and assume that the organization will have plenty of funding (just like Wikipedia has). 
%%
%%
%%Let me now try to explain the overall design of a Web 2.0 site that I envision, which has an underlying semantic structure. Some of the details here are more important than others (and some are less), but it is nice to see a good example that could work (and attract many users), and then from there, I can explain why the underlying semantic structure becomes important. 
%%
%%If I were to design such a Web 2.0 site, where the intention is that it can grow into a Web 3.0 site over time, I would probably give it this following initial design:
%%
%%A main feature of the site should be a page with a category tree, which I would implement basically as a structure of tabs, i.e.\ the kind of tab system we see everywhere in the interfaces of Windows and Mac applications and so on. Whenever a new tab is selected, it will then potentially open a new list of sub-tabs. The user might thus have selected the category `movies' as a tab, and then a submenu of movie categories should open. Thus, we get a category tree (which hopefully should be pretty quick and easy to navigate as a user). Whenever a new list of (sub-)tabs is in focus, it should be expanded as a whole box of selection, in fact one might even implement it as a whole HTML page at some point (instead of just a box containing a lot of tabs). But when a tab/subcategory is selected, the box/page should nevertheless collapse into just a single bar of a horizontally adjacent tabs, where one tab is then selected. And underneath, the new subcategory selection should then automatically expand. Also, if a user has navigated down into a category tree, but want to go to a different super-category, the user can either just click on some of the visible tabs in the one of the above tab bars (which are aligned vertically adjacent, each with tabs aligned horizontally adjacent), or he/she can expand that given tab box once again.
%%
%%Okay, that was a lot of details to explain a very simple design, but it is nice to have an example to hold on to, and one that does the job. But of course, there could be many other types of design that this Web 2.0 site might start with.
%%
%%Moving on, now that we have a category tree, we should also have some resources in it, of course. So at the same time as the user selects these categories and subcategories, there should be a list of resources at the bottom that is updated in principle whenever the user chooses a new category (although the user might want to click a button manually to make the resource list refresh such that it doesn't refresh al the time while the user is navigating the category tree).
%%
%%When the user then selects a resource from the list, the user is led to a the page of that resource. That resource is then displayed pretty much at the top of that page. And how the resource is displayed then depends on what kind of resource it is, i.e.\ whether it a video or a HTML page, and so on. And each resource should then also have a list of comments below, but similarly to the all the main resources of the site, if we can call them that, these commant should also be ordered in a similar category tree. Examples of different categories of comment could be `related resources,' `user reactions,' `related discussions,' `links to source material,' and so on and so forth. 
%%
%%And to finish up this description of this basic design, there should also be a homepage where each user can see one or more lists of the user's favorite categories and resources, such that the user can quickly navigate to some of their favorite spots in the category tree (without having to start from the root and navigate down).
%%
%%Okay, that was a quick sketch of a quite basic site design. 
%%%
%%%...Jeg har fået tænkt lidt mere. Nu ved jeg faktisk bedre, hvad man skal sige gælder for de rating-tal, der skal følge med sætningerne/tripletterne. Jeg tror ikke, det vil tage mig lang tid at færdiggøre denne hurtige udredning herfra, men lad mig lige se, om jeg lige vil skifte emne lidt og skrive på noget andet, eller om jeg vil holde en lille pause.. 
%%%...Okay, jeg prøver at skrive færdigt..
%%%
%%Now I can get on to some of the stuff that is actually interesting.
%%
%%Assuming that the reader knows about the Semantic Web (and about triplets and so on), the reader might have already guessed that the categorization of the resources should then of course be user-driven. The users should thus be able to say for instance: ``this resource belongs to this category,'' and thereby be able to vote resources into various categories. Note that ``this resource belongs to this category'' can be implemented as a triplet. The users should also be able to say ``this category is a relevant subcategory to show under this other category.'' The users should thus also be in control of the category tree --- and of the category trees under each resource (where one can reuse resource category trees for similar types of resources).
%%
%%So far so good: One thus get a Web 2.0 site where the categorization structure is semantic and user-driven. And because it is semantic, all the user data can easily be reused in for other similar sites, and specifically also for other implementations of the site in question.
%%
%%If such a Web 2.0 site can become more and more popular, and if it is run by an open source organization (and/or community) as mentioned, this site might thus effectively become all that people hope for in terms of what Web 3.0 might bring.
%%
%%Okay, at this point I have explained the overall idea, and also explained an overall type of implementation that could be the starting point for a Web 2.0 site that thus aims to become, what we could call af Web 3.0 site (bringing forth the features that people hope for in Web 3.0). Now I will move on to the \emph{really} intersting stuff, because I actually have a few idea that i believe can make such a ``Web 2.0--3.0 site,'' as I like to call it, really take off! 
%%
%%I actually believe that \emph{triplet} system will not be enough to carry forth a really useful Semantic Web (which is a big part of people associate with Web 3.0)! %(12:44)...
%%
%%First of all, it is important that the ``triplets,'' but let us actually just call them `relations' or `sentences' instead, should contain the user ID of who uploaded it, as well as a timestamp for the upload. So they should not just have the three entries. Second of all, I think it is \emph{so} important for the usability of the system, that each relation/sentence can also include a number (with whatever precision is appropriate for the case) that signifies a rating of \emph{how much} the user believes the sentance to be true. 
%%
%%This makes it possible to \ldots \textit{Okay, jeg har skrevet så meget af det her allerede, så lad mig ikke gentage alle pointerne her, nemlig da jeg nu igen har besluttet mig, at jeg alligevel bare børe vente med at fokusere på dette emne. Så lad mig i stedet bare lige ridse mine nye tilføjelser op.\,.}
%%
%%Okay, let me make this short and just mention the new thoughts that a had about this idea. The rest of the ideas, as well as the explanation of why they will be so good, can be found in my 21--22 notes (in \texttt{main.tex}, as the document is still called in the moment of writing).
%%
%%My big idea for making it easy and attractive to rate the resources on their lists, is that they can simply drag them up and down on the lists to rate them (according to the proposition that they are viewing). So when the user moves the resources in the list around, it should generate sentences/relation to the database, where the rating number in these relations are determined by where the user drops the resource in the list (and where only the most recent adjustment applies (which is what the timestamp is useful for determining)). The number might run from 0 to 1, or from -1 to 1, or whatever; that does not matter much (and the site can always change the conventions and then simply convert the previous data to such that it is scaled to the new convention). And the scale should only be very vaguely defined. The real precision that the user should worry about is how the number related to the neighboring resources on the list. So if the user believes, say, a movie to be incredible, and it has a low rating, the user might want to pull it up closer to 1. But if the question is, should it have a 0.6 rating or a 0.9 rating (assuming 1 is the highest score), that should actually only depend on the existing scores of what movies have received scores in about that interval. So the underlying rating should thus be primarily defined in relation to what resources are already rated. And then! If one wants to turn the resulting rating into one where points on the rating axis is more precisely defined, one can then just (and should be able to), upload a translation of that rating, which is basically a conversion function that takes the primary rating and converts all the numbers to the new rating. This `translation' function can then simply be defined by taking a bunch of resources, plotting them in on the list, and then use statistics after that to plot in all the other resources on that new axis (with an updated metric). And by putting a Gaussian ``error'' on all the ``fixed'' resources on this new axis, one can make sure that this process does not run into contradictions. So in short: The normal rating axis that is used when users drag and drop resources to rate them should have very vaguely defined semantics to begin with, and then the users can always translate the resulting axis from all the user activity into something with a more precise meaning, simply by defining a new metric for the axis that moves the resources into new positions on the axis.
%%
%%I also want to mention that when users drag and drop resources, they should be able to dial up and down the number of resources shown on the list as the drag and drop. Here, a setting to show few items in the list could thus only show the most `popular' items, i.e.\ such that an external predicate can be used for defining this setting, other than the predicate that orders the list. The lists should thus also have `filters,' and these filters should have different settings. And if the user can change these settings by hitting some keys, they can basically ``zoom in and out'' in the lists, namely by changing the filter dial to show fewer or more `popular' items, e.g. The user can then be ``zoomed in'' and chose a resource to rate. The user would then start draging it up or down, but since the list is long when ``zoomed in,'' the users might then hit the key to ``zoom out'' while dragging the resource. And when the user find the desired spot to drop it, the user might even not drop it right away, but ``zoom in'' a bit first to find a more precise spot for the resource. 
%%
%%Okay, I think that was it.\,. no, wait, maybe I also want to quickly reiterate something about the subcategories actually being implemented via `compound predicates,' and also that when rating such predicates, the user actually have to rate each atomic predicate individually (such that the `compound predicates' are not meant for rating, but only showing resources in a list.\,. oh, and then if the user wants to filter the list such that only resources of the one category/predicate is shown while rating resources in terms of another predicate, the user then just has to use the `filter' that I just mentioned.\,.).\,. Hm, no, I think that I have already covered these point in my 21--22 notes (in \texttt{main.tex}). So let me just stop again with this subject for now.\,. 
%%
%%\ldots\ Well, let me just mention another thing quickly, namely that the site might also use some automatically generated meta-sentences/relation, such as: ``this resource was uploaded by this user'' or ``this resource was uploaded as a comment to this resource.'' These are thus automatic sentences/relations that the site itself is responsible for applying to all uploads.
%%
%%.\,.\,Oh, and I also intended to mention something else, by the way: I wanted to mention that certain resources, e.g.\ HTML resources (or other markup), might actually get access to the database themselves. For instance, a HTML document might say ``insert a list of the top resources in this category here'' or something like that. More generally these resources might thus be able to query the database when they are viewed and change their appearance after what is contained in the database. (And this way, the site can thus also implement my so-called ``wiki-idea'' from the 21--22 notes.) 
%%
%%\ldots And yeah, all that jazz about `user groups' to distribute trust, and about the user-driven filter algorithms, about rating tags, and about so on and so forth, all that is written about in my 21--22 note collection, I don't want to try to repeat these things now.\,:) %(14:29)
%%
%%%(07.11.22, 10:32):
%%\ldots\ Oh, and I of course also need to mention an important point, and that is: Sure the idea could work as an organization, but if we think about e.g.\ YouTube and Twitch, the commercial part is a big part of what makes those sites work. And by using my ``Economically Sustainable'' (ES) companies instead, the Web 2.0--3.0 site would still be able to give big rewards to the users who create popular content. And on that topic, if I were in charge of such a company, I would try to bring the average user on as soon as possible, given them some vote and some say in how the creators should get paid (how much in total, perhaps, and more importantly: how it should be distributed). I thus envision an e-democracy using the system described above for all the users, where their decisions in this e-democracy will be heard by the company, at least if it is reasonable (and in fact, the company could also be a part of the e-democracy, giving it self a significant weight on its vote, which would then make it easier for the company to keep to its promise of listening to that e-democracy). And of course, since it is an ES company, this e-democracy will be more a representation of the true power over the company, not just power that is ``lend out'' to the users, as long as their decisions does not stray to much from the company's wishes. *(This last sentence does not seem to make a whole lot of sense, but I guess I just needed to point out that if the company is what I am currently calling an 'SRC,' the users will also eventually get that power \emph{within} the company..)
%
%
%%*(26.11.22, 9:01) I mentioned movies at some point above as an example of a category of resources. That does not mean that the site then has to contain all the movies themselves; the resources can simply be reference-type resources (such as kind of movie ID, etc.). And since users should be able to control how resources in different categories are generally viewed, meaning that they can add HTML-wrappers to the resources, they can thus make it so that all movie refernce resources are viewed with potential links to site where they can be viewed or what not (the HTML code can fetch anything that is desired from the database (and/or from the web)). 
%
%
%*(20.12.22) I should also mention, that I imagine that all sentences/relations (formerly known as triplets) should be signed by a private key of the user, which is publicly associated with the (or \emph{is} the) user ID. This way you don't have to trust the particular server when it comes to who uploaded what and when. 






















\end{document}